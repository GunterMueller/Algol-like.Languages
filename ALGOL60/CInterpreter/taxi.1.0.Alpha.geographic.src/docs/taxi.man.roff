.RP no
\R' FL \n[LL]'
.fam T
.EQ
delim @#
.EN
.TL
\fHtaxi\fR MANUAL
.ps 12
.AU
by Antonio Maschio
programmer in Montebelluna (TV) - Italy
.AI
with the great help of Ian Jones
programmer in Bristol (UK)
and Bruce Axtens
programmer in Western Australia (AUS)
.AB
.fam C
                                            
                  |              _|
                    _  _|           
                      |  __ \\   \\ /   |
                      |   _\\ |   \\    |
                     _|  \\___| _/_\\  _|

.fam T
Welcome to the world of \fHtaxi\fR! \fHtaxi\fR is a console 'boy' ALGOL 60 interpreter, based mostly on the DEC system-10/20 ALGOL and on the ISO 1538-1984 (E) standard. 

Read also the \fHtaxi\fR man page for other more general info and the installing instructions.

Readers are encouraged to report all errors and inconsistencies found (both in the program and in the manual) to

.fam C
.ce
ing dot antonio dot maschio at gmail dot com
.fam T

Unlike a common taxi, this \fHtaxi\fR won't ask you for a fare, doesn't matter how much far you can get from here. It will only ask you for a voluntary contribution, to be made through PayPal (any amount), just to support my work and let me know you like it. Donations can be directed to 

.fam C
.ce
tbin at libero dot it
.fam T

Thanks in advance to anyone of you who will contribute. And thanks anyway to anyone of you who will download and take a trip with this \fHtaxi\fR!
.AE
.pn +2

.bp 1

.DS R
\fIThis work is dedicated to the memory\fR
.br
\fIof \fRHeinz Rutishauser\fI (1918-1970),\fR
.br
\fISwiss mathematician and computer scientist\fR
.DE
.bp 1
.fam C
 
 























.fam T

.bp 3
.NH 1
.ds IND00 \*[SN-NO-DOT]
INTRODUCTION
.XS
\*(SN 		\fBIntroduction\fR
.XE
.LP
This manual illustrates the ALGOL language understood by \fHtaxi\fR, which must be written always in lower letters (so no Taxi, TAXI or the like).

\fHtaxi\fR (which means \fBT\fRonibin's \fBA\fRlgol si\fBX\fRty \fBI\fRnterpreter) is a boy implementation of the ALGOL 60 language; ALGOL is an abbreviation of ALGOrithmic Language, and 1960 is the year when it was defined. 

This document mimics the DEC system-10/20 ALGOL manual, paraphrased and integrated; it helps in using correctly the various statements, procedures and their options, using output examples for all the procedures, something that both the DEC system-10/20 ALGOL manual and the ISO 1538-1984 (E) document lacked\*[*]. 
.FS
I retained the term \fIprocedure\fR to identify both procedures (i.e. sequences that don't return a value) and functions (i.e. sequences that return a value), as in the DEC manual, retaining the \fIfunction\fR term only for mathematical issues. This is of little importance, because an ALGOL programmer knows the difference that procedures are called directly, while functions cannot, and that functions can enter any expression, while procedures cannot.
.FE

\fHtaxi\fR reads a textual program file and executes its instructions by interpretation, not by compilation. The interpreter is equally responsible for detecting errors in the user's source program and reporting them to the user, under the "First Error Stops Execution" Law. With modern machines, an interpreter can process ALGOL programs faster than a compiler of the Seventies and does not require the use of any backing store. Therefore, the fact \fHtaxi\fR is an interpreter will not affect the user.

For the specific features, please refer to the various sections of this manual. For the definitions of used terms, see Section 1.2 in particular. I just want to underline here the fact that I created \fHtaxi\fR with a specific goal in mind: security: security. I have not created it with the goal of execution speed. I rather want it to be safe. (I wouldn't want SIGSEGV errors or memory corruption messages to occur when running \fHtaxi\fR. And if it should happen, please write to me immediately.)

NOTE: in this manual, all code examples are written in \fCUPPER TYPEWRITER CASE\fR, to differentiate the listing from the common text; anyway, consider that \fHtaxi\fR is case insensitive for the builtin procedures and literal operators (that is \fCPRINT\fR and \fCprint\fR, or \fCEQV\fR and \fCeqv\fR, are the same items), and case-sensitive for all user items, that is variables and arrays names, procedure names, string contents. 

NOTE: all 
.UL "underlined references"
are references to the original documents they point to, and do not refer to parts of this manual. 

.NH 2
.ds IND10 \*[SN-NO-DOT]
A BIT OF HISTORY
.XS
\*(SN 			A bit of history
.XE
.LP
ALGOL was born (let me say) on May 2, 1958, during a meeting held in Z\[:u]rich between the great scientists of the American Association for Computing Machinery (ACM) and the European Society of Applied Mathematics and Mechanics (GAMM, in German words).

Those scientists were mainly F.L. Bauer, H. Bottenbruch, H. Rutishauser and K. Samelson of the GAMM, and J. Backus, C. Katz, A. Perlis and J.H. Wegstein of the ACM (Wikipedia source).

The first concept of the language was named IAL (International Algebraic Language), but it soon became ALGOL 58 when the rumours about it were spread enough. This first version is important because it is the first based on the '\fCBEGIN-END\fR' blocks model (the compound statements technique), that major languages would fully adopt years later (Pascal, C, Java, etc.) It was curious also because of the particular \fCFOR\fR cycle, with the step specified inside parentheses. 

By the end of 1958 the four Universities in Z\[:u]rich, M\[:u]nchen, Mainz and Darmstadt (collectively known as ZMMD) were working on an ALGOL-58 compiler for the Z22 computer. I cite this because Z\[:u]rich was the place where Heinz Rutishauser worked\*[*].
.FS
More in 
.pdfhref W -D https://en.wikipedia.org/wiki/Heinz_Rutishauser https://en.wikipedia.org/wiki/Heinz_Rutishauser
.FE 

The first report on ALGOL 60 was written on January 11-16, 1960, during a conference held in Paris. The scientists that convened were more or less the same as the 1958 meeting: L. Bauer, P. Naur, H. Rutishauser, K. Samelson, B. Vauquois, A. van Wijngaarden and M. Woodger for the European side, and J.W. Backus, J. Green, C. Katz, J. McCarthy, A.J. Perlis and J.H. Wegstein for the American side (Wikipedia source). Note the presence in the works of two important scientists, doctor J. Backus and doctor P. Naur, who will later develop the famous Backus-Naur notation for context-free grammars, still used today for the material definition of programming languages. Actually, ALGOL was maybe the first language to adopt this notation.

Anyway, the ALGOL 60 definition left several features undefined, notably the input/output procedures; this permitted the various implementers of the language some freedom in interpreting these lacking features, sometimes with too much liberty (for instance the Dartmouth Algol, which was given more or less the input/output features of the coeval BASIC language). 

Many of these lacking features were discussed extensively from 1960 until 1962 when the "Revised Report on the Algorithmic Language ALGOL 60", also known as the "Revised Report", was published, as acts of the \fIInternational Federation for Information Processing\fR (IFIP) in 1962 in Rome (again an European town!) This revised report solves some but not all the problems of the language.

In 1972, a preliminary ISO version, based upon the "Revised Report", was published by ISO as the "Recommendation 1538 (1972)", but the IFIP technical committee refused to recognise this document as valid. 

Later, in 1976, after many other meetings, the IFIP Committee ultimately approved the "Modified Report on the Algorithmic Language ALGOL 60", known since then as the "Modified Report", that was issued on The Computer Journal, Vol. 19, No. 4, Nov. 1976, pages 364\[di]379. The primary subject of discussion was the \fIrecursion\fR, that someone reputed not suitable for ALGOL, while some others felt it was a necessary feature\*[*]. A paladin of the recursion was the European Computer Manufacturers' Association (ECMA), an influential institution that published many texts about programming, most of them (if not all) are available today as pdf files and freely downloadable\*[*].
.FS
More here: https://vanemden.wordpress.com/2014/06/18/how-recursion-got-into-programming-a-comedy-of-errors-3/
.FE 
.FS
See here: https://www.ecma-international.org/publications/standards/Standard.htm
.FE

The authoritative definition for the ALGOL 60 language is contained in the final ISO 1538-1984 (E) standard, published in October 1984, which is extensively based on the Modified Report. This Standard is nowadays abrogated, but still a milestone in ALGOL.

In my humble opinion, one of the most useful versions of ALGOL was developed by the Digital Equipment Corporation (DEC), running on the famous PDP computers. The version I consulted was the one targeted for the DEC system-10/20 (namely the AA-0196C-TK 1977 protocol). The DEC system-10/20 ALGOL was robust and sufficiently adherent to the Algol-60 philosophy, with its performant input/output procedures, that plainly coexists with the ISO protocol.

\fHtaxi\fR uses by default the DEC protocol, with the addition of the ISO features, when not in contradiction with such protocol. 
.NH 3
.ds IND20 \*[SN-NO-DOT]
Restrictions with respect to the DEC System-10/20 ALGOL
.XS
\*(SN 			Restrictions with respect to the DEC System-10/20 ALGOL
.XE
.LP
\fHtaxi\fR imposes the following restrictions with respect to DEC system-10/20 ALGOL, partly due to the fact that it runs on modern 64 bits machines, and partly due to my ineptitude:
.IP 1. 0.4i
Integers are limited to the range -2,147,483,648 to 2,147,483,647 (was -34,359,738,367 to 34,359,738,367). The sign appearing before the number is part of the number (optional in case it is \fC+\fR).
.IP 2.
Octal numbers are limited to 11 digits (was 12)
.IP 3.
ASCII constants are limited to four characters (was five), and the character enclosing the ASCII constant can be any but not the space character.
.IP 4.
An array element cannot be chosen as the controlling variable in a \fCFOR\fR statement.
.IP 5.
In inputting numeric data through \fCREAD\fR, only digits and dots can appear in the data to be read, along with the exponent signs (\fCE\fR, \fC&\fR or \fC\@\fR for real, \fCEE\fR, \fC&&\fR or \fC\@\@\fR for long real); spaces and tabulation characters can appear anywhere, they will be removed before recognition.
.IP 6.
Logical devices do not set the end-of-file flag in input or output, acting as a circular data structure.
.IP 7.
Channels 0 and 1 are not available as normal I/O channels and are always linked respectively to the standard input from the keyboard and to the standard output to the screen. This cannot be changed (as a safety measure) to have a secure channel for any useful input or output scope (i.e. as a standard error report stream). Thus, modifiable device channel numbers are limited to the range 2\[di]15.
.IP 8.
Values bits of the procedure \fCIOCHAN\fR are not all meaningful in the sense of UNIX and in this case they are not used, but remain readable.
.IP 9.
Third and fourth arguments of procedures \fCINPUT\fR and \fCOUTPUT\fR (binary or textual format type, and buffering depth) are ignored.
.IP 10.
Built-in procedure names are always represented in the reserved word format; the non-reserved words enclosed in single quotes (ticks) are not allowed. Modern languages adhere to this philosophy. Moreover, the whole DEC system-10/20 ALGOL manual is written according to the reserved word format. If you have a listing in non-reserved words, you can use option \fC--purge\fR to get the correct version of the program and try if \fHtaxi\fR can digest it.
.IP 11.
This interpreter \fHtaxi\fR is a boy interpreter. (See par. 1.1.5 "A necessary clarification".)
.LP
.NH 3
.ds IND30 \*[SN-NO-DOT]
Enhancements with respect to the DEC System-10/20 ALGOL
.XS
\*(SN 			Enhancements with respect to the DEC System-10/20 ALGOL
.XE
.LP
\fHtaxi\fR implements the following extensions to the DEC system-10/20 ALGOL:
.IP 1. 0.4i
The double-precision of C permits a reasonably good performance with the ALGOL \fCREAL\fR type; the \fCLONG REAL\fR type of the DEC system-10/20 ALGOL is added, equivalent to FORTRAN's double-precision, but the two types are stored in the same C double type, so the difference is only in the output picturing; thus, the user can access the power to handle double-precision real numbers even with the \fCREAL\fR type, without caring about the \fCREAL\fR/\fCLONG REAL\fR conversion issues.
.IP 2.
Numeric labels are available (they are treated as any other alphanumeric label).
.IP 3.
The new procedures \fCWRITELN\fR, \fCPRINTLN\fR, \fCCREATEFILE\fR, \fCVPRINT\fR, \fCCLOCK\fR, the new constants \fCINF\fR, \fCERRL\fR, \fCERRC\fR, \fCPI\fR and the new string procedures \fCHEAD\fR, \fCTAIL\fR, \fCTAKE\fR, \fCDROP\fR, \fCCONVERT\fR are provided.
.IP 4.
Some DEC procedures have different features or scopes: \fCSIZE\fR, \fCCALL\fR, \fCDUMP\fR, \fCONTRACE\fR, \fCOFFTRACE\fR, \fCGFIELD\fR, \fCSFIELD\fR.
.IP 5.
All the trigonometric and hyperbolic procedures and their inverse, along with \fCERF\fR, \fCGAMMA\fR and \fCINTEGRAL\fR (to calculate a finite integral) are provided; also, new procedures for value conversion are provided: \fCDEGREES\fR, \fCRADIANS\fR, \fCTOLONG\fR, \fCTOREAL\fR.
.IP 6.
All variables are instantiated with zero (if numeric) or with the null string (if strings or labels), though this is required neither by the ISO 1538-1984 (3.1.5 comma 1) nor by the DEC protocol. This is extended to the fictitious variables created to store the return value of procedures. This guarantees that no uninitialized variables are used in a program.
.IP 7.
The restriction that forced variables and arrays to be declared before procedures and switches has been removed. Also, variables and arrays can be declared anywhere in the listing, even after some procedure has executed. 
.IP 8.
The restriction, in the definition of the arguments of a \fCPROCEDURE\fR, that forced \fCVALUE\fR items to be declared before types, has been removed; arguments and specifiers can be set in any order, before the procedure instructions. Besides, in the body of a procedure, the assignment of a referenced variable which is passed a numeric expression is possible.
.IP 9.
Third and fourth arguments of the procedure \fCOPENFILE\fR (protection code in the sense of DEC Operating System and project-programmer number) have been changed to: protection code - in UNIX sense - and content-deletion flag (i.e. if true, delete file content before opening).
.IP 10
The string procedure \fCCONCAT\fR has been enabled to concatenate all strings in the list of arguments, separated by a comma (therefore, also more than two).
.LP
.NH 3
.ds IND40 \*[SN-NO-DOT]
Differences with the ISO 1538-1984
.XS
\*(SN 			Differences with the ISO 1538-1984
.XE
.LP
Differences with the ISO 1538-1984 Standard features are here listed:
.IP 1. 0.4i
Strings are enclosed in double-quotes (either using the \fC"\fR character or using two instances of the single quote \fC''\fR). The ISO 1538-1984, instead, uses consistently strings with different characters for the opening and closing. The whole examples in par. 2.6.2 were built in such a way. \fHtaxi\fR adopts the DEC system-10/20 ALGOL point of view (modern and concrete), and strings are enclosed in quotes that must be the same for opening and closing the string. All other characters - but the double quote \fC"\fR - represent themselves, and the double-quote literal is represented with a double instance of it \fC""\fR (unless this represent the empty string). In case of strings enclosed in double instances of the single quote (\fC''\fR), a single instance of the quote character or a single instance of the double-quote character represents itself.
.IP 2
New ISO-like procedures are provided in completion to the ones described in the Environmental Block in ISO1538-Appendix 2: \fCINSTRING\fR, \fCINLONGREAL\fR, \fCOUTLONGREAL\fR, \fCOUTBOOLEAN\fR, \fCINCHARACTER\fR, \fCOUTCHARACTER\fR, 
.IP 3 
New ISO-like procedures for array input/output are provided, following the suggestions in the Heinz Rutishauser's book: \fCINARRAY\fR and \fCOUTARRAY\fR, for numeric arrays.
.IP 4.
All procedures in the Environmental Block in ISO document in Appendix 2 are hardwired in \fHtaxi\fR code. It's always possible to implement them in ALGOL, but their output may differ.
.IP 5.
The logical operators \fCAND\fR, \fCOR\fR, \fCIMP\fR and \fCEQV\fR in the ISO 1538-1984 follow a proper syntax (cf. 3.4.5), which \fHtaxi\fR incorporates; so \fC/\\\fR is \fCAND\fR, \fC\\/\fR is \fCOR\fR, \fC->\fR is \fCIMP\fR and \fC==\fR is \fCEQV\fR (the ASCII table lacks some specific logic symbols). The usage of such ISO operators is maybe not entirely portable.
.IP 6.
The precedence of \fCNOT\fR is coordinated with the negative sign for any item; This means it is evaluated immediately. This has a stronger binding than what the ISO 1538-1984 requires, that is a lower precedence with respect to the arithmetic and relational operators (cf. 3.4.6.1).
.LP

.NH 3
.ds IND50 \*[SN-NO-DOT]
The documented sources
.XS
\*(SN	 		\fBThe documented sources\fR
.XE
.LP
Here are the links to the documents upon which \fHtaxi\fR is based.

The last revision of the DEC system-10/20 ALGOL manual AA-0196C-TK dates back to April 1977. It can be found here:

.pdfhref W -D http://bitsavers.informatik.uni-stuttgart.de/pdf/dec/pdp10/TOPS10_softwareNotebooks/vol06/AA-0196C-TK_ALGOL_Programmers_Guide_Apr77.pdf AA-0196C-TK_ALGOL_Programmers_Guide_Apr77.pdf

The ISO 1538-1984 (E) First edition, titled "Programming languages - ALGOL 60", was published on October 15, 1984, and no other editions exist, to my knowledge. This norm is now abrogated, i.e. it has no scope and validity; firstly, because few ALGOL systems did effectively follow the ISO protocol, and secondly because ALGOL is not used anymore for serious programming. From now on, this document will be referred to as the \fIISO protocol\fR. It can be found here:

.pdfhref W -D http://www.softwarepreservation.org/projects/ALGOL/report/ISO1538.pdf http://www.softwarepreservation.org/projects/ALGOL/report/ISO1538.pdf

The Revised Report can be easily found on the Internet in various formats. The best version, to my knowledge and taste, edited by Peter Naur and Approved by the council of the International Federation for Information Processing, can be found here:

.pdfhref W -D http://ddhf.dk/site_dk/rc/algol/algol60.pdf http://ddhf.dk/site_dk/rc/algol/algol60.pdf

An interesting commentary on the ALGOL 60 Revised Report, by Morgan, Hill & Wichmann, can be found here:

.pdfhref W -D http://archive.computerhistory.org/resources/text/algol/ACM_Algol_bulletin/1061659/p5-de_morgan.pdf http://archive.computerhistory.org/resources/text/algol/ACM_Algol_bulletin/1061659/p5-de_morgan.pdf

The final and definitive version of the Revised Report called Modified Report (upon which the ISO 1538-1984 (E) is modelled), which also takes into account the previous Morgan, Hill ad Wichmann commentary, can be found here:

.pdfhref W -D http://hack.org/mc/texts/modified-report.pdf http://hack.org/mc/texts/modified-report.pdf

If you want to read an interesting article about ALGOL 60, titled "ALGOL, a simple explanation", by Richard F. Clippinger, from the November 1962 review "Computer and Automation", this can be found here (download the entire review):

.pdfhref W -D http://bitsavers.informatik.uni-stuttgart.de/pdf/computersAndAutomation/196211.pdf http://bitsavers.informatik.uni-stuttgart.de/pdf/computersAndAutomation/196211.pdf

The best book about ALGOL? It's the book "Description of Algol 60" by Heinz Rutishauser, written in 1967; it's freely available here (in English):

.pdfhref W -D http://www.algol60.org/docs/Rutishauser_Description_of_ALGOL_60_1967.pdf http://www.algol60.org/docs/Rutishauser_Description_of_ALGOL_60_1967.pdf

The manual of the Algol-20 environment designed at the Carnegie University in Washington DC can be found here:

.pdfhref W -D https://pdfs.semanticscholar.org/ea76/345e03baefd8923c197f25a26c9d3ce75bf1.pdf?_ga=2.217384277.2120336152.1580545214-1759669248.1580545214 https://pdfs.semanticscholar.org 

The Unisys Algol manuals, printed in 2001 for a very advanced and detailed version of Algol 60, can be found here in two volumes:

Volume 1:
.br
.pdfhref W -D https://public.support.unisys.com/aseries/docs/ClearPath-MCP-17.0/PDF/86000098-515.pdf https://public.support.unisys.com/aseries/docs/ClearPath-MCP-17.0/PDF/86000098-515.pdf

Volume 2:
.br
.pdfhref W -D https://public.support.unisys.com/aseries/docs/ClearPath-MCP-17.0/PDF/86000734-307.pdf https://public.support.unisys.com/aseries/docs/ClearPath-MCP-17.0/PDF/86000734-307.pdf

There are many other manuals for the Algol 60, built by American and European (and even Chinese) Universities, and freely available on the Internet, not detailed here.

Finally, I couldn't have finished without mentioning a wonderful site dedicated to Algol, created and maintained by Henry Levkine, full of documentation, examples, tutorials, articles, algorithms and more. You can find it here:

.pdfhref W -D http://www.algol60.org http://www.algol60.org

I hope you will like all this.
.NH 3
.ds IND60 \*[SN-NO-DOT]
A necessary clarification
.XS
\*(SN 			A necessary clarification
.XE
.LP
The 'man-or-boy' test was designed by Donald Knuth as a means of evaluating implementations of the ALGOL 60 programming language. The scope of the test was to distinguish compilers that correctly implemented "recursion and non-local references" from those that did not (from Wikipedia). More news here:

.pdfhref W -D https://en.wikipedia.org/wiki/Man_or_boy_test https://en.wikipedia.org/wiki/Man_or_boy_test

However, the stack-structure of the built-in variables storage of \fHtaxi\fR prevents the adherence to the \fIman\fR protocol; therefore, at present, \fHtaxi\fR is a \fIboy\fR interpreter.

I've planned to solve this, but I must observe that the current \fHtaxi\fR model does not prevent at all the normal programming. At present, and unless a further disproof, it fails only the Knuth man-or-boy family tests. 
.NH 3
.ds IND70 \*[SN-NO-DOT]
Compiling \fHtaxi\fR
.XS
\*(SN 			Compiling \fHtaxi\fR
.XE
.LP
To compile \fHtaxi\fR, you can simply run '\fCmake\fR' and '\fCmake install\fR' in the source directory, but I suggest taking a preliminary look at the file \fCcustom.h\fR, before compiling, to customize some parameters, if you need. Here they are.

.IP 1. 
\fBDefault page height\fR
.br
constant \fCDEFPAGEHEIGHT\fR (default value 68)

Use your printer page height; it's the height for simple textual files (it is a fixed size, based on the typographical characters of your printer; if you don't know this value, to retrieve it follow these steps:
.RS
.IP - 
write a textual file with 100 lines at least. This file should contain numbers (one for each line) and nothing else; void lines count, but they must be followed by filled lines; using void lines spares ink, but assure the lines count is correct and use a full line as the last forty.
.IP - 
call the file for instance \fCph.txt\fR.
.IP - 
put recycling paper into your printer (to save new paper)
.IP - 
from the console, type
.br
\fC$ lpr ph.txt\fR

or 

\fC$ cat ph.txt | lpr\fR

.br
If \fClpr\fR is not installed, find out which is the line printer command; let's call it '\fCmylpr\fR' for the sake of the example, and use it as previously explained.
.IP - 
Count how many lines are printed in the first printed page, including the empty lines; this number, that should be in the range 50..70, is the number to put after \fCDEFPAGEHEIGHT\fR
.RE

.IP 2. 
\fBDefault printer command\fR
.br
constant \fCROUTESTRING\fR (default value "\fClpr\fR")

Leave \fClpr\fR, if it's installed on your system, otherwise, put your own (to follow the previous example, '\fCmylpr\fR' - see point 1)

.IP 3. 
\fBMaximum number of loadable libraries\fR
.br
constant \fCEXTERNLIBMAX\fR (default value 64)

Put here the number you need, or leave 64 (which is sufficient for almost all tasks, as far as I can think).

.IP 4. 
\fBExecutable position\fR
.br
constant \fCCALLEX\fR (default value "\fC./taxi \fR")

If you run \fHtaxi\fR from the source directory, leave this value; if you install \fHtaxi\fR, write here simply \fC"taxi"\fR; remember that one space  must follow the executable name; remember also that you can put here some options if you need; this is the command that invokes programs through \fCCALL\fR (see 17.5).
.LP

After changing, or not, the file \fCcustom.h\fR, you can compile and install; anyway, while '\fCmake\fR' requires no root privileges (provided you own the rights to work on the source directory), '\fCmake install\fR' can be run only by root, or by a member of the sudoer group (with \fCsudo\fR). In case you cannot install the program, ask your administrator.

You can alternatively change the destination path in makefile, and drive the installation to a directory of your \fC$HOME\fR, to make \fHtaxi\fR available only for you. In this case, there's no need for root privileges.
.NH 3
.ds IND80 \*[SN-NO-DOT]
The Running Process
.XS
\*(SN 			The Running Process
.XE
.LP
The \fHtaxi\fR interpreter follows these steps:
.IP 1. 0.4i
The whole program is loaded in memory; during this phase, all comments are removed, all labels are analyzed and removed and their position is saved for later referencing, all operators constituted by more than one character are changed to a one-character symbol (for instance: \fCAND\fR becomes \fC_\fR); finally, all spaces out of a string are removed. The resulting compact meta-text is what \fHtaxi\fR stores and sees.
.IP 2.
The whole meta-text is parsed for determining the inner program structures (mainly \fCBEGIN-END\fR blocks, \fCIF-THEN-ELSE\fR, \fCFOR\fR and \fCWHILE\fR positional parameters, \fCPROCEDURE\fR declarations data); this causes a certain negligible runtime excess before program start but also speeds up the running phase, and this gain in speed is increased in case of cycles because the calculation for relative jumps is done once only.
.IP 3.
Being an interpreter, any error occurring in the preliminary phase, any logic error (not detected by the preliminary phase) or any syntax error (for instance using \fC=\fR instead of \fC:=\fR) in the run-time phase stops execution by printing an error message, with the (hopefully precise) position of the error in the line that caused the error. The printed line is the full line text (not the meta-text of previous point 1). The typical run-time error scheme is as follows (supposing \fCCARC\fR is meaningless for the current program):

.fam C
  taxi runtime processor error in the program at line 13:
  Illegal name.
  k:=234545; I:=CARC(3.0,ss[k]);
              ^
  Error code 46
.fam T

The indicated position may slightly differ from the correct error position. In case the error is detected in the pre-processing phase, the error scheme is slightly different, as follows:

.fam C
  taxi preprocessor error in the program at line 1:
  Irregular program flow. Check blocks.
  Error code 23
.fam T

No indicator is printed in this case, because an error in the preprocessor is a more general error, not confined in one line or position, but involving a whole structure. (For instance a \fCBEGIN\fR without \fCEND\fR.)
.NH 3
.ds IND90 \*[SN-NO-DOT]
Calculation issues
.XS
\*(SN 			Calculation issues
.XE
.LP
There are some subtle differences between a number in memory and the representation of it. 

Let's take an example. If the exponents of two numbers involved in a calculation are similar and not too different, the calculation is possible, and a correct (or so) result is returned. Suppose for instance the following addition is required:

.fam C
  long real x,y;
  x:=2.3&&45;
  y:=4.5&&46;
  outlongreal(0,x+y);
.fam T

The difference between the two numbers is small, and the result is the correct value

.fam C
   4.73000000000000220&&46
.fam T

(ignore rubbish at the end). But if the following is calculated:

.fam C
  long real x,y;
  x:=2.3&&145;
  y:=4.5&&6;
  print(x+y);
.fam T

(see the huge difference in the exponents) a poor 

.fam C
   2.30000000000000071&&+145
.fam T

is returned (again, ignore rubbish at the end). In practice, the addition is not performed at all. How come? Because \fCy\fR happens to be in the 'rumour' of \fCx\fR, and cannot be contained in the representation of it.

Another problem concerns the integer type in mixed calculations. In an integer expression, the result is accurate up to 32 bits (-2147483648\[di]2147483647 for signed values, i.e. @2 sup 31# as magnitude); if instead you put it into an expression involving real or long real values, you'll probably lose precision, halving the interval (at about -1000000000\[di]1000000000 i.e. @2 sup 30# as magnitude). Keep this in mind when performing mixed calculations involving high values numbers.

One more problem is hidden in the round-off errors in representing the number in memory. See for instance the file \fCpreci.alg\fR in the \fCfiles/\fR directory of the installation folder of \fHtaxi\fR: you will see that DEC and ISO represent numbers in different ways, but all suffer from some errors in the last decimals (see for instance https://en.wikipedia.org/wiki/Round-off_error).

Last, but not least, also the errors involved in repeated calculations must be taken in account, and cannot be avoided, because the round-off error accumulates, reducing the possible precision in the result. This can be said for all calculations that do repeated summing of expression (for instance the procedure \fCINTEGRAL\fR, built-in in \fHtaxi\fR, which suffer this problem and reduce the precision to 10/11 digits). Another known problem is called \fIcancellation\fR had happens when two floating-point numbers are subtracted: this may reduce dramatically the precision of the result.

I think that an ALGOL programmer should be aware that it's practically impossible yielding \fIexact\fR result from a floating-point expression. One must hope that there are sufficient acceptable digits, or put automatically in mind that when 24.999999999 is met, this means 25.0 (the error is small, but it totally cancel the correct representation of the number).
.NH 2
.ds IND100 \*[SN-NO-DOT]
TERMINOLOGY
.XS
\*(SN 			Terminology
.XE
.LP
Although the terms used in this manual may seem familiar to the experienced programmer, I suggest that you carefully read the following definitions, because the ALGOL jargon is not common today and can result incomprehensible or misleading.

.IP "\fBDelimiter Word\fR"
a single, English language word that is an inherent part of the structure of the ALGOL language. Such words cannot normally be used for other purposes. Examples:
.br
\fCBEGIN\fR \fCIF\fR \fCARRAY\fR.

.IP "\fBTerminator Word\fR"
a single, English language word or sign that is used to terminate a block of code. Such words are \fCEND\fR, \fCELSE\fR, semicolon.

.IP \fBIdentifier\fR
a name, established by a user declaration, that represents some quantity within a program or is set as a specific name for a procedure.

.IP "\fBLabel\fR"
an identifier used to mark a certain position in a program. Control of program execution can be transferred to the statement following the label. Unlike the DEC system-10/20 ALGOL, a numeric label, similar to a FORTRAN statement number, is available in \fHtaxi\fR ALGOL.

.IP "\fBProcedure\fR"
part of a program, which may be invoked by \fIcalling\fR. In general, an indefinite number of parameter can be supplied as arguments. No result is be returned. A procedure may be invoked as a command in the listing.

.IP "\fBParameter\fR" 
See also Procedure.
.br
A Formal Parameter is an identifier, used within the procedure, that represents the argument supplied when the procedure is called.
.LP
.bp
.NH 1
.ds IND110 \*[SN-NO-DOT]
PROGRAM STRUCTURE
.XS 
\*(SN 		\fBProgram structure\fR
.XE
.LP
.NH 2
.ds IND120 \*[SN-NO-DOT]
BASIC SYMBOLS
.XS
\*(SN 			Basic symbols
.XE
.LP
An ALGOL program consists of a sequence of symbols from the ASCII character set. The meaning of individual characters given in Table 2-1 is much the same as in other high-level languages.

.B1
.CD
Table 2-1
Basic Symbols

.DE
.fam C
 Symbol    Meaning or Use
.ps 9
.vs -3
 -----------------------------------------------------------------
 A-Z a-z   Used to construct identifiers for variables and procedures

    _      Underscore. Used to construct identifiers and 
           delimiter words. Also used as AND token
  
   0-9     Decimal digits; used to construct numeric constants 
           and identifiers.
  
   + -     Arithmetic addition/subtraction operators.
  
    *      Arithmetic multiplication operator.
  
    /      Arithmetic division operator.
  
    \\      Arithmetic integer division operator.
  
    \[di]      Arithmetic integer division operator (ISO)
  
    ^      Arithmetic exponentiation operator.
  
   ( )     Parentheses; used in arithmetic expressions and to 
           enclose parameters in procedure specifications and calls.
  
   [ ]     Square brackets; used to enclose subscript bounds in 
           array declarations, and array subscript lists.
  
    ,      Comma; general separator, placed subscripts, procedure 
           parameters, lists, between array items, in switch lists.
  
    .      Decimal point; used in numeric constants and byte subscription
           Also, used as a readability symbol in identifiers.
  
    ;      Semicolon; used to terminate statements.
  
    :      Colon; used to indicate labels, and separate lower
           and upper bounds in array declarations.
  
   = #     Equality and non-equality for arithmetic/string comparisons.
  
   < >     Less than, greater than.
  
  & \@ E    Introduces exponent in floating-point numbers.
  
    '      Opening and closing string quotes when used doubled ''.
  
    "      Opening and closing string double-quotes.
  
    !      Comment (not portable;) also used as IMP token.
  
   % $     Octal and ASCII constants.
   
    ~      Tilde; Logical NOT (ISO)

    `      Inverse tick; REM token

.fam T
.B2
.LP

NOTE: the \fCE\fR symbol for the exponent in floating-point numbers was not a standard for ALGOL. The DEC system-10/20 ALGOL could understand numbers read from a file written with \fCE\fR (if coming for instance from a FORTRAN output) or \fCD\fR (if coming from a FORTRAN output with double-precision numbers), but its primary input/output characters were only \fC&\fR or \fC\@\fR. \fHtaxi\fR is consistent in all the environments, so a number read from a file or keyboard may have \fCE\fR, \fC&\fR or \fC\@\fR or \fCD\fR as the exponent symbol, and you can choose the exponent to be printed between \fCE\fR, \fC&\fR or \fC\@\fR using the option \fC--exp=X\fR from the console\*[*], where \fCX\fR is the chosen ASCII character. The default is \fC&\fR.
.FS
I omit the output with \fCD\fR because it's not Algol and definitely out of date.
.FE
.NH 2
.ds IND130 \*[SN-NO-DOT]
COMPOUND SYMBOLS
.XS
\*(SN 			Compound symbols
.XE
.LP
Compound symbols consist of two adjacent basic symbols. Any intervening spaces or tabs do not affect their use. The compound symbols are shown in Table 2-2.

.B1
.CD
Table 2-2
Compound Symbols
.DE
.fam C
  Compound    Usage
   Symbol
.ps 9
.vs -3
 -----------------------------------------------------------------
     :=       Assignment (also <-)

     **       Arithmetic exponentiation operator (alternate form)
      
     <=       Less than or equal to (also =<)

     <>       Not equal (also ><)

     >=       Greater than or equal to (also =>)

     /\\       Bitwise AND (ISO)

     \\/       Bitwise OR (ISO)

     ->       Logical IMP (ISO equivalent) (also >>)

     ==       Logical EQV (ISO equivalent) (also <->)

   && \@\@      Used for the LONG REAL output format
     
     ~=       Not equal (also !=)

.fam T
.B2
.LP

NOTE: the \[<-] character as an alternative to the assignment symbol is implemented as \fC<-\fR, because modern keyboards don't have this key anymore. (The symbol nowadays is rather associated with the backward key function.) 
.NH 2
.ds IND140 \*[SN-NO-DOT]
RESERVED WORDS
.XS
\*(SN 			Reserved words
.XE
.LP
Certain letter combinations are reserved as part of the structure of the language and cannot be used as identifiers or part of identifiers.

For instance, to determine the \fCBEGIN-END\fR levels, an important phase in the pre-processor, \fHtaxi\fR looks for each \fCBEGIN-END\fR pair, storing the positions and other data, useful to the run-time phase to know where to jump. But a variable or a procedure named or containing \fCBEGIN\fR or \fCEND\fR will influence the pre-processor, which will certainly fail in finding all pairs coupled.

The same can be said for instance for \fCWHILE\fR, \fCFOR\fR, \fCDO\fR and so forth.

Table 2-3 contains a list of all the reserved words used in \fHtaxi\fR.

.B1
.CD  
Table 2-3
Reserved Words 

.DE
.fam C
.ps 9
.vs -3
 -----------------------------------------------------------------

        ; (semicolon)                            INCLUDE
        ARRAY                                    INTEGER
        BEGIN                                    LABEL
        BOOLEAN                                  LONG REAL
        COMMENT                                  OWN
        DO                                       PROCEDURE
        DUMP                                     REAL
        ELSE                                     STEP
        END                                      STRING
        EXTERNAL                                 SWITCH
        FOR                                      THEN
        FORWARD                                  UNTIL
        GO TO                                    VALUE
        IF                                       WHILE

.fam T
.B2
.LP

The semicolon is not an identifier of course; it was included in this list because it is substantial, and cannot be employed in purposes other than as a terminator.

The \fCLONG REAL\fR terms are reserved only if used consecutively, as reported. The word \fCLONG\fR can be used as an identifier until it is never used before \fCREAL\fR.

A special class of reserved words are the terminator delimiter words (a subset of the previous list, actually), that greatly influence the program structure. In Table 2-4 they are fully explained.

.B1
.CD
Table 2-4
Terminator Words

.DE
.fam C
  Terminator                   Usage
     Word
.ps 9
.vs -3
 -----------------------------------------------------------------
   END        Used to terminate a block begun with BEGIN; it may 
              be followed by any free form text, and terminated by 
              a semicolon or dot; the outermost block, called the 
              primary (or root) block, must be terminated by a dot; 
              all the innermost by a semicolon.
    
   ELSE       Used to terminate the THEN part of an IF-THEN-ELSE
              clause.
    
    ;         Semicolon; used to terminate any statement; if the 
              statement is followed by END or ELSE, the semicolon 
              is not mandatory.

.fam T
.B2
.LP

All the words in Tables 2-3 and 2-4 should be used neither for identifiers nor for part of identifiers, or the structure of the program could be greatly ruined.

All other identifiers (mainly for procedure names) can be used to build identifiers. (For instance you can redefine your \fCPRINT\fR routine, that at all effects will substitute the default one, or you can build your \fCSIN()\fR procedure.)
.NH 2
.ds IND160 \*[SN-NO-DOT]
USE OF SPACING AND COMMENTARY
.XS
\*(SN 			Use of spacing and commentary
.XE
.LP
The readability of ALGOL programs can be enhanced by the judicious use of spacing, tab formatting, and commentary. Spaces and tabs may be used freely in a source program without constraints. All spaces in the source (except for those inside a literal string) are removed before interpretation, thus you can insert spaces or tabs wherever you want.

Comments are introduced by either the word \fCCOMMENT\fR or the symbol \fC!\fR (available also in the DEC system-10/20 ALGOL, but not necessarily in other implementations of ALGOL). Such a comment may appear anywhere in a program. All such comments extend to all the lines they are spread to and must be terminated by a semicolon, to inform \fHtaxi\fR that the interpretation must continue. 

Comments in \fCtaxi\fR are removed before execution because their scope is limited to the source code (but retaining the original lines numbers, for error recognition). So you can write anything in the comments, also using extra ASCII characters or special keyword names, dots, colons and punctuation symbols (all but the semicolon). Refer to Sections 1.1.7 and 19 for the description of the processing phases.

If the first character in a line is a dash, the line is not loaded. This permits to avoid the whole line while debugging a program. The gvim syntax colouring file shows these lines as pure comments. This feature is a proper taxi feature, not belonging to the DEC system-10/20 ALGOL nor the ISO document. If you need to comment a line, ensure the line is not a continued-line (see the following Section).

There is a last useful comment: after the dot appearing after the last \fCEND\fR, any text (semicolon included) is ignored, so that you can put here results, comments, algorithms, descriptions, observations, in textual form and free format.
.NH 2
.ds IND170 \*[SN-NO-DOT]
PROGRAM LINES STRUCTURE
.XS
\*(SN 			Program lines structure
.XE
.LP
In general, in considering one single line of a program, \fHtaxi\fR ignores interspersed blanks, tabs and indenting (as it should be in ALGOL); besides, as usual in ALGOL, the various cycle procedures can be \fIbroken\fR in more lines, without affecting their work. Nonetheless, some rules must be observed:

.IP *
If a program line ends with a comma, it is automatically linked to the following line. This feature, called \fIcontinued-line mode\fR, is a classic feature in ALGOL, which is famous for its mathematical procedures with an endless list of arguments, that couldn't' fit a single line. The composed line inherits the line number of the starting line (this number is the one printed in the error message), and all the subsequent lines are emptied.

.IP *
Mathematical or string expressions should stand on the same line, and broken only on the first comma available (the continued-line mode exposed in the first point). This means that a phrase like

.fam C
  WHILE I>0 DO
.fam T

can be broken, as in:

.fam C
  WHILE 
  I>0
  DO
.fam T

but the mathematical conditional expression cannot be broken, otherwise the algebraic parser will fail to evaluate the terminal condition. This is not too stringent a rule, because who'd ever want to break such a condition?

.IP *
The conditional assignment rule (see Section 14), even if it \fIlooks\fR like an \fCIF-THEN-ELSE\fR structure, is nonetheless a mathematical/string/label function, that drives the result basing on a specific two-way condition. Therefore, it follows the previous rule and cannot be broken, unless on a possible continued-line break.

.IP *
\fCSWITCH\fR, its array name and the labels list must reside on the same line; to break the list, the continued-line mode can be used.

.IP *
Procedures cannot be detached of their arguments list, which may be long; to break such list, the continued-line mode can be used. The opening parenthesis must lie on the same line of the procedure name and separated only by blanks, in order to be distinguished from the associated fictitious variables list.
.LP
.bp
.NH 1
.ds IND180 \*[SN-NO-DOT]
IDENTIFIERS AND DECLARATIONS
.XS
\*(SN 		\fBIdentifiers and declarations\fR
.XE
.LP
.NH 2
.ds IND190 \*[SN-NO-DOT]
IDENTIFIERS
.XS
\*(SN 			Identifiers
.XE
.LP
An identifier must begin with a letter, followed by a series of letters or decimal digits or dots. An identifier cannot contain more than 64 characters.

RULES:

.IP 1. 
There is no implied type attached to an identifier (that is, suffixes are not meaningful, like \fC$\fR for strings in BASIC).

.IP 2. 
All identifiers in a program (included label variables) have to be "declared" before usage. 

.IP 3. 
Identifiers cannot be set equal to or contain any of the reserved words in Table 2-3 and 2-4; besides, variables names should neither start or be set equal to the name of an argumentless procedure. Ignoring these rules can severely interfere with the text interpretation in the pre-processing phase or in the run-time phase.

.IP 4. 
The case of letters, in an identifier name, matters, that is \fCAVOC\fR and \fCavoc\fR are two distinct items (variable or procedure). 

.LP
For example, the following are valid and distinct identifiers:

.fam C
   I
   i
   Alpha
   BAND
   J4k5
   HOUSEHOLDERTRIDIAGONALIZATION
.fam T

Note that \fCI\fR and \fCi\fR are distinct, and that \fCBAND\fR contains the relative reserved word \fCAND\fR, but it's a valid identifier name nonetheless. The following are not valid identifiers:

 \fC  4P\fR				it does not begin with a letter
 \fC  1\fR				it is a number
 \fC  AND\fR			it is equal to a literal operator
 \fC  BEGIN\fR			it is equal to a reserved word
 \fC  TREND\fR			it contains a reserved word

As already said, spaces are removed from the source, and this can be used to enhance the creation of the identifier; the following are valid identifiers:

.fam C
   VELVET UNDERGROUND,  ONCE AGAIN,  TWO EPSILON
.fam T

which will be seen and used with the names

.fam C
   VELVETUNDERGROUND,  ONCEAGAIN,  TWOEPSILON
.fam T

but can be referred to in any place with the spaced declared identifiers. 

\fHtaxi\fR (as the DEC system-10/20 ALGOL) enables the use of a decimal point as a "readability symbol" in the names of identifiers (even for label names). These readability symbols can appear anywhere but before the first letter, and are ignored by the interpreter. Thus: 

.fam C
   ONCE.AGAIN,  PI.BY.TWO,  ALPHA3.5,  BETA.22,  X.
.fam T

have the same effect respectively as

.fam C
   ONCEAGAIN,  PIBYTWO,  ALPHA35,  BETA22,  X
.fam T

The difference with spaces is that the readability symbols remain in the meta-text, i.e. they are not removed from the program, useful when using the debug feature.

NOTE: \fHtaxi\fR removed the restriction of the DEC system-10/20 ALGOL that the decimal point must appear only between two adjacent alphabetic characters.

NOTE: the readability symbols may also appear in procedure names: \fCPRINT.OCTAL\fR has the same effect as \fCPRINTOCTAL\fR.
.NH 2
.ds IND200 \*[SN-NO-DOT]
VARIABLES DECLARATION
.XS
\*(SN 			Variables declaration
.XE
.LP
A declaration reserves an identifier to represent a particular quantity used in a program. Such declarations are mandatory in ALGOL.

At any particular point during program execution, the form of the variable or quantity associated with the identifier depends on the type of variable. The type of variable is determined by the type of identifier which represents it.

There are six types of scalar variables, that is, variables which contain a single value:

    Integer
    Real
    Long Real
    Boolean
    String
    Label

Integer, real, and long real variables are capable of holding numerical values of the appropriate type (and only of that type). The range of values is as follows: 

.IP -  
integer type: -2147483648 to 2147483647 
.br
(see also the paragraph "Calculation Issues")
    
.IP -  
real and long real type: approximately -1.7&308 through 1.7&308; 
.br
values less than approximately 1&-16 are represented by zero but their value is retained, and when not lesser than 2.3&-308 in magnitude, they are recognized and correctly interpreted in math expressions. For instance, the simple piece of code:

.fam C
        REAL A,B; A:=1.3&-180; B:=1.3&180;
        PRINT(A*B);
.fam T
    
returns correctly the result 1.69.  (see also the paragraph "Calculation Issues")

.IP - 
Boolean type: true and false; Boolean variables (similar to FORTRAN's Logical variables) can hold a Boolean quantity, which is usually one between the states TRUE or FALSE but, in general, can be any integer value (where zero is FALSE, anything else is TRUE). In \fHtaxi\fR a Boolean type is a numeric type. When printed, they return the token '\fCtrue\fR' or '\fCfalse\fR'.\*[*]
.FS
Boolean variables are stored internally as 0 for false and -1 for true, and they bear those values when inserted in any mathematical expression, which can nonetheless involve any other mathematical type.
.FE

Should you need a numeric output (0 for false and, say, 1 for true), you should not use the Boolean type but rather the integer type; the interaction with any other Boolean variable (that is, 0 x Boolean = 0, -1 x Boolean = Boolean) is maintained. The only remarkable difference is that when you print an integer variable, used as Boolean, 0 or -1 is printed and not '\fCfalse\fR' or '\fCtrue\fR'

.IP - 
string type: string variables are somewhat more complicated. The user is referred to Chapter 13 for a full description of the subject.

.IP - 
label type: label variables hold the reference name of a label, and are used as the target of \fCGOTO\fR procedures.
.LP

All of the types of the above variables must be declared for use by preceding a list of the identifiers to be used by the appropriate delimiter word for their type. Throughout this manual, a "list of items" consists of those items arranged sequentially and separated by commas.

Examples:

.fam C
   INTEGER I,J,K;
   REAL X,Y;
   LONG REAL DOUBLE,P,Q,ELEPHANT;
   BOOLEAN ISITREALLYTRUE;
   STRING S,T;
   LABEL LAB;
.fam T

Notes:

.IP 1
In \fHtaxi\fR, variables can be declared anywhere, even at the last line of the program. A strict observation of the ALGOL rules should impose that any variable and procedure must be declared before any other statement in the block. So, the fact you can override this behaviour is an enhancement, but you can ignore it, if you want to obey to the general rule.

.IP 2
In \fHtaxi\fR, if you name a variable with a name already in use, in the same memory space, a warning appears:

.fam C
 Warning: Identifier <id> at line <n> already declared in line <n>.
.fam T

where \fC<id>\fR is the name being declared and \fC<n>\fR is the line where it was declared. This warning does not prevent the replication of the name, but this is done at your risk because, if you declare a variable \fCi\fR and an array \fCi\fR, though they are effectively two different items, they can be confused by having the same name, the latter hiding the former. Of course, if variable \fCi\fR is declared in the main body, and the variable \fCi\fR is declared into a procedure, they cannot be confused. It's actually true that the variable \fCi\fR in the procedure \fIhides\fR the variable \fCi\fR in the main body, but this is an user choice (even gcc does not warn about this kind of declaration).
.LP
.NH 2
.ds IND150 \*[SN-NO-DOT]
A NECESSARY WARNING ABOUT VARIABLES NAMES
.XS
\*(SN 			A necessary warning about variables names
.XE
.LP
A variable identifier with the name equal to the name of a procedure with no arguments can confuse \fHtaxi\fR.

For example, it's possible redefining \fCNEWLINE\fR (an existing argumentless procedure); at any time, by calling \fCNEWLINE\fR, the new procedure will be used and not the default one. So far, so good.

But if you name \fCNEWLINE\fR a variable (for example a Boolean), calling:

.fam C
 BOOLEAN NEWLINE;
 NEWLINE:= FALSE;
 PRINT(NEWLINE);
.fam T

the Boolean variable named \fCNEWLINE\fR will be correctly created and assigned (because the assignment recognizes variables only); however, in the printing phase, \fHtaxi\fR will see the default procedure \fCNEWLINE\fR as an unsuitable argument for \fCPRINT\fR, and will complain, printing an error message.

Besides, operator names with alphabetic characters deserve special clarification: literal operator names, like \fCAND\fR, are not reserved words, so you might think they can be used as normal identifiers, and you can really do it, \fHtaxi\fR will not prevent such use.

This is anyway like a two-edged sword; if you use the following sequence:

.fam C
 REAL AND;
 AND:=3.4;
 PRINTLN(AND);
.fam T

you will correctly get 3.4 printed on the screen. But if you should add spaces, like in the following example, perhaps to make it clearer:

.fam C
 PRINTLN( AND );
.fam T

you will get:

.fam C
 taxi runtime processor error in the program at line 4:
 Illegal formula.
 PRINTLN( AND );
     ^
 Error code 31
.fam T

because the interpreter was asked to print an operator, and not any math or Boolean expression. Operator names with alphabetic characters are recognized as such only if enclosed by blanks (space or tabulation).

The consequence of this is that you should avoid using the operators' names as identifiers themselves; anyway, you can use them as \fIpart\fR of an identifier. (For instance, you can use \fCBAND\fR, since the operator \fCAND\fR is not recognized as an operator, because it is not entirely enclosed by blanks.)
.bp
.NH 1
.ds IND210 \*[SN-NO-DOT]
CONSTANTS
.XS
\*(SN 		\fBConstants\fR
.XE
.LP
.NH 2
.ds IND220 \*[SN-NO-DOT]
NUMERIC CONSTANTS
.XS
\*(SN 			Numeric constants
.XE
.LP
There are three forms of numeric constants\*[*]:

.IP 1. 
Integer constants

.IP 2. 
Real constants

.IP 3. 
Long Real constants
.LP

Note: with regard to the symbol used to divide the integer part from the fractional part of a number, the dot (ASCII 46) is the universally used and accepted symbol (e.g. \fCIII.FFFFF\fR), and so it is here. But \fHtaxi\fR also accepts and parses every instance of the \[md] symbol outside of strings used to signal multiplication (it's the central dot, ASCII 62 and 73, called also \fIdotmath\fR), substituting it with the common asterisk. If you happen to copy and paste a listing from a book of the Sixties to your file, you're likely to see this central dot, used in those times to symbolize typographically the multiplication. It's a painful task parsing manually the program to see where this is used in place of the asterisk (I speak by experience), so I enabled a silent substitution, harmless and useful.
.FS
The terminology used in this manual reflects the original one, but I must observe here that \fIconstants\fR which are referred to in this chapter are actually to be considered (in modern language) 'literal numbers'. There is no \fCCONSTANT\fR specifier in ALGOL for creating instances of unmodifiable entities like C constants, for instance.
.FE
.NH 3
.ds IND230 \*[SN-NO-DOT]
Integer Constants
.XS
\*(SN 			Integer Constants
.XE
.LP
Integer constants consist of a series of adjacent decimal digits, subject to the constraint that the number represented must be in the range of integer numbers.

NOTE: any preceding sign, which is not the minus sign, that appears in the program is considered part of the constant. A plus sign is read but ignored.

Examples: 	

.fam C
   3 	 
     
   -24 	  
     
   +9276541
.fam T

See also Section 4.4 about the ASCII constants, and Section 1.1.8 related to problems in practical calculations.
.NH 3
.ds IND240 \*[SN-NO-DOT]
Real Constants
.XS
\*(SN 			Real Constants
.XE
.LP
Real constants consist of a decimal number (containing either an integer part, or a fractional part, or both) followed by an optional exponent. The exponent consists of either the \fC&\fR or \fC\@\fR symbol followed by an optionally signed integer (\fCE\fR or \fCD\fR are also accepted in reading). This has the effect of multiplying the decimal number by the power of ten specified in the exponent. If no decimal number appears, a value of unity is assumed. If the value of a decimal number is 1, then this may be omitted, and the real constant solely represented by the exponent (which, in this case, can be \fC&\fR or \fC\@\fR only) - see the last example in this section. 

Examples:

.fam C
   Literal             Stored              Printed
   
   3.141592653589793   3.141592653589793   3.141592654&+0
   .0001               0.0001              1.000000000&-4
   43.7E4              437000.0            4.370000000&+5
   5\@-3                0.005               5.000000000&-3
   &-6                 0.000001            1.000000000&-6
.fam T

NOTE: a number can be entered as a pure exponential part only in case of \fC&\fR and \fC\@\fR: for instance, \fC&3\fR is equivalent to \fC1&3\fR and \fC\@-1\fR is equivalent to \fC1\@-1\fR; instead, \fCE1\fR or \fCD3\fR could be confused as variables identifiers, and so they are not considered literal numbers.
.NH 3
.ds IND250 \*[SN-NO-DOT]
Long Real Constants
.XS
\*(SN 			Long Real Constants
.XE
.LP
Long real constants are used to represent numeric quantities to approximately twice the precision available with real numbers: about seventeen decimal digits. Long real constants are formed by writing a real constant in floating-point form, by replacing the \fC&\fR or \fC\@\fR by \fC&&\fR or \fC\@\@\fR. \fCE\fR and \fCD\fR are accepted in reading.

Examples:

.fam C
   Literal       3.14159265358979323846&&0               
   Stored        3.141592653589793
   Printed       3.14159265358979312&&+0

   Literal       12\@\@-3
   Stored        0.012
   Printed       1.20000000000000107&&-2
.fam T

Garbage numbers (dust) may appear in the final part of a long real, due to the C-double format. See last chapter.
.NH 3
.ds IND260 \*[SN-NO-DOT]
Actual numeric storage
.XS
\*(SN 			Actual numeric storage
.XE
.LP
All numbers are stored in a C 'double' memory space. That is number of type Boolean, integer, real and long real are all converted to the same C 'double' format when stored. 

This offers great flexibility in treating numbers because there is only one type to check, evaluate, increment, decrement; this avoids completely the loss of precision in arithmetic expressions involving long real variables and real constants, thus making easier the conversion of programs to use long real variables. Moreover, the C 'double' type can store completely the integer quantity up to the maximum signed value, so that calculation involving only integers and Booleans, is precise to the last digit.

The disadvantage is the loss of precision if integer numbers are involved in calculations in which real and long real numbers are also involved, even if the precision is at least @2 sup 30#, according to my studies, which is sufficient for most cases.

.NH 2
.ds IND270 \*[SN-NO-DOT]
OCTAL CONSTANTS
.XS
\*(SN 			Octal constants
.XE
.LP
Octal constants consist of the symbol \fC%\fR followed by a series of octal digits. Up to 11 significant digits may appear (leading zeros are ignored); these digits are right justified.

Examples:

.fam C
   %7777777774

   %0470
.fam T

Octal constants can be used in any expression where an equivalent decimal number is required.
.NH 2
.ds IND280 \*[SN-NO-DOT]
BOOLEAN CONSTANTS
.XS
\*(SN 			Boolean constants
.XE
.LP
Boolean constants consist of numeric values whose inequality of zero is considered. If they are zero, they are printed as \fCfalse\fR, otherwise as \fCtrue\fR (equivalent to the values 0 and -1 respectively). 

Boolean numbers can enter any calculation because they are stored as numbers, not as labels.

\fHtaxi\fR offers the two constants \fCTRUE\fR and \fCFALSE\fR that can substitute respectively -1 and 0, and simulate optimally the Boolean constants.
.NH 2
.ds IND290 \*[SN-NO-DOT]
ASCII CONSTANTS
.XS
\*(SN 			ASCII constants
.XE
.LP
Up to four ASCII symbols can be packed right-justified to give an integer-type constant. The format is a dollar sign (\fC$\fR), followed by up to four ASCII symbols enclosed within a delimiting symbol pair. 

The leading delimiter symbol immediately follows the \fC$\fR, and can be any readable character, but not an invisible one such as the space character.

Examples:

.fam C
   Text	      Decimal Value            Octal Value
   --------------------------------------------------
   $_A_                    65            %0000000101
  
   $/1234/          825373492            %6114431464
  
   $|ANNA|         1095650881            %10123447101
  
   $M~~~~M         2122219134            %17637477176
.fam T

The greatest integer generated by this algorithm is 2139062143, returned by four figures of ASCII 127. ASCII characters in the range 128-255 cannot be interpreted correctly by \fHtaxi\fR. The lower integer generated by this algorithm is 1, returned by one figure of ASCII 1 (the \fCCSOH\fR character).

NOTE: the number-generation algorithm differs from the one used by the DEC system-10/20 ALGOL. 

NOTE: the space character cannot be used nor as an ASCII constant delimiter neither as an ASCII figure, because spaces are removed before execution (see section 2.4).
.NH 2
.ds IND300 \*[SN-NO-DOT]
STRING AND LABEL CONSTANTS
.XS
\*(SN 			String and label constants
.XE
.LP
String constants allow the user to store any reasonable length string of ASCII characters within a program. String constants are typically used to output a message during the execution of the program or as values assigned to string variables.

The string of symbols is enclosed within quotes, the double-quote character \fC"\fR or two instances of the single-quote character \fC''\fR. There are restrictions on the symbols that may appear within the string:

.IP 1. 
\fC[\fR and \fC"\fR cannot appear alone inside a string.
 
.IP 2. 
\fC[\fR must appear only if properly paired with \fC]\fR.
 
.IP 3. 
Double occurrences of \fC[[ ]] ;;\fR and \fC""\fR respectively are represented as \fC[ ] ;\fR and \fC"\fR

.IP 4. 
Each opening \fC"\fR must be closed by an occurrence of \fC"\fR.
  
.IP 5. 
Each opening \fC''\fR must be closed by an occurrence of \fC''\fR.
.LP

Single square brackets are used to enclose symbols that have specific effects when the string is output. These are discussed in Paragraph 16.9.2.

Examples:

.fam C
   "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
   "REMEMBER THAT SPACES ETC. ARE SIGNIFICANT"
   "[P5C]INPUT DATA: [5C]"
   ''""A[[I]] := 0.1;;""''
.fam T

The latter example builds the following string: \fC"A[I] := 0.1;"\fR, and has the double quotes as constituent parts of the string itself.

As stated in the ISO 1538-1984, (2.6.2) two strings in two consecutive lines are joined together implicitly. The ISO 1538-1984 also states that two strings should join even if in the same line, but the double-double-quote mechanism for inserting the double-quote character into the string (a heritage of the DEC system-10/20 ALGOL) forbids this. A minor issue. 

Labels are a particular version of strings. They can contain only letters, numbers or dots, and they can be assigned as common strings wherever in the listing:

.fam C
   LABEL LAB;
   LAB:="ERR";
.fam T

This assignment lets use \fCGOTO LAB\fR or \fCGOTO ERR\fR with the same effect, but the destination can be changed if \fCLAB\fR is changed.

When passing literal label arguments to a procedure, the label may be naked; the system can detect if a naked name is a label variable (containing some value) or a naked literal label name. E.g. the following procedure calls are identical:

.fam C
   PRINT(SQUAREROOT(X,"ERR"));
   PRINT(SQUAREROOT(X,''ERR''));
   PRINT(SQUAREROOT(X,ERR));

   LABEL LAB;
   LAB:="ERR";
   PRINT(SQUAREROOT(X,LAB));
.fam T

See chapter 7 for the specific usage of labels.
.bp
.NH 1
.ds IND310 \*[SN-NO-DOT]
EXPRESSIONS
.XS
\*(SN 		\fBExpressions\fR
.XE
.LP
.NH 2
.ds IND320 \*[SN-NO-DOT]
ARITHMETIC EXPRESSIONS
.XS
\*(SN 			Arithmetic expressions
.XE
.LP
Arithmetic expressions are written in a form similar to that used in FORTRAN, BASIC, C and many other high-level scientific computer languages. The usual algebraic rules concerning the precedence of operators and parentheses are applied. (See Table 5-4 for the complete precedence list.)

The basic arithmetic operators are:

 \fC     +         \fRaddition

 \fC     -         \fRsubtraction

 \fC     /         \fRordinary division

 \fC     \\         \fRinteger division (also \fC\[di]\fR)

 \fC     *         \fRmultiplication

 \fC     ^         \fRexponentiation (also \fC**\fR)

.fam T
.LP
        
There are two additional operators, \fCDIV\fR and \fCREM\fR (the latter being also available as \fCMOD\fR), that indicate integer division and remainder, respectively, and these have the same precedence as ordinary division. Within the precedence scheme, the order of evaluation is always from left to right. For example: 

.fam C
   X - Y - Z means (X - Y) - Z
.fam T

and

.fam C
   I DIV J REM K means (I DIV J) REM K
.fam T

Unlike FORTRAN, when an ordinary division of one integer constant by another is performed, the real result is not rounded to an integer value.

The difference between the various types of division is clarified by the following examples:

 \fC  7/4\fR yields a result of 1.75, whereas
 
 \fC  7 DIV 4\fR yields a result of 1 (the same for 7 \\ 4), and
 
 \fC  7 REM 4\fR yields a result of 3

The interpretation of integer division for negative integers follows:

.fam C
   Let M, N>O, then

   -M DIV N = M DIV (-N) = -(M DIV N)
   -M DIV (-N) = M DIV N
.fam T

The integer remainder operator, \fCREM\fR, is defined so that for all integers \fCM\fR, \fCN\fR:

.fam C
   M REM N = M - N * (M DIV N)
.fam T

NOTE: the usage of \fC\[di]\fR (ISO flavour) instead of \fCDIV\fR (DEC flavour), to perform the integer division operation is also available.
.NH 3
.ds IND330 \*[SN-NO-DOT]
Identifiers And Constants
.XS
\*(SN 			Identifiers And Constants
.XE
.LP
Arithmetic expressions consist of operands, that is, identifiers and constants, of the three types, integer, real and long real plus one fourth (Boolean), together with arithmetic operators \fC+ - * / \\ \[di] DIV REM MOD\fR and \fC^\fR, with parentheses where necessary.

Since automatic conversion takes place as necessary when an expression is evaluated, the user may freely mix the three different types of identifiers and constants.
.NH 3
.ds IND340 \*[SN-NO-DOT]
Special Procedures
.XS
\*(SN 			Special Procedures
.XE
.LP
Three special procedures are provided for use in arithmetic expressions. The first is the transfer procedure \fCENTIER\fR, which converts a number of any type into an integer quantity defined as the largest integer value not exceeding the argument.

Thus

.fam C
   ENTIER(3.5) = 3
.fam T

and

.fam C
   ENTIER(-3.5) = -4
.fam T

The special procedure \fCABS\fR yields the absolute value (also known as the \fImodulus\fR) of its argument, which can be a number of any type.

Thus

.fam C
   ABS(-3.5) = 3.5
.fam T

and

.fam C 
   ABS(-3) = 3
.fam T

The special procedure \fCSIGN\fR is the signum function whose argument can be a number of any type. The result is always of integer type, being -1, 0 or +1, depending on whether the argument is negative, zero, or greater than zero, respectively.

Thus

.fam C
   SIGN(-3.5) = -1
   SIGN(O) = 0
   SIGN (3.5) 1
.fam T

Examples of simple arithmetic expressions follow:

.fam C
   X
   I+3
   X*Y/Z
   P+Q/R
   X2 + Y
   XJ - 4
   J + ENTIER(K-2)
   SIGN(ENTIER(J/K) + 1)
   (X + Y) * (-I)
.fam T
.NH 2
.ds IND350 \*[SN-NO-DOT]
BOOLEAN EXPRESSIONS
.XS
\*(SN 			Boolean expressions
.XE
.LP
Boolean expressions involve Boolean identifiers, Boolean and octal constants, arithmetic conditions, and Boolean operators interspersed in an order similar to that of arithmetic expressions. 
.NH 3
.ds IND360 \*[SN-NO-DOT]
Boolean Operators
.XS
\*(SN 			Boolean Operators
.XE
.LP
There are five Boolean operators listed here in decreasing order of precedence:

 \fC     +         \fRaddition

 \fC     NOT       \fR (unary operator, also \fC~\fR)

 \fC     AND       \fR (also \fC/\\\fR, bitwise)

 \fC     OR        \fR (also \fC\\/\fR, bitwise)

 \fC     IMP       \fR (logical implication, also \fC->\fR)

 \fC     EQV       \fR (logical equivalence, also \fC==\fR)

The operator \fCNOT\fR is a unary operator that complements a Boolean quantity in the same way that a unary minus sign negates an arithmetic quantity in an arithmetic expression, so that \fCFALSE\fR is changed to \fCTRUE\fR, or vice versa. \fCNOT\fR has the same precedence of the minus sign for numbers. This means that an expression such as

.fam C
   NOT I AND 0
.fam T

is not interpreted as \fCNOT(I AND 0)\fR but as \fC(NOT I) AND 0\fR; it's the very same case of the minus sign, where

.fam C
   -1 = 0
.fam T

is never interpreter as \fC-(1 = 0)\fR and the minus has the usual same position learned at school.

Table 5-1 gives the result of \fCA OP B\fR where \fCOP\fR stands for one of the Boolean operators \fCAND\fR, \fCOR\fR, \fCIMP\fR, or \fCEQV\fR, for all values of \fCA\fR and \fCB\fR.

.B1
.CD
Table 5-1
Boolean Operators

.DE
.fam C
   A        B       A AND B    A OR B     A IMP B    A EQV B     NOT A
 ---------------------------------------------------------------------
 TRUE     TRUE       TRUE       TRUE       TRUE       TRUE       FALSE
 FALSE    TRUE       FALSE      TRUE       TRUE       FALSE      TRUE
 TRUE     FALSE      FALSE      TRUE       FALSE      FALSE
 FALSE    FALSE      FALSE      FALSE      TRUE       TRUE

.fam T
.B2
.LP

Besides, the following theorems hold:

 \fCA EQV B   \fR is equivalent to\fC    (A IMP B) AND (B IMP A)\fR

 \fCA IMP B   \fR is equivalent to\fC    NOT A OR B\fR

.NH 3
.ds IND370 \*[SN-NO-DOT]
Evaluation Of Boolean Variables
.XS
\*(SN 			Evaluation Of Boolean Variables
.XE
.LP
Boolean variables have a value consisting of any pattern of bits, rather than be confined to the values \fCTRUE\fR and \fCFALSE\fR. The logical operations operate on a bit-by-bit basis according to the preceding rules. 

The actual test employed to determine the truth of a Boolean expression such as

.fam C
   B AND C
.fam T

is to evaluate it and regard it as true if the value is nonzero, that is, at least one bit of the associated integer value is set, otherwise, regard as false.

This is particularly important when octal constants are used in Boolean expressions. For example, if the user wishes to test a particular bit in a Boolean variable, a suitable decimal or octal constant can be used:

.fam C
   B AND %1
.fam T

is a Boolean expression that is true if and only if the bottom (least significant) bit of \fCB\fR is a one. 
.NH 2
.ds IND380 \*[SN-NO-DOT]
ARITHMETIC CONDITION TESTS
.XS
\*(SN 			Arithmetic condition tests
.XE
.LP
Arithmetic conditions are used as operands in Boolean expressions. They consist of two arithmetic expressions coupled with a comparator. The comparator, which decides the particular type of test to be performed on the two expressions, is one of the following:

 \fC     <         \fRless than

 \fC     <=        \fRless than or equal to

 \fC     =         \fRequals

 \fC     >         \fRgreater than

 \fC     >=        \fRgreater than or equal to

 \fC     #         \fRnot equal to
.fam T

The operator \fC#\fR can also be written as the infix forms \fCNOTEQUAL\fR, \fC<>\fR and \fC~=\fR.

Such an arithmetic condition can be regarded as true or false according to whether the condition specified by the comparator is met when the arithmetic expressions on each side are evaluated. The resulting condition is a Boolean expression.

The following examples of Boolean expressions, shown in Table 5-2, also involve arithmetic conditions.

.B1
.CD
Table 5-2 
Boolean Expressions

.DE
.fam C
   Expression           Meaning
 ----------------------------------------------------
   NOT B                NOT B
   NOT A=B              (NOT A)=B   
   B AND NOT C          B AND (NOT C)
   A OR B AND C         A OR (B AND C)
   B EQV X<Y            B EQV (X<Y)
   X+Y<Z AND B OR P=Q   (((X+Y)<Z) AND B) OR (P=Q)

.fam T
.B2
.LP
.NH 2
.ds IND390 \*[SN-NO-DOT]
FOREIGN OPERATORS
.XS
\*(SN 			Foreign operators
.XE
.LP
Since ALGOL birth, all the different compilers/interpreters conceived their syntax for math and logical operators even if, in the Modified Report, a sort of standardization were applied. 

On this premise, \fHtaxi\fR enables an extra conversion procedure, in the pre-processing phase, to substitute the foreign operators that don't agree with DEC or ISO forms, with the default ones.

If your ALGOL listing comes from an external source, before working out figuring what operator is to be changed, this feature may help in executing the code without having to change the code. If you should know about other operators not in the previous list, write me: I will add them to the reduction list.

In the following Table 5-5, the list of the operators that are converted and the \fHtaxi\fR equivalent is represented:

.B1
.CD
Table 5-3
Conversions

.DE
.fam C
 Symbol    	        Meaning or use
.ps 9
.vs -3
 -----------------------------------------------------------------
   EQL                  =   (equal operator)
   !=                   #   (not equal operator)
   ><                   #   (not equal operator)
   NEQ                  #   (not equal operator)
   % (*)                REM (remainder/modulus operator)
   >>                   IMP (logic implication operator)
   IMPL                 IMP (logic implication operator)
   <->                  EQV (logic equivalence operator)
   EQIV                 EQV (logic equivalence operator)
   LSS                  <   (less than operator)
   =<                   <=  (less than or equal operator)
   LEQ                  <=  (less than or equal operator)
   =>                   >=  (greater than or equal operator)
   GEQ                  >=  (greater than or equal operator)
   GTR                  >   (greater than operator)

.fam T
.ps 8
 (*) if not immediately followed by a digit.

.B2
.LP

.NH 2
.ds IND400 \*[SN-NO-DOT]
MACHINE TOKENS
.XS
\*(SN 			Machine tokens
.XE
.LP
The run-time interpretation of the source program is preceded by a preparatory phase in which the text is parsed and analyzed. During this phase, all operators constituted by more than a single character are converted to a single character, for the algebraic parser's sake. Thus, what the algebraic parser sees is not the textual or compound symbols operator, but a specific ASCII code token. Since these tokens are common ASCII characters, the usage of these in place of the original operator form is not forbidden, but it's strongly discouraged, because these could interfere with the parser phase (and are surely not portable).

The following Table 5-3 explains this in full. Please note that the ISO character \fC\[no]\fR is not available as a basic ASCII character, as well as \fC\[==]\fR. 


.B1
.CD  
Table 5-3
Machine tokens

.DE
.fam C
   Operator (DEC)   Operator (ISO)   Machine token
  ----------------------------------------------------------
    #                    \[!=]                #
    :=                   :=               \[co] 
    DIV                  \[di]                \\
    REM                                   ` (inverse tick)
    MOD                                   ` (inverse tick)
    <=                   <=               {
    >=                   >=               }
    NOT                  \[no]                ~ (tilde)
    AND                  /\\               _ (underscore)
    OR                   \\/               | (vertical bar)
    IMP                  ->               !
    EQV                  \[==]                ?

.fam T
.B2
.LP

These Machine tokens are the ones you see in debugging. (See chapter 19.)

.NH 2
.ds IND410 \*[SN-NO-DOT]
INTEGER AND BOOLEAN CONVERSIONS
.XS
\*(SN 			Integer and Boolean conversions
.XE
.LP
An integer quantity can be converted to a Boolean quantity through the dummy procedure \fCBOOL\fR. Similarly, the dummy procedure \fCINT\fR converts a Boolean quantity to an integer quantity. If only integer values are used as arguments of these procedures, they remain unchanged.

These procedures were conceived mostly for semantic correctness. Thus:

 \fCBOOL(I)\fR

can be regarded as a Boolean operand, and

 \fCINT(B)\fR
.br
 \fCINT(%400000000000)\fR
 
as an integer operand.

If a real or long real number is used as an argument, the decimal part is truncated, and the integer part is used as specified above.
.bp
.NH 1
.ds IND420 \*[SN-NO-DOT]
STATEMENTS AND ASSIGNMENTS
.XS
\*(SN 		\fBStatements and assignments\fR
.XE
.LP
.NH 2
.ds IND430 \*[SN-NO-DOT]
STATEMENTS
.XS
\*(SN 			Statements
.XE
.LP
The statement is the basic operational unit in ALGOL 60 and describes an operation, such as an assignment, to be performed at run time, or a single procedure.
.NH 2
.ds IND440 \*[SN-NO-DOT]
ASSIGNMENTS
.XS
\*(SN 			Assignments
.XE
.LP
Assignments convey the value produced by the execution of an expression to a destination variable of the appropriate type. This is done by writing the destination identifier, followed first by the symbols \fC:\fR and \fC=\fR and then by the expression to be evaluated. Thus

.fam C
   X := Y + Z
.fam T

causes the result of the addition of the values contained in the variables \fCY\fR and \fCZ\fR to be placed in the variable \fCX\fR. 

When an assignment is made to a variable type differing from that of the result of the expression, a type conversion is performed only when the assignment is made to a Boolean or an integer variable, by rounding (see ahead).

Boolean, integer, real and long real expressions can be assigned to variables of any of these four types, but not to any other types (namely strings and labels). String and labels expressions can only be assigned to a variable of the same type.

If a real or long real value is assigned to an integer or Boolean type variable, a rounding process occurs.

.fam C
   I := X
.fam T

results in an integer value equal to \fCENTIER(X + 0.5)\fR being assigned to \fCI\fR.

NOTE: in \fHtaxi\fR, all assignments, expressions, conditions are at all effects numerical values. It depends on the contest if it is a condition (0 is false, any other value is true), or an assignment of an expression. Basing on this, a condition can be assigned as a numeric expression (this was illegal in ALGOL 60) or a value can act as a conditional. Consider the following examples:

.fam C
   I := R > 1
.fam T

stores in \fCI\fR the value \fC-1\fR (default true condition) if \fCR\fR is greater than 1, or zero if not, while

.fam C
   IF R THEN PRINT(R)
.fam T

prints \fCR\fR only if it is not zero, because \fCR\fR is evaluated as a condition (zero is false, not zero is true), and it does not need to be a Boolean value.

This is a minor deviation (an enhancement in effect) from ALGOL 60 and the ISO documents.
.NH 3
.ds IND450 \*[SN-NO-DOT]
Multiple assignments
.XS
\*(SN 			Multiple assignments
.XE
.LP
A value is assigned simultaneously to several variables of the same type by multiple assignments. This takes a form such as

.fam C
   P := R := S := X + Y - Z ;
.fam T

where the result of adding \fCY\fR to \fCX\fR and subtracting \fCZ\fR is assigned to \fCP\fR, \fCR\fR, and \fCS\fR simultaneously.

Note here that a multiple assignment with an equality test at the end is not ambiguous:

.fam C
   A := B := C := D = 0;
.fam T

In languages using \fC=\fR as the assignment operator \fIand\fR the equality test operator, the \fCD = 0\fR part is ambiguous, because it can be the last item od the chain \fIor\fR the condition test. In ALGOL this is not possible, because the assignment operator and the equality test operator are different, and so the previous operation assigns to \fCA\fR, \fCB\fR and \fCC\fR the condition \fCD = 0\fR.

All identifiers on the left-hand side of multiple assignments don't need to be of the same type (but results may differ if integer and real variables are mixed).

.NH 3
.ds IND460 \*[SN-NO-DOT]
Parenthesized assignments
.XS
\*(SN 			Parenthesized assignments
.XE
.LP
A parenthesized assignment may be substituted for any operand in an expression. For example,

.fam C
   X := (Y := P+Q)/Z;
.fam T

This causes the assignment to \fCX\fR to be made \fIafter\fR the inner expression \fCY := P+Q\fR is evaluated. Where a type conversion is performed as part of an embedded assignment, the operand type is the same as that assigned to the variable in the embedded assignment. Thus, if I is an integer and X is a real

.fam C
   X := (I := 3.4)
.fam T

sets \fCI\fR equal to 3 and \fCX\fR equal to 3.0.
.NH 2
.ds IND470 \*[SN-NO-DOT]
EVALUATION OF EXPRESSIONS
.XS
\*(SN 			Evaluation of expressions
.XE
.LP
All expressions in \fHtaxi\fR (as in the DECsystem-IO/20 ALGOL) are evaluated observing the normal algebraic rules of precedence, including bracketing.

The following Table 5-4 resumes the precedence levels of all the math and Boolean operators. The lower is the level, the lower is the precedence.

.B1
.CD 
Table 5-4
Precedence 

.DE
.fam C
  Precedence     Operator     	
    Level         
 -----------------------------------------------------------------
     10          +  - (prefix number signs)  NOT ~
      9          (...)  parentheses (evaluated immediately)
      8          ^  **
      7          *  /  \\  \[di]  DIV  REM  MOD
      6          +  - 
      5          <  <=  =  >  >=  #
      4          AND  /\\
      3          OR  \\/
      2          IMP  ->
      1          EQV  ==

.fam T
.B2
.LP

Within the precedence structure, expressions are always evaluated from left to right. For example, if \fCX\fR is a scalar, and \fCF\fR a procedure (see Chapter 11) that alters \fCX\fR, 

.fam C
   X := X + F ;
.fam T

may have a different effect than

.fam C
   X := F + X
.fam T

This is known as the \fIside effect\fR phenomenon.

Consider also:

.fam C
   A[I] := (I := I+1)
.fam T

The subscript \fCI\fR is always evaluated before \fCI\fR is incremented, as it is to the left of the embedded assignment, within the statement. Thus the above expression is equivalent to

.fam C
   J := I; 
   I:= I+1; 
   A[J] := I; 
.fam T

The user can always predict the order of evaluation of an expression and can count on such things as 

.fam C
   X := (P := P+Q)/(P+R)
.fam T

being evaluated correctly, thus giving the same result as

.fam C
   P := P+Q ;
   X := P/(P+R);
.fam T

The final type of an expression depends on the types of the operands:

.IP -
if an expression involves only Booleans or Boolean procedures, the result is Boolean;
.IP -
if an expression involves Booleans or Boolean procedures and at least one Integer or Integer procedure, the result is Integer;
.IP -
if an expression involves Booleans or Boolean procedures or Integers or Integer procedure and at least one Real or Real procedure, the result is Real;
.IP -
if an expression involves Booleans or Boolean procedures or Integers or Integer procedures or Reals or Real procedures and at least one Long Real or Long Real procedure, the result is Long Real.

E.g.
.fam C
 PRINTLN(true*true);
 PRINTLN(24*true);
 PRINTLN(3.4&1*24*true);
 PRINTLN(1&&1*3.4&1*24*true);
 
  true 
          -24 
 -8.160000000&+2 
 -8.16000000000000014&&+3 
.fam T
.NH 2
.ds IND480 \*[SN-NO-DOT]
COMPOUND STATEMENTS
.XS
\*(SN 			Compound statements
.XE
.LP
A compound statement (or block) consists of a set of statements, preceded by \fCBEGIN\fR, separated by semicolons, and terminated by \fCEND\fR. ALGOL statements, unlike those in FORTRAN, are terminated by a semicolon, not by the end of a line of text.

For example:

.fam C
   BEGIN
         I := 3; J:= 4;
         K := I + J;
         X := K
   END
.fam T

is a compound statement. Semicolons do not need to appear after the \fCBEGIN\fR or before the \fCEND\fR (but their usage is not illegal); \fCBEGIN\fR and \fCEND\fR act as a type of bracket (\fCEND\fR is also a terminator).

The usefulness of compound statements will become apparent in later chapters.
.bp
.NH 1
.ds IND490 \*[SN-NO-DOT]
CONTROL TRANSFERS, LABELS, AND CONDITIONAL STATEMENTS
.XS
\*(SN 		\fBControl transfers, labels, and conditional statements\fR
.XE
.LP
.NH 2
.ds IND500 \*[SN-NO-DOT]
LABELS
.XS
\*(SN 			Labels
.XE
.LP
A label is a method of marking a place in a program so that control can be transferred to that point from elsewhere in the program.

\fHtaxi\fR (as the DEC system-10/20 ALGOL) uses identifiers as labels. These identifiers are placed before statements and are followed by a colon. 

A label name must begin with a letter or a number, and optionally be followed by one or more letters or decimal digits or dots. A label name, as an identifier, may not contain more than 64 characters.

Numeric labels are permitted, as established in the Revised Report (but were not implemented in DEC system-10/20 ALGOL).

For example:

.fam C
   COMP: X:= X + Y
.fam T

is a statement labelled by \fCCOMP\fR.

More than one label can be attached to a statement if required; thus,

.fam C
   LAB1:  2000:  Y:= 0 ;
.fam T

NOTE: only digits, letters and the dot are allowed in labels; if you want to use more than one single word for your label, use the dot as a separator. 

E.g.:
.fam C
 SQUARING OPERATIONS:		! this label is illegal;

 SQUARING_OPERATIONS:		! this label is illegal;

 SQUARING.OPERATIONS:		! valid label;
.fam T

I don't know what was the behaviour in DEC system-10/20 ALGOL or the ISO specifics, but I think anyway that this is a minor issue.
.NH 2
.ds IND510 \*[SN-NO-DOT]
UNCONDITIONAL CONTROL TRANSFERS
.XS
\*(SN 			Unconditional control transfers
.XE
.LP
A transfer of control, or "jump", to a statement in a program is handled by a \fCGOTO\fR statement. This statement consists of the word \fCGOTO\fR followed by the name of the label attached to the relevant statement. The two words \fCGO TO\fR can be used instead of the word \fCGOTO\fR in any statement where \fCGOTO\fR can be used. Thus:

.fam C
       LAB: I := J := 3;
       K := I + J;
       GOTO LAB;
.fam T

is an example of a somewhat tedious program. To write any reasonable program, it is necessary to be able to jump conditionally.
.NH 2
.ds IND520 \*[SN-NO-DOT]
CONDITIONAL STATEMENT
.XS
\*(SN 			Conditional statement
.XE
.LP
Conditional statements provide a method to make the execution of either a statement or a compound statement dependent on some condition in the program, such as the value of a variable. The simplest form of a conditional statement is

.fam C
   IF B THEN S
.fam T

where \fCB\fR is some Boolean expression, and \fCS\fR is a statement. For example:

.fam C
   IF X < 0 THEN I := I + 1
.fam T

Here, \fCX < 0\fR is the Boolean expression and \fCI := I + 1\fR is the statement which is obeyed if and only if the Boolean condition is true, that is, if \fCX\fR is negative.

A more general form of a conditional statement is

.fam C
   IF B THEN S1 ELSE S2
.fam T

In this case, the statement \fCS1\fR is obeyed if and only if the Boolean expression \fCB\fR is true, and \fCS2\fR is obeyed if and only if it is false. To eliminate the "dangling \fCELSE\fR ambiguity" (a construction in which an \fCELSE\fR could be paired with either of two \fCTHEN\fRs) and to avoid ambiguity in case of complex multiline statements, \fCS1\fR and \fCS2\fR should be only direct statements or assignments (for instance \fCGOTO\fR or \fCA:=1\fR) and not a complex statement like an \fCIF\fR conditional, a \fCFOR\fR, or a \fCWHILE\fR statement. In case you have to use such statements after \fCTHEN\fR or \fCELSE\fR, enclose them in a block (between a \fCBEGIN\fR and \fCEND\fR). 

Example:

.fam C
   BEGIN  INTEGER I;
 	  I := 0;
   LAB:   I := I + 1;
          IF I < 100 THEN GOTO LAB
   END
.fam T

is a simple way of counting to one hundred. 

More sophisticated methods are shown in Chapter 14.
.bp
.NH 1
.ds IND530 \*[SN-NO-DOT]
CYCLE STATEMENTS
.XS
\*(SN 		\fBCycle statements\fR
.XE
.LP
.NH 2
.ds IND540 \*[SN-NO-DOT]
THE FOR STATEMENTS
.XS
\*(SN 			The \fCFOR\fR statements
.XE
.LP
The \fCFOR\fR statement enables the user to iterate a portion of the program in a fashion similar, to but more sophisticated than, FORTRAN's \fCDO\fR loop.

The general format is

.fam C
   FOR V := FORLIST DO S
.fam T

where \fCV\fR is a variable and \fCS\fR is a statement (compound or simple).

\fCFORLIST\fR can consist of any number of \fCFOR\fR elements (separated by commas). A \fCFOR\fR element takes one of the following forms: 

.IP 1.
An expression:

.fam C
       E
.fam T

.IP 2.

A \fCSTEP-UNTIL\fR element taking the form:
 
.fam C
       E1 STEP E2 UNTIL E3
.fam T

.IP 3.
A \fCWHILE\fR element taking the form:

.fam C
       E WHILE B
.fam T

    where \fCB\fR is some Boolean expression.

.LP
Any number of \fCFOR\fR elements may appear in a \fCFOR\fR statement, in which they are executed serially. Consider the following examples:

.fam C
   FOR I := 3,5,10 DO ...
   FOR X := 2.5,5.0,10.0 DO ...
   FOR J := 1,2,5 STEP 5 UNTIL 20 DO ...
.fam T
.NH 3
.ds IND550 \*[SN-NO-DOT]
The \fCSTEP-UNTIL\fR \fBelement\fR
.XS
\*(SN 			The \fCSTEP-UNTIL\fR element
.XE
.LP
This particular form deserves closer inspection. Consider 

.fam C
   FOR I := B STEP I UNTIL N DO S
.fam T

The statement \fCS\fR is obeyed with \fCI\fR taking an initial value of \fCB\fR, and being incremented by \fCI\fR units until the final value \fCN\fR is achieved. No cycle is performed if \fCB\fR, \fCN\fR and \fCI\fR cannot satisfy the surviving condition. (E.g. if \fCB>N\fR and \fCI\fR are positive.)
 
\fHtaxi\fR (as the DEC system-10/20 ALGOL) allows the abbreviated form

.fam C
   FOR V := E1 UNTIL E3 DO S
.fam T

instead of

.fam C
   FOR V := E1 STEP 1 UNTIL E3 DO S
.fam T

The value of the running index \fCV\fR, at exit, yields the last useful value of the cycle. (Unlike C, for instance, that sets this running index to the first invalid value not included in the cycle.)
.NH 3
.ds IND560 \*[SN-NO-DOT]
The \fCWHILE\fR \fBelement\fR
.XS
\*(SN 			The \fCWHILE\fR element
.XE
.LP
A \fCFOR\fR statement with a single \fCWHILE\fR element takes the form 

.fam C
   FOR V := E WHILE B DO S
.fam T

This is interpreted as follows:

.fam C
   L1:    V := E;
          IF NOT B THEN GOTO L2;
          S;
          GOTO L1;
   L2:
.fam T

Once again, the complexity of the loop may be affected by changing \fCV\fR and \fCE\fR within the loop.
.NH 2
.ds IND570 \*[SN-NO-DOT]
THE WHILE STATEMENT
.XS
\*(SN 			The \fCWHILE\fR statement
.XE
.LP
The \fCWHILE\fR statement is an enhancement of ALGOL 60 provided in DEC system-10/20 ALGOL (not in the ISO 1538-1984) and adopted by \fHtaxi\fR too. The general form of the statement is

.fam C
   WHILE B DO S
.fam T

and is interpreted as follows:

.fam C
   L1:    IF NOT B THEN GOTO L2;
          S;
          GOTO L1;
   L2:
.fam T

.NH 2
.ds IND580 \*[SN-NO-DOT]
GENERAL NOTES
.XS
\*(SN 			General notes
.XE
.LP
The following notes must be taken into account when using the \fCFOR\fR and \fCWHILE\fR statements.

.IP 1. 
Within a \fCFOR\fR statement of any kind, the user can change the controlling variable or any other variable appearing within the action of the loop. Such changes predictably affect the execution of the loop by the rules given above.

.IP 2. 
On exit from a \fCFOR\fR statement either by jumping out of the loop or by exhausting the \fCFOR\fR elements, the controlling variable has a well-defined value equal to the last assigned value of the controlling variable. This may not be true of other ALGOL 60 implementations depending on 
.UL "Section 4.6.5"
of the Revised Report, where the following established rule is reported: "\fIIf the exit is due to exhaustion of the \fR\fCFOR\fR\fI list, on the other hand, the value of the controlled variable is undefined after the exit\fR."
.LP
.bp
.NH 1
.ds IND590 \*[SN-NO-DOT]
ARRAYS
.XS
\*(SN 		\fBArrays\fR
.XE
.LP
.NH 2
.ds IND600 \*[SN-NO-DOT]
GENERAL
.XS
\*(SN 			General
.XE
.LP
Arrays are essentially lists of variables of the same type, allowing the user to address each variable individually using a common name and a unique subscript or subscripts. In the simplest case, an array is a vector and is known as a one-dimensional array. A matrix is a two-dimensional array, etc.

There is no limit to the number of subscripts allowed, other than those imposed by the ability of the computer to store the array.
.NH 2
.ds IND610 \*[SN-NO-DOT]
ARRAY DECLARATIONS
.XS
\*(SN 			Array declarations
.XE
.LP
Arrays may be of type integer, real, long real, Boolean, or string and these are declared similarly to scalar variables, except the size of the array must be stated. For each subscript that the array possesses, a lower and an upper bound called the "bound pair" for that subscript must be given.

For example, to declare two one-dimensional integer arrays \fCA\fR and \fCB\fR with lower bound 1 and upper bound 5:

.fam C
   INTEGER ARRAY A,B[1:5]
.fam T

NOTE: The lower and upper bounds must be enclosed in square brackets and separated by a colon.

When there are two or more subscripts, the declaration is similar, and the bound pairs are separated by commas. Thus

.fam C
   LONG REAL ARRAY P,Q,R[-5:2,0:10]
.fam T

declares three long real arrays, \fCP\fR, \fCQ\fR and \fCR\fR, with the first subscript bounded by -5 and 2 and the second subscript bounded by 0 and 10. 

Arrays of the same type but of different sizes may be declared in the same statement:

.fam C
   REAL ARRAY A[1:10], B,C[1:10,1:12]
.fam T

NOTE: In the case of real arrays, the \fCREAL\fR may be omitted in the declaration, and is assumed by default, thus:

.fam C
   ARRAY A[1:10], B,C[1:10,1:12,-5:5]
.fam T

behaves like \fCREAL ARRAY\fR...

The bounds in an array need not be static, as in the examples above, but can be any arithmetic expressions, which are evaluated to give an integer value for the individual bound pairs. The use of such dynamic array declarations will become apparent later. The bound limit should not exceed 2147483647 in magnitude, but in general memory problems should arise with much lower bounds (unless your computer has a \fB*very huge*\fR memory).

NOTE: arrays dimensions may be more than two... if you imagine how to use such multi-dimension arrays.

NOTE: string arrays elements size is fixed, set by default to 255, and cannot be changed.

NOTE: to declare a real array \fCA\fR and a real variable \fCV\fR, one could be tempted to write:

.fam C
   REAL ARRAY A[1:10], V;		! invalid form;
.fam T

Unfortunately, the \fCARRAY\fR keyword (and the specifier that precedes it, for example \fCREAL\fR) form a unique statement; thus, two separate instructions must be used, i.e.

.fam C
   REAL ARRAY A[1:10]; REAL V;		! valid form;
.fam T

.NH 2
.ds IND620 \*[SN-NO-DOT]
ARRAY ELEMENTS
.XS
\*(SN 			Array elements
.XE
.LP
An individual element of an array can be referred to by following the name of the array by a list of subscripts in square brackets. The number of subscripts must be identical to the number in the array declaration. Thus, a typical element of A used in the last declaration might be

.fam C
   A[5] or A[9] or generally, A[I]
.fam T

where \fCI\fR is some integer expression or, in general, any expression whatsoever, with the limitation that its value, when used as a subscript and evaluated as an integer, is in the range of that array \fCA\fR dimension. 

As an example of the use of arrays, consider the declaration

.fam C
   REAL ARRAY D,E,F [1:10,1:10]
.fam T

and suppose the operation required, was to set \fCF\fR equal to the matrix product of \fCD\fR and \fCE\fR:

.fam C
   FOR I := 1 UNTIL 10 DO
   FOR J := 1 UNTIL 10 DO
   BEGIN X := 0;
      FOR K := 1 UNTIL 10 DO X := X + D[I,K]*E[K,J];
      F[I,J] := X
   END
.fam T

NOTE

.IP 1. 
In the above example, \fCX\fR is used to accumulate the Inner product of the multiplication for all values of \fCI\fR and \fCJ\fR. The variable \fCX\fR was used instead of \fCF\fR to facilitate the computation.  

.IP 2. 
An element of an array of a particular type may be used anywhere that a scalar variable of the same type may be used, that is in every possible math expression, but not as the controlling variable in a \fCFOR\fR statement.  This is a minor deviation from the DEC system-10/20 ALGOL.
.LP
.bp
.NH 1
.ds IND630 \*[SN-NO-DOT]
BLOCK STRUCTURE
.XS
\*(SN 		\fBBlock structure\fR
.XE
.LP
.NH 2
.ds IND640 \*[SN-NO-DOT]
GENERAL
.XS
\*(SN 			General
.XE
.LP
An ALGOL program structure is somewhat more complicated than other high-level languages, such as FORTRAN. An ALGOL program consists of a series of "blocks" arranged hierarchically. A block consists of the words \fCBEGIN\fR and \fCEND\fR enclosing the declarations and (optionally) statements.

Thus:

.fam C
   BEGIN
      ...
      BEGIN
         ...
      END;
      ...
      BEGIN
         ...
         BEGIN
            ...
         END;
         ...
      END;
      ...
   END.
.fam T

is an ALGOL program, assuming appropriate declarations and statements in the blocks. Notice the semicolons at the end of each inner block and the dot at the end of the outermost block.

The block structure offers the user many interesting features not available in non-block structured languages. For instance, the user may declare an identifier that appears to conflict with another identifier in an enclosing block. Thus:

.fam C
   BEGIN INTEGER I;
      ...
      BEGIN INTEGER I;
         ...
      END
      ...
   END
.fam T

There is no conflict, here, because they are two different \fCI\fRs. The only \fCI\fR that statements in the outer block can "see" is the one in the outer block. Similarly, any statement in the inner block will always use the I in that block. Such a declaration in an inner block is known as a "local" variable and takes precedence over declarations occurring at an outer or more "global" level. In general, all variables can be "seen" from any point in a program that is either in the same block as the declaration or in a block that is enclosed by the block in which the declaration of the variable occurred. Note that a more local variable is always taken in preference to a relatively global variable. Consider the following example:

.fam C
   BEGIN INTEGER I, J;
      [1]
      BEGIN INTEGER J,K
         [2]
      END;
      BEGIN INTEGER I,K
         [3]
      END
   END
.fam T

Any statements occurring at point \fC[1]\fR can see the declarations of \fCI\fR and \fCJ\fR, which are local but cannot see the declarations of \fCJ\fR and \fCK\fR in the first inner block, or the declarations of \fCI\fR and \fCK\fR in the second inner block. At [2], the local variables \fCJ\fR and \fCK\fR can be seen, as can the global variable \fCI\fR in the outer block. The global variable \fCJ\fR is not seen because the local variable \fCJ\fR takes precedence over it; the variables \fCI\fR and \fCK\fR in the second inner block are not seen at all. A similar situation occurs at [3]; here both local variables \fCI\fR and \fCK\fR, as well as the global variable \fCJ\fR, are seen.

Note that the "scope" of a variable is the set of all places in a program where it can be seen and therefore used. This term will be used frequently throughout this text.

In general, local variables are more efficient to use than global ones. This statement is also true of most ALGOL 60 implementations. Where a global variable is used frequently, a local variable should be assigned as having the same value and used instead. For example:

.fam C
   BEGIN INTEGER I;
      ...
      I := ...
      BEGIN INTEGER II;
         II := I;
         ...
         ... II ...
      END
      ...
   END
.fam T

Here, in the inner block, a local variable \fCII\fR is used and assigned the value of the global variable \fCI\fR for use throughout the local block. 
.NH 2
.ds IND650 \*[SN-NO-DOT]
ARRAYS WITH DYNAMIC BOUNDS
.XS
\*(SN 			Arrays with dynamic bounds
.XE
.LP
The concept of the scope of a variable can be applied most usefully to arrays. In \fHtaxi\fR (and in the DEC system-10/20 ALGOL), all arrays are constructed at execution time (that is, no fixed space is reserved during compile-time), irrespective of whether their bounds are static or dynamic. When a declaration of an array is encountered within a block, the space required to construct it is obtained and the array is laid out. When the end of the block enclosing the array is reached, that is, the array variable is no longer within scope, the space utilized by the array is recovered and can be used later for other arrays.

Consider the case of a problem in which the size of an array to be used in a calculation is dependent on the data to be processed. The programmer has the choice of making the array large enough to cope with the worst of the cases or constructing the array with dynamic bounds to suit the size required by the particular data. The first method has the disadvantage of wasting space on many occasions. The latter method only has the minor disadvantage of the overhead needed to construct the array. Such overhead is very small compared to the running time of most programs, therefore, the second method is more desirable.

Consider the following example:

.fam C
   BEGIN INTEGER N;
   L: N := ...
      ...
      BEGIN ARRAY A[1:N,1:N];
         ...
      END;
      GOTO L
   END
.fam T

A value for \fCN\fR is calculated in this example, possibly dependent on some data read into the program, and used to declare the array \fCA\fR, which is used to process the data in the inner block. When the end of the inner block is reached, the space used by \fCA\fR is recovered and control passes to \fCL\fR, where another value for \fCN\fR is calculated, and the process repeated.
.bp
.NH 1
.ds IND660 \*[SN-NO-DOT]
PROCEDURES
.XS
\*(SN 		\fBProcedures\fR
.XE
.LP
Procedures are similar in concept to the FORTRAN subroutines, but with more sophisticated and general applications.

A \fIprocedure\fR is a portion of an ALGOL program that is given a name for identification and can be "called" from any part of a program which is in the scope of the body of the procedure. A procedure can execute a series of statements, and can eventually return a value to the procedure body. In addition, it may or may not have parameters. User procedure names are called in case-sensitive mode, so that if you define procedure \fCTEST\fR, you have to call it as \fCTEST\fR, because \fCtest\fR would not be found; this is in accordance with the user variables rules for what about the fictitious variables, that must be created in case-sensitive mode. (In the above examples, the fictitious associated variable would be \fCTEST\fR, which is different from \fCTest\fR or \fCtest\fR.) 

A \fIformal parameter\fR is an entity declared and used in the body of a procedure; an \fIactual parameter\fR is the value passed to a formal parameter in the calling environment (it may be any legal string or numeric expression).

In \fHtaxi\fR (as in the DEC system-10/20 ALGOL), a procedure can be one of the following types: integer, real, long real, Boolean, string, label or typeless. The formal parameters of a procedure (known as "dummy variables" in FORTRAN), can be one of the following types: integer, real, long real, boolean, string, label as scalars; they can be values, arrays, or procedures. There are nineteen different types of formal parameters. (See table 11-1.)

Whenever the formal parameter associated with the actual parameter in a procedure body appears in the body of the procedure, the actual parameter is re-evaluated as if it appeared in the procedure body at that point. For example, if the actual parameter is an array element like \fCA[I]\fR, the element is re-evaluated using the current value of \fCI\fR (i.e., the value available at each time the formal parameter is used, not at the time the procedure body is entered). 
.NH 2
.ds IND670 \*[SN-NO-DOT]
PARAMETERS CALLED BY "VALUE"
.XS
\*(SN 			Parameters called by "value"
.XE
.LP
Calling parameters by \fIvalue\fR is the most common and, except for arrays and strings, the most efficient way to pass a parameter to a procedure. The value of the expression presented in a procedure call, known as the actual parameter, is evaluated on entry to the procedure and assigned to a formal parameter within the procedure. This formal parameter acts like a local variable in the procedure which is initialized, the initial value being that of the actual parameter supplied in the call to the procedure.

In the case of arrays or strings, since a new copy of the array or string is made, this type of parameter-passing for arrays and strings should be avoided unless specifically required.

Parameters called by value are specified in the \fCVALUE\fR list.

NOTE: labels are always passed by value, independently from the presence of the statement VALUE (which is optional).
.NH 2
.ds IND680 \*[SN-NO-DOT]
PARAMETERS CALLED BY "NAME"
.XS
\*(SN 			Parameters called by "name"
.XE
.LP
Calling parameters by "name" is a useful method of passing a parameter to an ALGOL procedure. Whenever a variable or an array item is passed to a parameter by name, the parameter acts like a substitute of the variable or the array item, that will inherit all the changes applied to the parameter. 

Table 11-1 shows the different types of formal parameters, with valid actual parameters that can be substituted in a procedure call.

.B1
.CD
Table 11-1
Parameters in a Procedure Call

.DE
.fam C
  Formal Type           Actual Parameter
.ps 9
.vs -3
 -----------------------------------------------------------------
  Integer
  Real                  Any arithmetic expression
  Long Real
  Boolean

  String                Any string expression (refer to Chapter 13)

  Label                 A label or switch element (refer specially
                        to Chapter 7 and Chapter 12)

  Switch                A switch

  Integer Array         An array of type integer*

  Real Array (or Array) An array of type real*
 
  Long Real Array       An array of type long real*

  Boolean Array         An array of type Boolean*

  String Array          An array of type string

  Procedure             A non-type procedure

  Integer Procedure
  Real Procedure        A procedure of type integer, real, or long
  Long Real Procedure   real or Boolean
  Boolean Procedure

  String Procedure      A procedure of type string
  Label Procedure       A procedure of type label

.fam T
.ps 8
 (*) In the case where the array parameter is called by value, any arithmetic type (integer, real or long real) array is allowed as an actual parameter. A conversion of the type takes place during the copying process.

.B2
.LP
You may wonder why there's not the Label array case; this case is performed by the \fCSWITCH\fR declaring procedure, because a switch is a sort of string array with labeling properties. (See \fCSWITCH\fR.)
.NH 2
.ds IND690 \*[SN-NO-DOT]
PROCEDURE HEADINGS
.XS
\*(SN 			Procedure headings
.XE
.LP
Procedure headings identify the type of procedure, the number and the type of parameters. A procedure heading consists of:

.IP 1.   
The type of procedure (omitted in the case of typeless procedures).
   
.IP 2.   
The word \fCPROCEDURE\fR followed by the name of the procedure.
   
.IP 3.   
A semicolon if the procedure has no parameters, otherwise
   
.IP 4.   
A list of the formal parameters, enclosed in parentheses, separated by commas, and followed by a semicolon.
   
.IP 5.   
Specifications of the formal parameters.
.LP

A procedure identifier must begin with a letter, and optionally be followed by one or more letters, decimal digits or dots. A procedure identifier may not contain more than 64 characters.

Omitting formal parameter specifications, this looks like

.fam C
   LONG REAL PROCEDURE LR;
   BOOLEAN PROCEDURE BOOLE(I,J,K);
   PROCEDURE CALC(THETA,X);
.fam T

The formal parameter specification that follows consists of a list of descriptions of the formal parameters, appearing in any order, and a value specification if any of the parameters are to be called by value. (If this is omitted, the parameters, by default, will be called by name.) For example, the specification of the formal parameters for the second example above might be:

.fam C
   VALUE I,J; INTEGER I,J,K;
.fam T

meaning that all three formal parameters are of type integer (scalars), and \fCI\fR and \fCJ\fR are to be called by value, while \fCK\fR is to be called by name. A typical formal parameter specification for the third example might be:

.fam C
   REAL PROCEDURE THETA; ARRAY X;
.fam T

NOTE: Procedure headings must precede the body of the procedure.

NOTE: In a procedure heading spread in two or more lines (for instance the \fCPROCEDURE name()\fR line and the variable declaration lines), comments should be avoided, though permitted, because they obfuscate the specifications section. So that instead of the erroneous

.fam C
   REAL PROCEDURE ALPHA(T,H);
   COMMENT FOR ALPHA IN A BAD AREA! ;
   INTEGER T; REAL H; BEGIN ...
.fam T

use the following form

.fam C
   COMMENT FOR ALPHA IN A GOOD AREA! ;
   REAL PROCEDURE ALPHA(T,H);
   INTEGER T; REAL H; BEGIN ...
.fam T

which is more clear. Anyway, follow your sense.
.NH 2
.ds IND700 \*[SN-NO-DOT]
PROCEDURE BODIES
.XS
\*(SN 			Procedure bodies
.XE
.LP
The body of a procedure is that part which follows the procedure heading, and consists of a single statement, a compound statement, or a block. In the last-mentioned case, there may be declarations of local variables within the block, and also other blocks or procedures. Consider the following examples of realistic procedures:

.IP 1. 
A real procedure, \fCSQUAREROOT\fR, to calculate the square root of a real quantity. The first parameter is the quantity, the second is a label that is used as an escape if the quantity is found to be negative. The result of the procedure is the square root of the quantity. Note how the result of the calculation is assigned to the procedure by placing the name of the procedure on the left-hand side of an assignment.

.fam C
       REAL PROCEDURE SQUAREROOT(X,L);
              VALUE X; REAL X; LABEL L;

       BEGIN  REAL Y,Z;
              IF X < 0 THEN GOTO L;
              Y := (1+X)/2;

       IT:    Z := (X/Y + Y)/2;
              IF ABS(Z-Y) < 1&-6 THEN GOTO OK;
              Y := Z;  GOTO IT;

       OK:    SQUAREROOT := Z;
     
       EXIT:  END SQUAREROOT;

.fam T
The previous example uses the Newton-Raphson method for finding the square root of a number by taking an initial approximation \fC(1 + X)/2\fR and iterating until the difference between successive approximations is less then 1&-6.  The procedure is again described below, with the aid of some commentary. The DEC system-10/20 ALGOL alternative method of commentary (refer to 2.4) is used for brevity:

.fam C
       REAL PROCEDURE SQUAREROOT(X,L);
              VALUE X; REAL X; LABEL L;
 
              BEGIN  ! CALCULATES THE VALUE OF SQRT(X)
                       USING THE NEWTON-RAPHSON METHOD.
                       L IS USED FOR AN ESCAPE IF X < 0;

              REAL Y,Z;
              IF X < 0 THEN GOTO L;    ! EXIT IF X < 0;
              Y := (1+X)/2;            ! FIRST APPROXIMATION;
 
       IT:    Z := (X/Y + Y)/2;        ! ITERATE;
              IF ABS(Z-Y) < 1&-6
                   THEN GOTO OK;       ! TEST FOR CONVERGENCE;
              Y := Z;  GOTO IT;        ! OTHERWISE CONTINUE;
 
       OK:    SQUAREROOT := Z;         ! FINAL RESULT;
 
              END SQUAREROOT;
.fam T

.IP 2. 
A procedure \fCSUM\fR to sum of the values of any real procedure \fCG\fR over the integers \fC1 ..... N\fR (that is, iterating \fCN\fR times) where \fCN\fR is also a parameter of the procedure. 

.fam C
       REAL PROCEDURE SUM(G,N);

              VALUE N; REAL PROCEDURE G; INTEGER N;

       BEGIN  INTEGER I; REAL X;

               X := 0;

               FOR I : = 1 UNTIL N DO X := X + G(N) ;

               SUM : = X
       END
.fam T

NOTE: In this example, the formal parameter \fCG\fR is invoked so that the actual procedure substituted for \fCG\fR is called. It's the user responsibility to call \fCG\fR with the same number of parameters with the same types and order required by the procedure passed as the argument, otherwise, an error is raised.
.LP
.NH 2
.ds IND710 \*[SN-NO-DOT]
PROCEDURE CALLS
.XS
\*(SN 			Procedure calls
.XE
.LP
In the preceding example, procedure \fCG\fR was \fIcalled\fR. Since \fCG\fR is a function procedure, it is only necessary for its name to appear in an expression for the procedure to be entered with the actual parameters specified substituted for the formal parameters.

The function procedure \fCSQUAREROOT\fR of a preceding example can also appear in an expression, for example: 

.fam C
   P := SQUAREROOT(Z+O.5, ERR)
.fam T

causes the square root of \fCZ + 0.5\fR to be calculated.

An example of the use of the procedure \fCSUM\fR can be used to calculate the sums of the square roots of the first \fCJ\fR integers, with the result squared, as follows:

.fam C
   X := SUM(SQUAREROOT,J)^2;
.fam T

Here is a further example of a procedure and the calls:

.fam C
   PROCEDURE MATRIXMULT(A,B,C,N);
 
   VALUE N; ARRAY A,B,C; INTEGER N;

     BEGIN   INTEGER I,J,K; REAL X;

     COMMENT THIS PROCEDURE PERFORMS THE MATRIX
     MULTIPLICATION OF 'B' AND 'C' AND STORES THE RESULT
     IN 'A'. THE ARRAYS ARE ASSUMED TO BE SQUARE
     AND OF BOUNDS 1:N,1:N;

     FOR I := 1 UNTIL N DO
     FOR J := 1 UNTIL N DO
  
     BEGIN X := 0;

     FOR K := 1 UNTIL N DO X := X +
      	B [I,K]*C[K,J];
     A[I,J] := X
     
     END
   END;
.fam T

A typical call for this procedure might be

.fam C
   MATRIXMULT(E,F,G,N) ;
.fam T

or

.fam C
   MATRIXMULT(E,F,F,N) ;
.fam T

Since the arrays are called by name, a call such as \fCMATRIXMULT(E,E,F,N);\fR would give rather interesting results.

This call could be made to work by calling \fCB\fR and \fCC\fR of \fCMATRIXMULT(A,B,C,N);\fR by value. However, this would increase the overhead of the procedure considerably.
.NH 2
.ds IND720 \*[SN-NO-DOT]
PROCEDURE SCOPES
.XS
\*(SN 			Procedure scopes
.XE
.LP
As shown in the ISO 1538-1984, ALGOL lets design nested procedures, up to any level. Let's consider the following example:

.fam C
      BEGIN
           
         PROCEDURE PROC1(...);
	 BEGIN
         ....
           
            PROCEDURE PROC3(...);
	    BEGIN
            ....
             
               PROCEDURE PROC5(...);
	       BEGIN
               ....
               END PROC5;
           
            ....
            END PROC3;
   
         ....
         END PROC1;
   
   
         PROCEDURE PROC2(...);
	 BEGIN
         ....
      
            PROCEDURE PROC4(...);
	    BEGIN
            ....
   
            END PROC4;
   
   	    PROCEDURE PROC6(...);
	    BEGIN
   	    ....
   
   	    END PROC6;
    
         ....
         END PROC2;
      
      ....
      END.
.fam T

If level 0 is assumed to be the level of the most outer block (root block), the example illustrates the creation of \fCPROC1\fR at level 0, which creates \fCPROC3\fR at level 1, which creates \fCPROC5\fR at level 2. Then follows the creation of \fCPROC2\fR at level 0, which creates \fCPROC4\fR and \fCPROC6\fR at level 1.

In general, the following law is respected: a procedure may be called if created at level 0 or in the same level of the caller; a procedure can thus call itself.

Here are the scopes of the procedures in the example:

.IP 1. 
root block sees \fCPROC1\fR and \fCPROC2\fR;

.IP 2. 
\fCPROC1\fR sees \fCPROC3\fR (created in its space) and \fCPROC2\fR (at the same level).
 
.IP 3. 
\fCPROC3\fR sees \fCPROC5\fR (created in its space) and \fCPROC1/PROC2\fR (at level 0).

.IP 4. 
\fCPROC5\fR sees \fCPROC1\fR and \fCPROC2\fR (at level 0).

.IP 5. 
\fCPROC2\fR sees \fCPROC4\fR and \fCPROC6\fR (created in its space) and \fCPROC1\fR (at level 0).
 
.IP 6. 
\fCPROC4\fR sees \fCPROC6\fR (at the same level) and PROC1/PROC2 (at level 0).
 
.IP 7. 
\fCPROC6\fR sees \fCPROC4\fR (at the same level) and \fCPROC1/PROC2\fR (at level 0).

.IP 8. 
All procedures see themselves.
.LP
.NH 2
.ds IND730 \*[SN-NO-DOT]
ADVANCED USE OF PROCEDURES
.XS
\*(SN 			Advanced use of procedures
.XE
.LP
.NH 3
.ds IND740 \*[SN-NO-DOT]
More on argument passing by name
.XS
\*(SN 			More on argument passing by name
.XE
.LP
We have seen in previous sections that a call by name with a variable argument binds the two variables (the one passed and the one in the body of the procedure) so that an assignment to the latter is also an assignment of the former.

If instead any \fIformula\fR is passed to a reference argument (that is a number, an expression, a function, etc.), the argument is evaluated at run time returning its proper value. This is legal as far as the argument, in the body of the procedure, is used only in the right part of an assignment (that is, in an expression), because the number is legally admitted as an element of an expression. 

If instead this argument is used in the left part, that is an assignment to it is tried, an error is raised, because there is no variable associated. Besides, since the calculated value is always referred to the original call, any instantiation would be reset to the value originally passed at each invocation.

See the following example:

.fam C
 BEGIN
   REAL R;
   PROCEDURE TEST(X);
   BEGIN
      X:=3; PRINTLN(X);
   END;

   R:=4;
   TEST(R);
   PRINTLN(R);
   TEST(5*4);
   PRINTLN(R);
 END.
.fam T

The first call to the \fCTEST\fR procedure links the reference of \fCR\fR to \fCX\fR, and when \fCX\fR is assigned 3, this value is assigned also to \fCR\fR; the second call to \fCTEST\fR passes a numeric expression, which is inherited by \fCX\fR, but when the assignment is tried, an error is raised.  The total output is of course:

.fam C
  3.000000000 
  3.000000000 
 
 taxi runtime processor error in procedure test,  at line 5:
 Illegal assignment due to invalid lefthand type.
 X:=3;
 ^
 Error code 88
.fam T

Let's now suppose, absurdly, that the assignment would be possible. The argument \fCX\fR had inherited the value 20 (that is 5*4) in the creation of the procedure instance and the assignment would try to set \fCX=3\fR; the assignment fails in reality, because there is no linked variables, but we have supposed that it succeeds. So, when \fCX\fR is printed, since there was no assignment, it would recall it's former attribution stored in it (remember that is was not passed by value). So that it would print 20 instead of 3. To avoid these inconsistencies \fHtaxi\fR (as many other compilers/interpreters) bans such assignments, and returns an error message. 

Anytime you have to alter a variable in a procedure, you must assure either to create it as a procedure local variable or to use the \fCVALUE\fR specifier while creating the procedure. In this case, the \fCVALUE\fR specifier would simply create a normal variable with the original value passed (20 in the example) that any further assignment would reset to the new assigned value.

Another interesting consequence is this; if you plan to use a string by name in a procedure, you may think that using it in the right part of an assignment as a char subscript is legal and painless; for instance:

.fam C
   INTEGER I,J;
   PROCEDURE TEST(X) LETTERS:(L) FIRST:(C);
   STRING X; INTEGER L,C;
   BEGIN
      L:=LENGTH(X);
      C:=X.[1];
   END;
   
   TEST("TODAY IS A GOOD DAY",I,J)
.fam T

The previous piece of code will fail while assigning \fCC:=X.[1]\fR, because the search of the first character of the string is made upon the referenced string, and not in the body of \fCX\fR, but there is no reference string associated, because \fCX\fR was feed with a literal string. The result is the error message of not found string:

.fam C
 taxi runtime processor error in procedure test,  at line 10:
 Illegal number, undeclared numeric variable or undefined numeric function.
 C:=X.[1];
          ^
 Error code 81
.fam T

In these cases, either you associate a string \fCS:="TODAY IS A GOOD DAY"; \fRand pass \fCS\fR to \fCTEST\fR or, since you never have to instantiate \fCX\fR, you set it as \fCVALUE\fR. In both cases, you will get the correct answer.
.LP
.NH 3
.ds IND750 \*[SN-NO-DOT]
Jensen's Device
.XS
\*(SN 			Jensen's Device
.XE
.LP
This method of using a procedure exploits the power and flexibility of the call-by-name concept. Consider the following example:

.fam C
        REAL PROCEDURE SUM(I,N,X); VALUE N; INTEGER I,N; REAL X;
        BEGIN   REAL Y;
                Y:=0;
                FOR I:=1 UNTIL N DO Y:=Y+X;
                SUM:=Y;
        END SUM;
.fam T

On the surface, the procedure appears to calculate the value of \fCN * X\fR. However, consider the call

.fam C
  Z := SUM(J,10,A[J]);
.fam T

and remember that \fCJ\fR and \fCA[J]\fR are parameters called by name. Since \fCI\fR and consequently \fCJ\fR take new values, each \fCX\fR in the loop is evaluated as a particular value of \fCA[J]\fR, using the value of \fCJ\fR just assigned. Hence the above call calculates

.fam C
   A[1] + A[2] + ..... + A[10].
.fam T

Similarly, the call

.fam C
   Z := SUM(K,M,A[I,K]*B[K,J]);
.fam T

calculates the \fC(I,J)\fRth inner product of \fCA\fR and \fCB\fR.

The following listing shows a complete program in which Jensen's device is used:

.fam C
  BEGIN
     INTEGER L; L:=10;
     REAL ARRAY ARR[1:L];
     INTEGER K; REAL RES;

     COMMENT: JENSEN'S DEVICE TEST;
     REAL PROCEDURE SUM(I,N,X); VALUE N; INTEGER I,N; REAL X;
     BEGIN   REAL Y;
        Y:=0;
        FOR I:=1 UNTIL N DO Y:=Y+X;
        SUM:=Y;
     END SUM;

     COMMENT MAIN;
     FOR K:=1 UNTIL L DO ARR[K]:=K;
     RES := SUM(K,L,ARR[K]);
     PRINT (RES,5,7)
  END MAIN.
.fam T

This program prints:

.fam C
       55.0000000
.fam T

which is precisely the sum of \fCA[1] + A[2] + ... + A[10]\fR, where \fCA[J]=J\fR.

.LP
.NH 3
.ds IND760 \*[SN-NO-DOT]
General Problem Solver (GPS)
.XS
\*(SN 			General Problem Solver (GPS)
.XE
.LP
Another technique can be illustrated to show the power of the calling by name feature in ALGOL. This was introduced by D.E. Knuth and J.N. Merner in their article titled "ALGOL 60 confidential"\*[*]. The algorithm is simple:

.fam C
        REAL PROCEDURE GPS(I1,N,Z,V); 
        REAL I1,N,Z,V;
        BEGIN
                FOR I1 := 1 STEP 1 UNTIL N DO Z := V;
                GPS := 1
        END;
.fam T

This algorithm was later exposed by B. Randell and L.J. Russell in their 1964 book "Algol 60 implementation"\*[*], the best text about how to implement an ALGOL compiler\*[*] called Whetstone ALGOL. This is the book I consulted.
.FS
Published in Commun. ACM 4, 6 (June 1961), pages 268-272.
.FE
.FS
Published by the Automatic Programming Information Centre (APIC), Brighton College of Technology, England, 1964, Academic Press, London and New York.
.FE
.FS
Just to clear the field, I built \fHtaxi\fR following my personal model, not using the techniques exposed in this book. And this can be derived by the fact the Whetstone Compiler is far more clever than mine.
.FE
Let us Randell and Russell speak (page 253): "\fIThe single example chosen to illustrate the workings of the Whetstone ALGOL Compiler is based on the procedure GPS (General Problem Solver) in the article \fRALGOL 60 Confidential\fI by Knuth and Merner. In this article the possibilities of recursive procedures and parameters called by name are demonstrated by using GPS in several assignment statements, one of which has the effect of multiplying two matrices together, and which is presented as a challenge to compiler writers. This use of the procedure GPS, which is rightly described by Knuth and Merner as \fRjust ALGOL 
for ALGOL'S sake\fI, nevertheless demonstrates several fundamental features of ALGOL which are of great practical value, and hence is worth using to demonstrate translation techniques. In order to reduce the task of description to more manageable proportions, the working of the Whetstone Compiler is demonstrated on a program using GPS to set up a matrix \fR\fCA\fR\fI, in which the element \fR\fCA[i,j]\fR\fI has the value \fR\fCi+j\fR. [...]\fI Though it is not claimed that the method of implementation is in any way optimum, the example shows that the standard mechanisms of the Whetstone Compiler for handling recursive procedures and parameters called by name can easily deal with the apparent complications of General Problem Solver\fR.

The following listing shows a complete program in which the GPS device is used:

.fam C
 BEGIN
   REAL I;
   REAL J;
   REAL ARRAY A[1:4, 1:5];
 
   REAL PROCEDURE GPS(I1,N,Z,V); 
      REAL I1,N,Z,V;
      BEGIN
         FOR I1 := 1 STEP 1 UNTIL N DO Z := V;
         GPS := 1
      END;
 
   COMMENT MAIN SECTION;
   I := GPS(J, 5.0, I, GPS(I, 4.0, A[I,J], I + J));
 
   COMMENT OUTPUT OF I AND J;
   OUTREAL(1,I);OUTSTRING(1,"\\n");
   OUTREAL(1,J);OUTSTRING(1,"\\n");
 
   COMMENT OUTPUT OF THE ARRAY;
   FOR I:=1 STEP 1 UNTIL 4 DO BEGIN
      FOR J:=1 STEP 1 UNTIL 5 DO BEGIN
         OUTREAL(1,A[I,J]); 
      END;
      OUTSTRING(1,"\\n");
   END;
 END.
.fam T

The program is built for a general ISO ALGOL, avoiding all the DEC features or new procedures that \fHtaxi\fR has builtin. As such, this program can be executed on a wider range of ALGOL compilers/interpreters. This program is here reported with a 4x5 matrix (the dimensions in the book were 2x3, supposedly to ease tracking down the program flow, but the principle remains the same and you can change the dimensions at will). 

The output of the program follows:

.fam C
  1.000000000 
  5.000000000 
  2.000000000  3.000000000  4.000000000  5.000000000  6.000000000 
  3.000000000  4.000000000  5.000000000  6.000000000  7.000000000 
  4.000000000  5.000000000  6.000000000  7.000000000  8.000000000 
  5.000000000  6.000000000  7.000000000  8.000000000  9.000000000 
.fam T

The core of the procedure is of course the assignment \fCZ := V\fR (occurring in the second call to \fCGPS\fR), with \fCZ\fR bound to \fCA[I,J]\fR and \fCV\fR bound to \fCI + J\fR. (You can find the original program in the \fCfiles/\fR directory of the installation package as \fCgps.alg\fR.)

A far more complex example is also given in the book (page 266), conceived by Knuth and Merner themselves. This program calculated the product of two matrices using the GPS. The example given in the book is here copied and integrated in a full working program:

.fam C
 BEGIN
   REAL I;
   REAL J;
   REAL K;
   COMMENT M = 4, N = 5, P = 3;
   REAL ARRAY A[1:4, 1:5], B[1:5, 1:3], C[1:4, 1:3];
 
   REAL PROCEDURE GPS(I1,N,Z,V); 
   REAL I1,N,Z,V;
   BEGIN
      FOR I1 := 1 STEP 1 UNTIL N DO Z := V;
      GPS := 1
   END;

   COMMENT FILL UP MATRICES A AND B;
   FOR I:=1 STEP 1 UNTIL 4 DO
      FOR J:=1 STEP 1 UNTIL 5 DO
         A[I,J]:=I*J;
   FOR I:=1 STEP 1 UNTIL 5 DO
      FOR J:=1 STEP 1 UNTIL 3 DO
         B[I,J]:=I*J;

   COMMENT MAIN SECTION;
   I:=GPS(I, 1.0, C[1,1], 0.0) * GPS(I, (4-1) * GPS(J,(3-1) * GPS(K,5, C[I,J],
   C[I, J]+A[I,K]*B[K,J]), C[I,J+1], 0.0), C[I+1,1], 0.0);

   COMMENT OUTPUT OF I AND J;
   OUTREAL(1,I);OUTSTRING(1,"\\n");
   OUTREAL(1,J);OUTSTRING(1,"\\n");
   OUTREAL(1,K);OUTSTRING(1,"\\n");

   COMMENT 
   OUTPUT OF THE ARRAYS;
   OUTSTRING(1,"ARRAY A IS\\n");
   FOR I:=1 STEP 1 UNTIL 4 DO BEGIN
      FOR J:=1 STEP 1 UNTIL 5 DO BEGIN
         OUTREAL(1,A[I,J]); 
      END;
      OUTSTRING(1,"\\n");
   END;
   OUTSTRING(1,"ARRAY B IS\\n");
   FOR I:=1 STEP 1 UNTIL 5 DO BEGIN
      FOR J:=1 STEP 1 UNTIL 3 DO BEGIN
         OUTREAL(1,B[I,J]); 
      END;
      OUTSTRING(1,"\\n");
   END;
   OUTSTRING(1,"\\nMULTIPLICATION RESULT ARRAY C IS\\n");
   FOR I:=1 STEP 1 UNTIL 4 DO BEGIN
      FOR J:=1 STEP 1 UNTIL 3 DO BEGIN
         OUTREAL(1,C[I,J]); 
      END;
      OUTSTRING(1,"\\n");
   END;
END.
.fam T

Again, the program is built for a general ISO ALGOL. This program is here reported with a 4x5 matrix \fCA\fR, with a 5x3 matrix \fCB\fR and of course with a 4x3 result matrix \fCC\fR. (You can find the original program in the \fCfiles/\fR directory of the installation package as \fCmgps.alg\fR.)

The output of the program follows:

.fam C
  1.000000000 
  2.000000000 
  5.000000000 
 Array A is
  1.000000000  2.000000000  3.000000000  4.000000000  5.000000000 
  2.000000000  4.000000000  6.000000000  8.000000000  10.00000000 
  3.000000000  6.000000000  9.000000000  12.00000000  15.00000000 
  4.000000000  8.000000000  12.00000000  16.00000000  20.00000000 
 Array B is
  1.000000000  2.000000000  3.000000000 
  2.000000000  4.000000000  6.000000000 
  3.000000000  6.000000000  9.000000000 
  4.000000000  8.000000000  12.00000000 
  5.000000000  10.00000000  15.00000000 
 
 Multiplication array C is
  55.00000000  110.0000000  165.0000000 
  110.0000000  220.0000000  330.0000000 
  165.0000000  330.0000000  495.0000000 
  220.0000000  440.0000000  660.0000000 
.fam T

A web page (an email, actually) where the GPS is also confidentially treated can be found at:

.pdfhref W -D https://cseweb.ucsd.edu/~goguen/courses/230w02/GPS.html https://cseweb.ucsd.edu/~goguen/courses/230w02/GPS.html

The author is Dana Dahlstrom. She introduces the GPS in few words and presents some algorithms, the second being the latter here exposed. Towards the end, she adds: "\fIIn fact, using GPS we can actually compute any computable function \fR[...]\fI using a single ALGOL assignment statement.\fR"

This is much more than a compliment for ALGOL!
.NH 3
.ds IND770 \*[SN-NO-DOT]
Recursion	
.XS
\*(SN 			Recursion
.XE
.LP
ALGOL procedures are recursive, that is, they may call themselves, directly or indirectly, to any reasonable depth. (The only restriction is the amount of core storage available to the object program.) An often-quoted and very inefficient method of calculating the factorial function of a small positive integer \fCN\fR is:

.fam C
        INTEGER PROCEDURE FACTORIAL(N); 
        VALUE N; INTEGER N;
              IF N = 1 THEN FACTORIAL := 1
              ELSE FACTORIAL := N * FACTORIAL(N-l);
.fam T

This procedure has only one single statement and no local variables, and can, therefore, be written in a compact form. A call such as

.fam C
   J := FACTORIAL(6);
.fam T

causes the procedure to be entered with \fCN\fR equal to 6. The call to \fCFACTORIAL\fR inside \fCFACTORIAL\fR enters the procedure a second time with \fCN\fR equal to 5, but this \fCN\fR is different from the one to the previous \fCN\fR, which retains its value of 6, and is stored in a different space. In this particular case, \fCFACTORIAL\fR is entered six times, the last time with \fCN\fR equal to 1.

NOTE: you'll be tempted (as I did) to see how far (and how inefficient) is this method. This depends of course on your machine, but when you reach the limit you will get a memory error.

Consider the following program:

.fam C
  BEGIN
     INTEGER PROCEDURE FACTORIAL(N);
     VALUE N; INTEGER N;
        IF N=1 THEN FACTORIAL := 1
        ELSE FACTORIAL:= N * FACTORIAL(N-1);

        PRINT(FACTORIAL(10));
  END.
.fam T

This program can be used with any positive value, trying to exploit the machine capabilities. For what about mine, a laptop with 4 Intel Core i3-5005U CPU at 2.00GHz and Linux OpenSuse Leap 15.1 as Operating System, these limits are reached:

.IP -
values from 1 to 12 return a meaningful value
.IP -
values from 13 to 49450  return always 2147483647
.IP -
values from 49451 on print "Out of Memory"

The first range is OK. The second range returns an infinitive integer representing the INTEGER type proper limit. The third range means that if I use a value greater than 49450, the number of "suspended" processes waiting for the previous to complete are too much for my computer. Probably yours is much more clever...

.NH 3
.ds IND780 \*[SN-NO-DOT]
Break and continue
.XS
\*(SN 			Break and continue
.XE
.LP
Modern programming involves two procedures that are missing in ALGOL \fCBREAK\fR and \fCCONTINUE\fR.

The procedure \fCBREAK\fR is used to break a cycle (definite or indefinite) in some specific position and under specific conditions; one example in C is:

.fam C
 while (i<limit) {
         d+=3*i;
         if (d>=t) break;
         i++;
 }
.fam T

The same task in ALGOL cannot be replicated as-is, because \fCBREAK\fR is missing; but this situation can be completely emulated by the sage usage of \fCGOTO\fR and labels, for instance:

.fam C
 WHILE i<limit DO BEGIN
        d:=d+3*i;
        IF d>=t THEN GOTO rec;
        i:=i+1;
 END;
 rec:  comment continue here...;
.fam T

\fHtaxi\fR takes care, in case of a \fCGOTO\fR outside the cycle itself, of \fIdismissing\fR the cycle from memory, that is resetting the inner references of the cycle as if the cycle was never executed.

Analogously, \fCCONTINUE\fR is a procedure that resumes the cycle starting over again. This is useful when reading characters from a source; example in C:

.fam C
 while ((c=fgetc(fd)) {
        if (c=='A') continue; 
        putchar(c);
 }
.fam T

This piece of source continues reading from the file source \fCfd\fR, printing all characters found but the capital \fC'A'\fR.

The same task in ALGOL is in DEC flavour:

.fam C
 redo: 
 WHILE (INSYMBOL(c)) DO BEGIN
        IF c=65 THEN GOTO redo;
        OUTSYMBOL(c);
 END;
.fam T

Or in ISO flavour\*[*]:

.fam C
 redo:
 WHILE (INCHARACTER(0,c)) DO BEGIN
        IF c=65 THEN GOTO redo;
        OUTCHARACTER(1,c);
 END;
.fam T

In this case, the reading from an external source is an independent procedure, that always gives a result suitable for the cycle. Using \fCGOTO redo\fR (or \fCCONTINUE\fR) in different situations, that is directing backwards the program flow, causes repetition of code but this can generate closed loops (in Rutishauser's words), that is loops that end only by intervention by the user (by the CTRL-C keys combination).
.FS
The previous pieces of code use the \fCINCHARACTER\fR and \fCOUTCHARACTER\fR procedures that are not ISO but ISO-like; the ISO ones are less friendly.
.FE

.NH 2
.ds IND790 \*[SN-NO-DOT]
LAYOUT OF DECLARATIONS WITHIN BLOCKS
.XS
\*(SN 			Layout of declarations within blocks
.XE
.LP
Declarations must always be made at the head of a block, before any assignments, procedure calls, etc., in any order; the order respected by DEC system-10/20 ALGOL was:

 1) scalars and arrays 
 2) procedures and switches (see Chapter 12).

but \fHtaxi\fR removed this restriction. They are here written in case a program must be written for \fHtaxi\fR \fIand\fR for the DEC system-10/20 ALGOL.
.NH 2
.ds IND800 \*[SN-NO-DOT]
LAYOUT OF PROCEDURE CALLS WITHIN BLOCKS
.XS
\*(SN 			Layout of procedure calls within blocks
.XE
.LP
Procedure calls that occur in a block should follow the declarations of variables that occur in the block. Consider the following example:

.fam C
      PROCEDURE P(X); VALUE X; REAL X;
      BEGIN INTEGER J;
            ....
            J : = I;
	    ....
      END;
      ...
      Z:=P(3);
      INTEGER I;
.fam T

The assignment of \fCI\fR to \fCJ\fR within the body of \fCP\fR utilizes the \fCI\fR that is declared following the call of \fCP\fR. The interpreter cannot "see" this \fCI\fR and, therefore, cannot take any rational action. In a case such as this, the user must declare \fCI\fR before the call of \fCP\fR:

.fam C
      PROCEDURE P(X); VALUE X; REAL X;
      BEGIN INTEGER J;
            ....
            J : = I;
	    ....
      END;

      INTEGER I;
      Z:=P(3);
.fam T

If the user neglects to declare \fCI\fR before the call of \fCP\fR, the interpreter can easily detect the condition, because either \fCI\fR is unknown at the time of the assignment to \fCJ\fR, whereupon an error message will occur when the declaration of \fCI\fR in the body of \fCP\fR is met, or there is a more global \fCI\fR available and, in this case, this last is used (and maybe changed, with unpredictable results).
.NH 2
.ds IND810 \*[SN-NO-DOT]
FORWARD REFERENCES
.XS
\*(SN 		Forward references
.XE
.LP
Although the DEC system-10/20 ALGOL interpreter operated in one pass and consequently, required the usage of the procedure \fCFORWARD\fR and is references, \fHtaxi\fR operates in a completely different way, and \fCFORWARD\fR is no longer necessary..

A forward reference for a procedure had to be given when a procedure was called (either directly, or indirectly, through passing the procedure name as an actual parameter in a procedure call) before its body was encountered by the interpreter, for instance as in the case

.fam C
        FORWARD REAL PROCEDURE Q;

        PROCEDURE P(X); VALUE X; REAL X;
        BEGIN REAL Y;
               Y:= Q(X);
        END P;

        REAL PROCEDURE Q(Z); VALUE Z; REAL Z;
        BEGIN REAL F;
               F := P(Z);
        END Q;
.fam T

Since \fCQ\fR was evaluated in \fCP\fR before its declaration, a \fCFORWARD\fR reference to \fCQ\fR had to be implemented. Reversing the two definitions would bring no help, since also \fCQ\fR calls \fCP\fR.

Since \fHtaxi\fR operates a preliminary parsing of the source text to establish all references for \fCWHILE\fR and \fCFOR\fR cycles, for \fCBEGIN-END\fR blocks, for \fCIF-THEN-ELSE\fR structures and for \fCPROCEDURE\fR declarations, all procedures are stored in memory and are always available from the start, with the restriction for subsidiary procedures. (See Procedure Scopes 11.6.)

The conclusion is that, at present, the \fCFORWARD\fR statement and all characters until the terminator are simply ignored by \fHtaxi\fR. The \fCFORWARD\fR procedure is maintained only for backward compatibility.
.NH 2
.ds IND820 \*[SN-NO-DOT]
EXTERNAL PROCEDURES
.XS
\*(SN 		External procedures
.XE
.LP
The DEC system-10/20 ALGOL compiler could load during runtime already compiled procedures, attaching them to the program under compilation; this was achieved through the \fCEXTERNAL\fR procedure. The form of this keyword was the same as that of a \fCFORWARD\fR declaration, but with the word \fCFORWARD\fR replaced by \fCEXTERNAL\fR. For example:

.fam C
   EXTERNAL INTEGER PROCEDURE CALC
.fam T

Such an \fCEXTERNAL\fR declaration could be made in any block within the program and had the same scope as if the procedure source appeared at that point.

Since \fHtaxi\fR is not compiled, such a statement would be simply ignored and the line not loaded (there is no compiled procedure or program to be found); because of this, the \fCEXTERNAL\fR procedure in \fHtaxi\fR was conceived with different scopes: if the \fCEXTERNAL\fR keyword is followed by a literal string. 

E.g.
.fam C
   EXTERNAL "FILENAME";
.fam T

\fHtaxi\fR performs the following steps, during the loading of the program:
  
.IP 1. 
\fC"FILENAME"\fR, which may contain a proper path, and which must be a textual ALGOL program file (usually with the .alg extension) is opened. The file name must be a literal string enclosed in double quotes or double single quotes. 

.IP 2. 
the file is copied in memory in the position of the \fCEXTERNAL\fR declaration (which is discarded) by expanding the memory. Nothing must precede or follow the \fCEXTERNAL\fR statement, which must reside alone in its program line.
.LP

These steps are executed before the preliminary process so that the external file is successively pre-parsed along with the rest of the program. 

If \fC"FILENAME"\fR is not found, an error is raised and execution stops.

The external file is required to be a normal textual file; it should contain only \fCPROCEDURE\fR declarations and their bodies; in practice, it is a simple collection (library) of well-tested procedures. If some extra procedure blocks are found, they are loaded as well and later possibly executed, with unpredictable results. 

It's responsibility of the programmer to call the loaded procedures with the correct number of arguments in the right order. It's far too easy to forget an argument or invert types without the declaration under your eyes!

For instance, a library with one factorial function could be stored in \fCfactlib.alg\fR:

.fam C
   COMMENT FACTORIAL INSECURE RECURSIVE FUNCTION;
   INTEGER PROCEDURE FACTORIAL(N);
        VALUE N; INTEGER N;
        IF N=1 THEN FACTORIAL := 1
        ELSE FACTORIAL:= N * FACTORIAL(N-1);
.fam T

A practical example would be then, for instance in file \fCfact.alg\fR:

.fam C
   BEGIN
        EXTERNAL "factlib.alg";
        PRINT(FACTORIAL(7));
   END.
.fam T

If you build a library of well-tested procedures, their usage can be effective and practical if you should write anywhere in the listing statements like:

.fam C
   .....
   EXTERNAL "math.alg";
   EXTERNAL "string.alg";
   .....
.fam T

This guarantees that, if library procedures are well-tested, any error found is likely to reside in the current file and not in the library. This reduces the amount of debugging width. For this reason, libraries should print no error messages but should only return certain flags to signal the correct/incorrect computation; these flags are to be evaluated in the caller for the proper, driven error message printing or error-resolution code.

Some notes:

.IP \[bu]
This particular version of \fCEXTERNAL\fR is not compatible with the DEC system-10/20 ALGOL and does not belong to the ISO 1538-1984 document either.
.IP \[bu]
If you use option \fC--list\fR, you will see that the listed program will include the external libraries, loaded starting from the position of \fCEXTERNAL\fR, which is removed.
.IP \[bu]
For error-managing purposes, external libraries data are stored in a special memory, made available only in case of errors that require the printing of an error message. You can load at maximum up to 64 library files through the procedure \fCEXTERNAL\fR. This value is contained in the variable \fCEXTERNLIBMAX\fR in \fCcustom.h\fR; if you should need more libraries to load, change this value and recompile.
.IP \[bu]
The \fCEXTERNAL\fR procedure may be invoked as \fCINCLUDE\fR, with identical effects.
.NH 2
.ds IND830 \*[SN-NO-DOT]
ADDITIONAL METHODS OF COMMENTARY
.XS
\*(SN 		Additional methods of commentary
.XE
.LP
Three further ways of writing commentary are available to the user in addition to \fCCOMMENT\fR and \fC!\fR described in Section 2.4.
.NH 3
.ds IND840 \*[SN-NO-DOT]
Comment After \fCEND\fR
.XS
\*(SN 			Comment after \fCEND\fR
.XE
.LP
Following the delimiter word \fCEND\fR, the user may add any commentary, terminated by a semicolon, or the dot in case of the outer block's \fCEND\fR; the characters that may appear in such a comment may be any, in any combination (even reserved words if necessary), except for the dot, the terminator words (see Table 2-4), and the comment words \fC!\fR and \fCCOMMENT\fR. For example:

.fam C
   END OF PROC INVERT;
.fam T

I repeat here that the terminator words \fCEND\fR, \fCELSE\fR, the dot \fC.\fR, the semicolon \fC;\fR and the comment words \fC!\fR and \fCCOMMENT\fR cannot appear in the \fCEND\fR commentary: their presence would put the interpreter in confusion (for block and \fCIF\fR structures and for comment inside a comment). So avoid using such characters in such commentary. Use synonyms like 'closure' for \fCEND\fR, 'otherwise' for \fCELSE\fR or 'remark' for \fCCOMMENT\fR and use the comma and the colon or the question mark as punctuation signs. Use the dash \fC-\fR as the terminator (dot or semicolon).
.NH 3
.ds IND850 \*[SN-NO-DOT]
Comments Within Procedure Headings
.XS
\*(SN 			Comments within procedure headings and calls
.XE
.LP
The ISO 1538-1984 specifies that any procedure heading may be enriched with specifiers (from the second argument on), like:

.fam C
   SPUR(A) ORDER:(N) RESULT TO:(S);
.fam T

From a closing \fC)\fR to the following opening \fC:(\fR, any combination of characters (but the semicolon) may be used. The colon is required (also by the DEC system-10/20 ALGOL and the ISO documents) and must be followed by the open parenthesis of the following argument.

Even the call to such procedures may be as such enriched:

.fam C
   SPUR(VECTOR) ORDER:(7) RESULT IS:(RES);
.fam T

This call is equivalent to

.fam C
   SPUR(VECTOR, 7, RES);
.fam T

Please note that the final closing parenthesis is one (count the couples: they match) and that no space is allowed between one colon and the open parenthesis.
.NH 3
.ds IND860 \*[SN-NO-DOT]
Comments after the last \fCEND\fR
.XS
\*(SN 			Comments after the last \fCEND\fR
.XE
.LP
Any free form text, after the dot closing the outer block ended with last \fCEND\fR onward, is ignored by the interpreter, so that any free-form text can be put here, program inputs and outputs, info, manual, help and so forth, also using the 'forbidden' characters \fCEND\fR, \fCELSE\fR, the dot and the semicolon, i.e.:

.fam C
   BEGIN      !outer block;
        ...
        ...
        ...
   END OF OUTER BLOCK.<-- here begins the further free-form commentary

   This program was created by John Smith on Oct. 23, 2016.
   It can be used with the following data:
   ...
   ...
.fam T

This free form text is NOT loaded in memory and can be used to store results or any kind of text being physically not part of the listing. 

This feature can be used to isolate a final part of the program by using an intermediate \fCEND.\fR (with the dot) put just before the part to be isolated.
.bp
.NH 1
.ds IND870 \*[SN-NO-DOT]
SWITCHES
.XS
\*(SN 		\fBSwitches\fR
.XE
.LP
.NH 2
.ds IND880 \*[SN-NO-DOT]
GENERAL
.XS
\*(SN 			General
.XE
.LP
Switches enable the user to jump to one of the stored labels, depending on the value of an arithmetic expression, and in addition, provide automatic detection when such an expression is out of range for the switch.
.NH 2
.ds IND890 \*[SN-NO-DOT]
SWITCH DECLARATIONS
.XS
\*(SN 			Switch declarations
.XE
.LP
A switch declaration takes the form of the word \fCSWITCH\fR followed by the name of the switch, an assignment (\fC:=\fR), and a list of labels, all on the same line (the declaration cannot be broken). These are called switch elements and must be in the scope of the switch declaration. For example:

.fam C
   SWITCH SW := LAB,L1,L2,OK,STOP;
.fam T

A switch name must follow the usual rules of scope and, therefore, must not conflict with any local variable of the same name. 

In addition to the example above, a switch element can also be one of the labels in another switch declaration. 

E.g.:
.fam C
   SWITCH SW := LAB,L1,QUIT;
   SWITCH TW := PROF,SW[I];
.fam T

Here \fCSW[I]\fR and \fCTW[2]\fR are in practice the same label, through the value of \fCI\fR ranging from 1 to 3. Label \fCTW[1]\fR is instead a different and independent label.

Being a switch a collection of labels (i.e. strings), a string can be assigned to a switch element. Look a the following example:

.fam C
 STRING S;
 SWITCH SW:=LAB1,LAB2;
 S:=SW[1];
 WRITE(S);
.fam T

The previous piece of program prints \fCLAB1\fR, which is the label stored in \fCSW\fR at position one. This is because, in \fHtaxi\fR, labels are stored internally in \fCSW\fR as strings, and an assignment to a string item is made then possible\*[*].
.FS
I don't know if this is adherent to the DEC or ISO protocol, but I consider this an enhancement, not a bad feature.
.FE
.NH 2
.ds IND900 \*[SN-NO-DOT]
USE OF SWITCHES
.XS
\*(SN 			Use of switches
.XE
.LP
A jump to a particular label in a switch declaration is made by following the word \fCGOTO\fR with the name of the switch and an arithmetic expression in square brackets. Thus:

.fam C
   GOTO SW[I];
.fam T

where the variable \fCI\fR takes values from 1 to the \fCN\fRth label in the \fCSWITCH\fR list. This causes control to pass to the \fCI\fRth label in the switch declaration, unless \fCI\fR is negative or zero, or is larger than the number of switches in the switch declaration. In either case, there is no transfer of control (an error is raised). If the expression in square brackets is not of integer form, it is evaluated and rounded as usual. Consider the following more complicated example:

.fam C
   SWITCH SW := LAB,L1,L2,OK,STOP;
   SWITCH TW := L3,SW[J],L4;
   ....
   GOTO TW[I];
.fam T

If \fCI\fR has the value 3, a jump to \fCL4\fR occurs. If \fCI\fR has the value 2 and \fCJ\fR has the value 1, a jump to \fCLAB\fR occurs, via \fCSW\fR.

More sophisticated switch elements are described in Chapter 14.
.bp
.NH 1
.ds IND910 \*[SN-NO-DOT]
STRINGS
.XS
\*(SN 		\fBStrings\fR
.XE
.LP
.NH 2
.ds IND920 \*[SN-NO-DOT]
GENERAL
.XS
\*(SN 			General
.XE
.LP
\fHtaxi\fR (as the DEC system-10/20 ALGOL) includes a major extension to the string features defined in the Revised Report. Users wishing to run their programs on other compilers/interpreter should check whether the compiler they will use offers similar facilities. Scalar, array or procedure variables may be of type \fCSTRING\fR, and are declared by the reserved word \fCSTRING\fR. The string memory size, length and contents of string variables are defined via the various assignment statements described below.

Typical string declarations might be:

.fam C
   STRING S,T; STRING ARRAY SA[1:10];
   STRING PROCEDURE B(X); VALUE X; REAL X;
.fam T
.NH 2
.ds IND930 \*[SN-NO-DOT]
STRING EXPRESSIONS AND ASSIGNMENTS
.XS
\*(SN 			String expressions and assignments
.XE
.LP
String expressions are limited to a single variable or array element, a string procedure call or a string constant. (For a full description of string constants see Section 4.5.) The only string operators are the comparison operators and the assignment operator. All other operations are achieved via the string library procedures described in Section 13.7.

String expressions can be assigned only to string variables. For example:

.fam C
   S:=T;
   SA[I]:=SA[3];
   SA[2]:=B(Z);
   T:="ANY ""OLD"" IRON";
.fam T
.NH 2
.ds IND940 \*[SN-NO-DOT]
BYTE STRINGS
.XS
\*(SN 			Byte strings
.XE
.LP
The value associated with a string variable is a sequence of bytes (in some ways, byte strings can be thought of as arrays of characters), up to 255 characters in length. Thus, when a byte string is created using a \fCREAD\fR statement, the programmer need not know how long the string will be. The routine starts accepting characters after encountering the open quotation marks and continues until the close quotation marks have been read (or until the total length of 255 is reached).

When one string is assigned to another, as in the following example:

.fam C
   S:=T;
.fam T

then a copy of \fCT\fR is made to which \fCS\fR will refer. Subsequent changes to the value of \fCT\fR will not affect \fCS\fR, or vice versa, unless a further assignment is made from one to the other.
.NH 2
.ds IND950 \*[SN-NO-DOT]
BYTE SUBSCRIPTION
.XS
\*(SN 			Byte subscription
.XE
.LP
Byte strings can be modified through the byte subscription mechanism. Individual bytes in a string are referenced by following the string variable name by a decimal point and then the subscript number enclosed in square brackets. For example

.fam C
   S.[I]
.fam T

refers to the \fCI\fRth byte of string \fCS\fR. The subscript may be any arithmetic expression and is evaluated in the same way as an array subscript of dimension \fC[1:N]\fR, where \fCN\fR is the length of the string.

Byte-subscripted string variables are regarded as being of type integer, having an integer value equivalent to the byte to which they refer. Therefore, to change the value of a particular byte in a string, a byte-subscript must appear on the left-hand side of an arithmetic statement with the appropriate new value on the right-hand side. 

If the new value is too large to be held in the byte, this is simply truncated. No warning is given.

If on the other hand, the subscript is out of the string memory space (less than 1 or greater than the maximum size) an error message is shown and execution stops.
.NH 2
.ds IND960 \*[SN-NO-DOT]
NULL STRINGS
.XS
\*(SN 			Null strings
.XE
.LP
When a string is declared, a space of memory is assigned to it, filled with null values. Until a value is assigned to a string by the program, the string takes the null value, and any attempt to reference the string by a byte-subscript in the right-hand side of an arithmetic statement and within the string limits will yield zero.

Assignment with a byte-subscript on the left-hand side (and within the string limits) will store in the string memory that character value, but if any nulls should exist before it, this will be at all effects invisible. 

E.g. 
.fam C
   S:="Art";
.fam T

String picture:
.fam C
  1 2 3 4 5 6 7 8 9...
 |A|r|t|0|0|0|0|0|0|

   S.[5]:=101; ! = 'e';
.fam T
String picture:
.fam C
  1 2 3 4 5 6 7 8 9...
 |A|r|t|0|e|0|0|0|0|
          ^
 inserted character
.fam T

The insertion of character \fC'e'\fR in the middle of the string and beyond the null terminator is ignored; string \fCS\fR is anyway printed as \fC"Art"\fR.

But if the null is removed: 

.fam C
  S.[4]:=105; ! = 'i';
.fam T

String picture:
.fam C
  1 2 3 4 5 6 7 8 9...
 |A|r|t|i|e|0|0|0| |
        ^
inserted character
.fam T

the character \fC'e'\fR becomes visible and string \fCS\fR is printed as \fC"Artie"\fR. 
.NH 2
.ds IND970 \*[SN-NO-DOT]
STRING COMPARISONS
.XS
\*(SN 			String comparisons
.XE
.LP
Two byte-strings can be compared with each other using the usual comparison operators. For example 

.fam C
   IF S < T THEN GO TO L;
.fam T

where \fCS\fR and \fCT\fR are string variables, string constants or string procedures. The effect of the comparison is to compare the strings byte-by-byte, the "lesser" string being that with the first lower value byte, working from left to right. Thus \fC"ABCD"\fR is less than \fC"ABCE"\fR or \fC"ABCDE"\fR. Where the strings to be compared are of different byte sizes, then the smaller bytes are regarded as being extended on the right by null bits.

Trailing blanks (spaces or tabs, or any mixture thereof) are treated as equal. Similarly, ASCII strings of different lengths will compare equally if the extra length comprises only spaces and tabs. In all other cases strings of unequal length can only be regarded as equal if the extra length consists entirely of blanks.

Thus, if \fCS\fR contains \fC"  ABCD  "\fR and \fCT\fR contains \fC"ABCD"\fR they are treated as equal, and a test such \fCS=T\fR would return true.

The cases of letters matter (upper or lower): they will compare equally if cases match. Thus if \fCS\fR contains \fC"A"\fR and \fCT\fR contains \fC"a"\fR, they are treated as different, and a test such \fCS=T\fR would return false.
.NH 2
.ds IND980 \*[SN-NO-DOT]
STRING LIBRARY PROCEDURES
.XS
\*(SN 			String library procedures
.XE
.LP
Sections 16.5 and 16.6 deal with the input and output procedures that apply to strings. What follows is the String Library Procedures implemented in \fHtaxi\fR.
.NH 3
.ds IND990 \*[SN-NO-DOT]
String concatenation
.XS
\*(SN 			String concatenation
.XE
.LP
A string can be assigned the concatenated value of two (or more) strings with the procedure \fCCONCAT\fR. For example

.fam C
   S:=NEWSTRING(36);
   S:=CONCAT(T,U);
   S:=CONCAT(S,T);
.fam T

If the sum of the lengths of the two strings were greater than the memory space of the result string, the bytes copied would be truncated as appropriate.

Thus, supposing \fCS\fR is a string of width 36, and that \fCS="123456789012345678901234567890"\fR with length equal to 30, and another string \fCT="1234567890"\fR with length equal to 10, the statement

.fam C
   S:=CONCAT(S,T);
.fam T

would return in \fCS\fR the string \fC"123456789012345678901234567890123456"\fR, with the total length equal to 36 (its width) and the last characters of \fCT\fR silently cut out.

The original DEC system-10/20 ALGOL procedure admitted two strings only; \fHtaxi\fR lets the user add a variable chain of strings, all separated by a comma:

.fam C
   S:=CONCAT(S,T," HELP ",S);
.fam T

would return the string \fCS\fR plus the string \fCT\fR, plus the literal string addition \fC" HELP "\fR (spaces included) and another instance of \fCS\fR; provided the sum of the length of arguments is less than or equal to the length of the hosting string size, any sum is accomplished as desired.

This more-than-two-strings ability is an enhancement that the original DEC system-10/20 ALGOL and the ISO documents don't even quote.

If one string only is given to \fCCONCAT\fR, the result is this string. No error message is output:

.fam C
   S:=CONCAT(T);
.fam T

is equivalent to

.fam C
   S:=T
.fam T
This feature is a natural consequence of the previous enhancement, extending the feature to the single case. I don't know what was the behaviour of the original DEC ALGOL.
.NH 3
.ds IND1000 \*[SN-NO-DOT]
String length and size
.XS
\*(SN 			String length and size
.XE
.LP
The primary attribute of a string, that is its length in characters, is returned by the integer procedure \fCLENGTH\fR.

Thus

.fam C
   I:=LENGTH(S);
.fam T

would return the number of bytes of string \fCS\fR in \fCI\fR (whichever, depending on the context).

The procedure \fCSIZE\fR, instead, has a different usage than that in the DEC system-10/20 ALGOL. The bit size of a string, in \fHtaxi\fR, is fixed to 8 bits (one byte). So the \fCSIZE\fR procedure has been redesigned to return the memory size of a string (the maximum width), that is the longest string it can host.

Thus

.fam C
   J:=SIZE(S);
.fam T

would return 255 for a default string, or the value the string has after resizing it with \fCNEWSTRING\fR. The difference with \fCLENGTH\fR is subtle: while \fCLENGTH\fR tells us how many characters the string has now, \fCSIZE\fR tells us how many characters it can have at most. This is useful to check the memory space of a string and resize it before usage if needed.
.NH 3
.ds IND1010 \*[SN-NO-DOT]
String copy
.XS
\*(SN 			String copy
.XE
.LP
A portion of an existing string can be assigned to another one using the string procedure \fCCOPY\fR. This procedure can have one, two or three parameters. 

Suppose the string \fCT\fR is assigned the value \fCT:="THE VILLAIN AND THE PAINTER"\fR; now the following cases can be considered: 

.IP 1. 
The effect of \fCCOPY\fR with one parameter is precisely the same as a simple string assignment, and this feature has been retained for the sake of continuity. 

    \fCS:=COPY(T);\fR is equivalent to \fCS:=T;\fR 

Thus, for what about the previous assignment, \fCS\fR is assigned with \fC"THE VILLAIN AND THE PAINTER"\fR. 

.IP 2. 
Where there are two parameters, as in the following example: 

.fam C
    S:=COPY(T,M) ; 
.fam T

where \fCM\fR is an arithmetic expression, then \fCS\fR is assigned the value of the first through \fCM\fRth byte of \fCT\fR. Thus, if \fCM\fR yields 11, \fCS\fR is assigned with \fC"THE VILLAIN"\fR. 

.IP 3. 
If there are three parameters, as in the following example: 

.fam C
    S:=COPY(T,M,N) ; 	
.fam T

where both \fCM\fR and \fCN\fR are arithmetic expressions, then \fCS\fR is assigned the value of the \fCM\fRth through \fCN\fRth byte of \fCT\fR.  Thus, if \fCM\fR yields 17 and \fCN\fR yields 27, \fCS\fR is assigned with \fC"THE PAINTER"\fR. 

If values are invalid or beyond the scope (for instance \fCM<0\fR or \fCM>N\fR), the assigned result is the empty string. No warning is given.
.LP

As the examples show, the string count starts from 1.
.NH 3
.ds IND1020 \*[SN-NO-DOT]
String resize
.XS
\*(SN 			String resize
.XE
.LP
A string can be resized by using this string procedure. \fCNEWSTRING\fR takes two parameters, the first being the number of null bytes to be assigned to the string, and the optional second (ignored by \fHtaxi\fR but left for the sake of compatibility\*[*]) the characters size, and assigns the string new definition to the string on the left of the equal sign.

For example

.fam C
   S:=NEWSTRING(100[,7]) ;
.fam T

causes \fCS\fR to be defined as a string of 100 ASCII characters; the previous memory space is destroyed and given back to the operating system. (The second argument 7, if given, is ignored.) The content of the previous memory is copied back (not beyond new string limit) to the new space. String \fCS\fR is 100 bytes long at this point (and thus byte subscripts up to and including \fCS.[100]\fR are valid).
.FS
\fHtaxi\fR uses ASCII characters, which always are 8-bit numbers in the range 0\[di]255. The DEC system-10/20 ALGOL computer could treat characters of different sizes, and this is the reason for the second argument. (For instance, characters in the range 0\[di]127 use only numbers, lower and upper alphabetic characters and classic punctuation characters, and if this was the only need of the programmer, he/she could redefine a string which occupied less memory than the 8-bit size characters.)
.FE
.NH 3
String erasure
.XS
\*(SN 			String erasure
.XE
.LP
In Section 13.5 it was explained that if a null string is assigned to another string, then that string also becomes null, and the value previously held is lost. The procedure \fCDELETE\fR has the same effect on the string passed to it as a parameter, as the assignment of a null string would have, but while \fCS:=T\fR (with \fCT\fR being an empty string) would simply set \fCS\fR to the empty string, \fCDELETE(S)\fR would also erase all characters in the memory space of \fCS\fR.

NOTE: the length reference of the variable is not reset to 255 characters (if for instance it was resized with \fCNEWSTRING)\fR. Thus, the statement 

.fam C
   DELETE(S); 
.fam T

has the effect of erasing the string memory space of \fCS\fR maintaining its current structure. 

If \fCS\fR is a string array, all instances of its elements (whatever dimension they have) are set to null. \fCLENGTH\fR would return 0 and \fCSIZE\fR would return the original memory size.
.NH 3
.ds IND1040 \*[SN-NO-DOT]
String extraction
.XS
\*(SN 			String extraction
.XE
.LP
Four string procedures for coordinated extraction are provided; these are \fCHEAD\fR, \fCTAIL\fR, \fCTAKE\fR and \fCDROP\fR. They are similar - but not identical - to the ones of the Unisys Algol. (See vol. 1, edition 2001.)

The procedure \fCHEAD\fR returns all the characters in a given base string, starting from the first character, that don't match any of the characters in a given match string. 

E.g.:
.fam C
  S:="ABCDE";
  WRITE(HEAD(S,"CE"));
.fam T

would print \fCAB\fR because the character \fCC\fR of the match string stops the extraction; in the following case:

.fam C
  WRITE(HEAD(S,"JE"));
.fam T

would extract \fCABCD\fR, because character \fCJ\fR is not present in \fCS\fR, and the first break happens on character \fCE\fR.

The procedure \fCTAIL\fR is the complementary version of \fCHEAD\fR because it returns all the characters in a given base string, discarding all leading characters until a match in the given match string occurs. 

E.g.
.fam C
  S:="ABCDE";
  WRITE(TAIL(S,"CE"));
.fam T

would print \fCCDE\fR because the character \fCC\fR of the match string stops the discarding and starts the extraction; in the following case:

.fam C
  WRITE(TAIL(S,"JE"));
.fam T

would extract \fCE\fR, because character \fCJ\fR is not present in \fCS\fR, and the discard proceeds until character \fCE\fR is met (and copied).

For the procedures \fCHEAD\fR and \fCTAIL\fR, the following scheme holds:

.fam C
  S is equivalent to HEAD(S,T) + TAIL(S,T)
.fam T

The procedure \fCTAKE\fR returns a fixed number of characters in a given base string, starting from the first character; basing on the given length argument, as for example in the following lines:

.fam C
  S:="ABCDE";
  WRITE(TAKE(S,2));
.fam T

would print \fCAB\fR, that is the first two characters in \fCS\fR. If the index is lower than zero, or greater than the string length, it is resized accordingly.

The procedure \fCDROP\fR is the complementary version of \fCTAKE\fR, because it returns all the characters in a given base string, discarding the number of leading characters according to the length argument. 

E.g.
.fam C
  S:="ABCDE";
  WRITE(DROP(S,2));
.fam T

would print \fCCDE\fR, because it would skip the first 2 characters.

For the procedures \fCTAKE\fR and \fCDROP\fR, the following scheme holds:

.fam C
  S is equivalent to TAKE(S,N) + DROP(S,N)
.fam T

A final consideration: the Unisys procedure \fCTAKE(S,N)\fR is equivalent to the DEC system-10/20 ALGOL procedure \fCCOPY(S,N)\fR, with two arguments. Besides, the Unisys procedure \fCDROP(S,N)\fR is equivalent to the DEC system-10/20 ALGOL procedure \fCCOPY(S,N+1,M)\fR, where \fCM\fR is the length of string \fCS\fR (or greater value).
.NH 3
.ds IND1050 \*[SN-NO-DOT]
String from number
.XS
\*(SN 			String from number
.XE
.LP
A number can be converted to its string representation by using the string procedure \fCCONVERT\fR. This procedure has one argument, which is the number to be converted, as a costant, a variable, an array item or a math expression:

.fam C
  S := CONVERT(N)
.fam T

The number is converted to its proper form, that is an integer if it has no decimal part otherwise it is a decimal number; in case the \fCREAL\fR/\fCLONG REAL\fR is specified with a exponentation, the number is classified accordingly; the string representation is followed by the space terminator, and is preceded by the minus sign in case its negative, or by a space if positive. E.g., the following piece of code:

.fam C
  S := CONVERT(10.67&56);
  OUTSTRING(1,S);
.fam T

returns as expected:

.fam C
  1.067000000&+57
.fam T	 
.bp 
.NH 1
.ds IND1060 \*[SN-NO-DOT]
CONDITIONAL EXPRESSIONS AND STATEMENTS
.XS
\*(SN 		\fBConditional expressions and statements\fR
.XE
.LP
.NH 2
.ds IND1070 \*[SN-NO-DOT]
GENERAL
.XS
\*(SN 			General
.XE
.LP
\fHtaxi\fR (as the DEC system-10/20 and ISO ALGOL) allows great flexibility in the construction of expressions and conditions.

Consider, for example, a variable \fCI\fR which could be set equal to 0 or 1 according to the value of a Boolean variable \fCB\fR: this could be written as:

.fam C
   I := 0;
   IF B THEN I := 1;
.fam T

Also, consider the case where a user wants to perform some action, depending on the value of \fCB\fR:

.fam C
   IF B THEN X1 := Y; IF NOT B THEN X2 := Y;
.fam T

.NH 2
.ds IND1080 \*[SN-NO-DOT]
CONDITIONAL OPERANDS
.XS
\*(SN 			Conditional operands
.XE
.LP
\fHtaxi\fR allows the user to substitute a conditional operand for any operand in an expression by the use of a construction involving 

.fam C
   IF ..... THEN ..... ELSE.
.fam T

For instance, the first example above can be rewritten

.fam C
   I := IF B THEN 1 ELSE 0;
.fam T

This is more compact and of great use in cases such as: 

.fam C
   J := J + (IF K < 1 THEN 1-K ELSE K-1);
.fam T

Note that the conditional operand must always be bracketed if included in an expression; brackets may be avoided only when it forms the complete expression by itself.

In general, a conditional operand may replace an operand in any arithmetic or Boolean expression. Also, a conditional operand may replace a label and act as an element in a switch list, for example:

.fam C
   SWITCH SW := L1, IF B THEN L2 ELSE L3, L4;
.fam T

It is also permitted in an array subscript or in a byte subscript;

E.g.
.fam C
   X := A[I, IF L = 0 THEN J ELSE J+1];
.fam T

It must be underlined here that a conditional expression is made of the \fCTHEN\fR *and* the \fCELSE\fR part, i.e. the \fCELSE\fR part is not optional, because a value must be ensured, either as a result of the \fCTHEN\fR or as a result of the \fCELSE\fR part.

Besides, the expression \fCIF..THEN..ELSE..\fR is interpreted a value, and must reside on the same line: it cannot be broken. An error is printed if \fCTHEN\fR or \fCELSE\fR are not found.
.NH 2
.ds IND1090 \*[SN-NO-DOT]
CONDITIONAL EXPRESSIONS AND STATEMENTS
.XS
\*(SN 			Conditional expressions and statements
.XE
.LP
Since a conditional operand may replace any operand in an expression, operands can also be replaced in conditional expressions. Consider the following example:

.fam C
   IF (IF B THEN B1 ELSE B2) THEN I := I + 1;
.fam T

The \fCIF-THEN-ELSE\fR between brackets may be seen as a number. It is the same sequence as if it was written as

.fam C
   C:=B2;
   IF B THEN C:=B1;
   IF C THEN I := I + 1;
.fam T

where \fCC\fR takes the value \fCB1\fR or \fCB2\fR depending on the value of \fCB\fR.

.NH 2
.ds IND1100 \*[SN-NO-DOT]
CONDITIONAL STATEMENTS
.XS
\*(SN 			Conditional statements
.XE
.LP
The reader was introduced to conditional statements of the form

.fam C
   IF B THEN S1 ELSE S2
.fam T

in Chapter 7. The full power of this type of statement can now be demonstrated. First, \fCS1\fR and \fCS2\fR can be compound statements or blocks. For example:

.fam C
   IF I < 0 THEN 
      BEGIN
         I := -I; B:= FALSE
      END 
   ELSE
      BEGIN 
         I := I + 1; GOTO L2
      END;
.fam T

Second, the whole structure of the \fCIF ..... THEN ..... ELSE\fR statement can be made more powerful by using conditional statements within themselves. For example:

.fam C
   IF X < 0 THEN X := 0 ELSE IF B THEN GOTO L
.fam T

This is equivalent to the following sequence of statements:

.fam C
       IF NOT X < 0 THEN GOTO L1;
       X := 0; GOTO L2;
   L1: IF NOT B THEN GOTO L2;
       GOTO L;
   L2:
.fam T

The former method of expression is both briefer and more elegant. Conditional statements take the general form 

.fam C
   IF B THEN S1 ELSE S2
.fam T

where \fCS1\fR and \fCS2\fR may both be conditional statements. However, if there is any ambiguity, bracketing using \fCBEGIN\fR and \fCEND\fR must be used to clarify this. Consider the following example: 

.fam C
   IF B THEN IF X = 0 THEN Y := Z ELSE P := Q;
.fam T

This piece of code can be seen as

.fam C
   IF B THEN
      BEGIN
         IF X = 0 THEN Y := Z
      END
   ELSE P := Q
.fam T

or

.fam C
   IF B THEN
      BEGIN
        IF X = 0 THEN Y := Z ELSE P := Q
      END
.fam T

The first case is interpreted as:

.fam C
       IF NOT B THEN GO TO L1;
       IF NOT X = 0 THEN GO TO L2;
       Y := X: GO TO L2;
   L1: P : = Q:
   L2:
.fam T

The second case is interpreted as:

.fam C
       IF NOT B THEN GOTO L2;
       IF NOT X = 0 THEN GOTO L1:
       Y := Z; GO TO L2:
   L1: P := Q:
   L2:
.fam T

ALGOL 60 forbids such ambiguities by forbidding the sequence 
 
.fam C
   THEN IF .... THEN .... ELSE;
.fam T

\fHtaxi\fR, in particular, stops execution if such a condition appears in the listing; if you need an \fCIF\fR after \fCTHEN\fR, enclose the \fCIF\fR into a \fCBEGIN-END\fR block:

.fam C
   IF .... THEN
        BEGIN
  	     IF ....
        END;
   ...
.fam T

.NH 2
.ds IND1110 \*[SN-NO-DOT]
DESIGNATIONAL EXPRESSIONS
.XS
\*(SN 			Designational expressions
.XE
.LP
A designational expression is something that acts as an argument in a \fCGOTO\fR statement, either directly, or indirectly via a formal procedure parameter of type label. This may simply be a label or a switch element. Thus the following are designational expressions:

.fam C
   L
   IF B THEN L1 ELSE L2
   IF X < 0 THEN SW[I] ELSE IF X+Y >= Z THEN TW[J] ELSE L
.fam T

These designational expressions would be used in the following manner:

.fam C
   GO TO L;
   GOTO IF B THEN L1 ELSE L2;
   GOTO IF X < 0 THEN SW[I] ELSE IF X+Y >= Z THEN TW[J] ELSE L;
.fam T
.bp
.NH 1
.ds IND1120 \*[SN-NO-DOT]
OWN VARIABLES AND ARRAYS
.XS
\*(SN 		\fBOwn variables and arrays\fR
.XE
.LP
.NH 2
.ds IND1130 \*[SN-NO-DOT]
GENERALITIES ABOUT OWN VARIABLES
.XS
\*(SN 			Generalities about \fCOWN\fR variables
.XE
.LP
\fCOWN\fR variables are a special kind of ALGOL variables and may be of type integer, real, long real, Boolean or string, either scalar or array.

The variables have the following properties:

.IP 1. 
Although following the normal scope rules, the variables are not recursive; they are the same copy of each variable that is being used in all occurrences of a procedure or block.

.IP 2. 
When control passes out of a block, the values are retained and are still available when the block is re-entered.

.IP 3. 
The initial value is set to zero before the execution of the program. (\fCFALSE\fR in the case of Boolean \fCOWN\fR variables). \fCOWN\fR strings are initialized to the empty string.
.LP

\fCOWN\fR variables are declared by writing the usual declaration with the word \fCOWN\fR preceding it. For example:

.fam C
   OWN INTEGER I,J,K;
   OWN REAL ARRAY THETA[l:M];
.fam T

.NH 2
.ds IND1140 \*[SN-NO-DOT]
OWN ARRAYS
.XS
\*(SN 			\fCOWN\fR arrays
.XE
.LP
\fCOWN\fR arrays are implemented in a completely dynamic fashion in \fHtaxi\fR ALGOL. The declaration proceeds according to the following rules.

.IP 1. 
If this is the first time the array is declared, space is obtained and then the array laid out. If the array has been laid out before, proceed to Step 2.

.IP 2. 
The bounds are examined to ensure that these are identical to the ones of the previous construction of this array and the array is left unaltered if found to be of the same dimension; otherwise, proceed to Step 3.

.IP 3. 
A new array is constructed and the common elements if any, are copied from the old array; the remaining elements are zeroed. The old array is then deleted and the allocated space is recovered for future use.
.LP

For example, if an \fCOWN\fR array \fCA\fR is declared as follows:

.fam C
  OWN REAL ARRAY A[l:M,M:N];
.fam T

where \fCM\fR is 2 and \fCN\fR is 5 the first time, and \fCM\fR is 1 and \fCN\fR is 4 the second time, the elements \fC[1,2]\fR, \fC[1,3]\fR and \fC[1,4]\fR are copied over, and the remaining elements of the new array are zeroed. The memory is copied as a whole, and the new array can have elements in different positions.

NOTES:
.IP - 
in the DEC system-10/20 ALGOL manual or the ISO 1538-1984, there is no mention of implicit real type in case of \fCOWN\fR variables if the type is not specified. But \fHtaxi\fR, as for the arrays, in case \fCOWN\fR is used alone, defaults to \fCOWN REAL\fR;

.IP - 
please note that declaring \fCOWN\fR variables in the main block (the most external block ending with \fCEND\fR plus dot) is useless, and is equivalent to a declaration without the \fCOWN\fR keyword.
.LP
.bp
.NH 1
.ds IND1150 \*[SN-NO-DOT]
DATA TRANSMISSION
.XS
\*(SN 		\fBData transmission\fR
.XE
.LP
.NH 2
.ds IND1160 \*[SN-NO-DOT]
GENERAL
.XS
\*(SN 			General
.XE
.LP
Data transmission encompasses the input and output of data between the user's program and the peripheral devices. (Originally they included disks, tapes with DEC formatting, magnetic tapes, card readers, card punches and line printers.)

\fHtaxi\fR provides the user with a default channel for input (channel zero) and a default channel for output (channel 1). These cannot be changed and are always active.

\fHtaxi\fR also provides the user with a set of pre-installed basic procedures for uniformly handling data. All available peripheral devices (at present \fCDSK\fR, \fCTTY\fR and \fCPRN/LPT/PLT\fR) and all file channels that \fHtaxi\fR can handle are under the user's control completely and can be allocated or released at any time throughout the execution of the program. The user can handle up to physical 14 devices simultaneously, numbered 2 to 15 (16 including devices 0 and 1).
.NH 2
.ds IND1170 \*[SN-NO-DOT]
ALLOCATION OF PERIPHERAL DEVICES
.XS
\*(SN 			Allocation of peripheral devices
.XE
.LP
Peripheral devices are allocated to the user's program by calls to the library procedures \fCINPUT\fR or \fCOUTPUT\fR. A call to one of these procedures usually has two parameters. The first is the channel number, an integer in the range 2 to 15, on which the device is to operate. Only one device at a time may be operated on a channel since a channel provides either input \fIor\fR output facilities. The second parameter is either a string or a string constant. The text contained in the string is the logical name of the device to be allocated to this channel.

NOTE: at present, only \fCTTY\fR and \fCDSK\fR can be used for input, and \fCTTY\fR as the monitor, \fCDSK\fR, \fCPRN/LPT/PLT\fR as a deferred printing can be used for output. The following Table 16-1 lists all devices:

.B1
.CD
Table 16-1
Standard Device Names

.DE
.fam C
.ps 9
   Device Name          Peripheral
.vs -3
 -----------------------------------------------------------------
   DSK                  Any disk mounted on the File System
.ps 8
                        
 NOTE: This device should be used even for external HD or USB keys, 
 or any other mountable directory-driven device, since they are 
 simple directories for a UNIX File System.

.ps 9               
   PRN - LPT - PLT      Line printer/Plotter
.ps 8

 NOTE: These devices identify current printer/plotter attached 
 to the machine. \fHtaxi\fR is unable at present to select a specific 
 printer. Printing is deferred until the end of the program or a 
 specific channel RELEASE, and printed afterwards; in the
 meantime data are stored into a temporary file.

.ps 9                
   TTY                  The terminal
.ps 8

 NOTE: This device means input governed by keyboard and output 
 directed to the monitor. Input from channel 0 and output to
 channel 1 are both protected; on channels 2\[di]15, instead, input OR 
 output can be done. 

.fam T
.B2
.LP

For example, to allocate the terminal for use as an input device on channel 5, the user would use the statement

.fam C
   INPUT(5, "TTY");
.fam T

or, if \fCR\fR were a string possessing a byte string that has the characters \fCTTY\fR (or \fCtty\fR) in it,
 
.fam C
   INPUT(5, R);
.fam T

NOTE: All devices are allocated to operate in one direction only; thus, if the user wants simultaneously to input and output from a device (included the terminal), two separate channels must be used.

NOTE: the \fCINPUT\fR and \fCOUTPUT\fR logical feature is provided. See the paragraph "LOGICAL INPUT/OUTPUT."
.NH 3
.ds IND1180 \*[SN-NO-DOT]
Device Modes
.XS
\*(SN 			Device Modes
.XE
.LP
NOTE: the third parameter (device modes) has no meaning here and, if used, it is simply ignored.
.NH 3
.ds IND1190 \*[SN-NO-DOT]
Buffering
.XS
\*(SN 			Buffering
.XE
.LP
NOTE: the fourth parameter (buffering type) has no meaning here and, if used, it is simply ignored. Buffering is left to the underlying UNIX Operating system.
.NH 3
.ds IND1200 \*[SN-NO-DOT]
Error Returns
.XS
\*(SN 			Error Returns
.XE
.LP
Normally, if the device allocation fails (for example if the device is in use by
another job), a suitable message is typed and the program terminated. The user can prevent this by providing, as the fifth parameter to \fCINPUT\fR or \fCOUTPUT\fR, a label to which control is to be passed in the event of an error. For example:

.fam C
   OUTPUT(14,"DSK",O,O,ERROR.LABEL);
.fam T

If the actual label parameter is a switch whose subscript is out of range, or it is an inexistent label, the procedures behave as though the label parameter were absent.

NOTE: The third and fourth parameters must be specified in this case. They are ignored anyway.
.NH 2
.ds IND1210 \*[SN-NO-DOT]
FILE DEVICES
.XS
\*(SN 			File devices
.XE
.LP
Being everything a file, all peripheral devices, such as disks or tapes, after being chosen as \fCINPUT/OUTPUT\fR with the \fCDSK\fR identifier, require the opening of a specifically named file before any input or output operations can be performed. The opening of this file is performed using the procedure \fCOPENFILE\fR, which is called after the device has been allocated to a channel. The procedure call has two main parameters:

.IP - 
the channel number on which the device has been allocated;

.IP - 
a string variable possessing a byte string or a string constant, the text of which is the name of the file.
.LP

The \fCDSK\fR device can be used for simultaneous input/output channels on several files on the File System.

The user can also specify a permission code and/or a flag for erasing the file once opened. For example, to open a file named \fC"TEST.DAT"\fR on channel 9 with permissions 744 and anew (owner read/write/execute and group/world read-only), the user could write

.fam C
   OPENFILE (9,"TEST.DAT",%744,N);
.fam T

The octal code specified as the permission code works according to the following table (UNIX permissions):

.fam C
        4000    set user id on execution
        2000    set group id on execution
        1000    save swapped text even after use
 
        0400    read for owner
        0200    write for owner
        0100    execute for owner
        
        0040    read for group
        0020    write for group
        0010    execute for group
 
        0004    read for world
        0002    write for world
        0001    execute for world
 
        0000    user usage
.fam T

For instance, to specify reading permission for all, and read/write permission for the user only, one could use \fC%644\fR as the permission code; of course, any integer can be used in this place, but the octal form (preceded by \fC%\fR) makes designing the permission code \fIas-is\fR. If a null value is passed, it is left to the shell umask code the task to define how files are created in the user directories.

The fourth argument is any number, whose integer part is taken: if null, the file is not erased, otherwise it is. For instance

.fam C
   OPENFILE(9,"TEST.DAT",0,1);
.fam T

creates file \fCTEST.DAT\fR in the current directory, with null permission codes, and erased before it is used.

NOTE: the file must exist when the \fCOPENFILE\fR procedure is called.

When operations on a file are over, the file should be closed. A file is closed by using the procedure \fCCLOSEFILE\fR, with a list of parameters, each being a channel number on which the file is open. Thus, 

.fam C
   CLOSEFILE(9);
.fam T

closes the file that is open on channel 9, whereas

.fam C
   CLOSEFILE (3,9);
.fam T

closes the files that are open on channel 3 and 9.

NOTE: when the program ends, \fHtaxi\fR as a safety measure, takes care of closing all files left opened. But it's, anyway, a good programming style closing a file after use.

The user can also rename or delete existing files: if a file is already open, use of \fCOPENFILE\fR causes the file to be renamed with the new name supplied. Thus the sequence

.fam C
   OPENFILE (5,"TESTl.DAT");
   OPENFILE (5,"TEST2.DAT");
.fam T

causes the file with name \fCTESTl.DAT\fR to be renamed \fCTEST2.DAT\fR. If the string containing the new name is null, the original file is erased. Thus,

.fam C
   OPENFILE (5,"TEST3.DAT");
   OPENFILE (5,"");
.fam T

causes the file \fCTEST3.DAT\fR to be erased. (The empty file remains in the file system, and should be deleted manually.)
.NH 3
.ds IND1220 \*[SN-NO-DOT]
Error Returns
.XS
\*(SN 			Error Returns
.XE
.LP
Normally, if the requested operations fail (for example an input file is not a regular file or it does not exist), a suitable message is typed and the program terminates. The user can prevent this by providing a label and an optional integer variable name as the fifth and sixth parameters to \fCOPENFILE\fR. In the event of an error, control will be passed to the label, with an error-code set into the integer variable if present.

.fam C
   INPUT(5,"DSK");
   INTEGER N;
   OPENFILE(5,"TEST.DAT",0,0,LAB1,N);
   ....
   LAB1: COMMENT ERROR-TREATMENT SECTION;
   IF N=44 THEN ....
.fam T

NOTES:
.IP -
The error-codes are those returned by option \fC--errors-list\fR.
.IP - 
The third and fourth parameters must be present if the error return parameter is specified. Defaults will be taken if both parameters are specified as zero.
.IP - 
If the actual label parameter is a switch whose subscript is out of range, an error message is printed and the program stops.
.LP

The error code variable can be used to check what kind of error occurred and take the appropriate action to avoid it repeats. The ISO 1538-1984 procedure \fCFAULT\fR is useful with this regard to print the associated error message. Make sure that the variable used in \fCOPENFILE\fR as the sixth parameter refers to a label currently in scope.
.NH 2
.ds IND1230 \*[SN-NO-DOT]
CREATING A NEW EMPTY FILE
.XS
\*(SN 			Creating a new empty file
.XE
.LP
The procedure \fCCREATEFILE\fR (not belonging to the original DEC system-10/20 ALGOL) was designed to enable the creation of a fresh new empty file on the file system. Since procedure \fCOPENFILE\fR acts only on existing files, provided they are previously created in the underlying Operating System or created empty during runtime before usage (for instance, before a \fCTRANSFER\fR). You can create the file by yourself, before executing the program or use \fCCREATEFILE\fR in the source.

The file name must be given along with the whole path. Example:

.fam C
   CREATEFILE("/path/to/file/name.XX");
.fam T

The procedure \fCCREATEFILE\fR is not associated with a channel. It acts on the \fCDSK\fR device, depending on current working directory and pathname. The file is created and closed, so no action is performed upon it. To use it as an output file, \fCOPENFILE\fR and \fCSELECTOUTPUT\fR (see next chapter) must be used to connect the newly created file to the program and select it as the output source.

NOTE: If the file should already exist, it is erased and retained empty. So watch out.
.NH 2
.ds IND1240 \*[SN-NO-DOT]
SELECTING INPUT/OUTPUT CHANNELS
.XS
\*(SN 			Selecting input/output channels
.XE
.LP
Before a user uses a device to transfer data, assuming that the device has already been allocated to some channel (or the file has already been opened), the appropriate input or output channel must be "selected" for use as the input or output channel. All data input and output always occurs on the currently selected input channel and output channel, respectively. The user may change the selection of channels at any time, switching from one channel to another without loss of data, irrespective of whether complete lines (or records) of data have been read or not. \fHtaxi\fR does not assume any structure in the data: all input and output channels are regarded as pipelines through which the user pulls or pushes data.

To select an input channel, a call to the procedure \fCSELECTINPUT\fR must be made. This has one parameter, which is the channel number. Thus 

.fam C
   SELECTINPUT(5);
.fam T

causes input channel 5 to be selected.

Similarly, the procedure \fCSELECTOUTPUT\fR is used to select an output channel.

.fam C
   SELECTOUTPUT(6);
.fam T

NOTE: \fCSELECTOUTPUT\fR opens the file always in append mode (that is, the writing begins at the end of the existing data). To ensure rewriting all, use the erase feature of \fCOPENFILE\fR. (See FILE DEVICES.)
.NH 2
.ds IND1250 \*[SN-NO-DOT]
RELEASING DEVICES
.XS
\*(SN 			Releasing devices
.XE
.LP
The procedure \fCRELEASE\fR, with a list of parameters, each being a channel number, is used to release a device from a channel. Thus,

.fam C
   RELEASE(5);
.fam T

releases the device or file allocated to channel 5, whereas

.fam C
   RELEASE(3,7);
.fam T

releases the devices or files allocated to channels 3 and 7.

NOTE: the multiple argument feature was not on the DEC system-10/20 ALGOL.

NOTE: In case of files (\fCDSK\fR devices), \fCRELEASE\fR must be used only referencing to channels already closed with \fCCLOSEFILE\fR (or never opened with \fCOPENFILE\fR). Moreover, \fCRELEASE\fR won't act on channels 0 and 1, which cannot be released.

If a user terminates his program without releasing used channel devices, these are automatically released and all file closed by \fHtaxi\fR when the program terminates.

The procedure \fCRELEASE\fR can also close the channel associated to a string (logical device); e.g the syntax:

.fam C
   RELEASE(26);
.fam T

cause the string, that it was connected to as an input/output channel through \fCINPUT\fR or \fCOUTPUT\fR, to be detached from the channel; the string is not altered anyway.
.NH 2
.ds IND1260 \*[SN-NO-DOT]
BASIC INPUT/OUTPUT PROCEDURES
.XS
\*(SN 			Basic input/output procedures
.XE
.LP
.NH 3
.ds IND1270 \*[SN-NO-DOT]
Byte Processing Procedures
.XS
\*(SN 			Byte Processing Procedures
.XE
.LP
The following the DEC system-10/20 ALGOL procedures may be used with any device to handle 8-bits bytes, normally used with devices supplying or accepting ASCII bytes (and thus called "symbols").

.IP 1. 
\fCINSYMBOL(S);\fR - (where \fCS\fR is usually some integer variable) causes the next byte to be read from the currently selected input channel and stored in \fCS\fR.

.IP 2. 
\fCOUTSYMBOL(J);\fR - (where \fCJ\fR is usually some integer expression) causes the value of \fCJ\fR to be output as a byte to the currently selected output channel. If \fCJ\fR is too large for the byte size of the device in use, it is truncated to the byte size.

.IP 3. 
\fCNEXTSYMBOL(S);\fR - acts in the same way as \fCINSYMBOL()\fR except that the byte pointer for the input channel is not advanced to the next available byte. This gives the user a look-ahead facility of one byte.

.IP 4. 
\fCSKIPSYMBOL;\fR - causes the next byte from the selected input channel to be read and ignored.

.IP 5. 
\fCBREAKOUTPUT;\fR - causes all bytes in the buffer of a file output device to be sent immediately to it. This ensures the file buffer is emptied before eventually setting it for input.
.LP
 
See also chapter 18.8 about the two different philosophies behind the DEC system-10/20 ALGOL and ISO 1538-1984 documents.
.NH 3
.ds IND1290 \*[SN-NO-DOT]
Miscellaneous Symbol Procedures
.XS
\*(SN 			Miscellaneous Symbol Procedures
.XE
.LP
The procedures \fCSPACE\fR, \fCTAB\fR, \fCPAGE\fR, and \fCNEWLINE\fR cause the appropriate number of spaces, tabs, page throws, or new lines to be output. This number is specified by a single integer parameter. If the parameter is omitted a value of one is assumed. Thus 

.fam C
   SPACE(5);
.fam T

causes five spaces to be output, whereas

.fam C
   SPACE;
.fam T
or

.fam C
   SPACE(l);
.fam T

cause one space to be output.

NOTES:
- \fCNEWLINE\fR is ignored if current \fCOUTPUT\fR is a logical channel. (See 16.8.)
.br
- \fCPAGE\fR currently clears the screen of the monitor output. It is without effect on files.
.NH 3
.ds IND1300 \*[SN-NO-DOT]
Numeric and String Procedures
.XS
\*(SN 			Numeric and String Procedures
.XE
.LP
Numeric procedures are used to read and print numeric quantities. The procedures will normally be used with a device that is operating in ASCII mode, and are capable of processing integer, real, or long real quantities in fixed-point and floating-point representation.
.NH 4
.ds IND1310 \*[SN-NO-DOT]
Numeric and String Input
.XS
\*(SN 				Numeric and String Input
.XE
.LP
Numeric data for input can be represented in any format that would be acceptable as a numeric constant in a program, irrespective of the type of variable involved. When a number is read, automatic type conversion is performed, giving a result of the same type as if an assignment of the data represented as a constant in the program had been executed.

There is a minor restriction in that no spaces, tabs, or other non-printing symbols may appear in such numeric data. Otherwise, any symbol that is not a part of a numeric quantity may act as a terminator for such a quantity. It is strongly recommended that spaces, tabs, commas or new lines be used as separators.

For example:

.fam C
   3.4   -9.6   1.36   -52
 
   0,     14.9
.fam T

NOTE: In reading a numeric quantity, the terminating symbol, that is the first 
symbol that is not part of the number, is lost.

\fHtaxi\fR also allows the user to input floating-point data written in FORTRAN format, that is using \fCE\fR for \fC&\fR or \fC\@\fR, and \fCD\fR for \fC&&\fR or \fC\@\@\fR. However, since numbers are stored in fixed memory space, this is of little importance for what about the input phase and is only meaningful in output, where the type of the variable influences the number picture.

The procedure \fCREAD\fR is used to input numeric data and also strings. This procedure may have any number of parameters (up to the end of a physical program line), of type integer, real, long real, Boolean, string or label.

The effect is as follows:
 
.IP 1. 
For integer, real and long real variables, a number is read and converted to the type appropriate to the parameter and then assigned to the variable.

.IP 2. 
For Boolean, a number is read as if for an integer variable and assigned to the variable.

.IP 3. 
For a string or label variable, the data text is scanned until a quote (\fC"\fR) or (\fC''\fR) is found, and the text following this up to but not including the next free quote is read in and a byte string is generated, which is then possessed by the string or label variable.
.LP

If the sequence \fC""\fR is found inside the string, a single \fC"\fR is stored, and reading of the string continues. Of course \fC""\fR indicates, per se, the empty string.
.NH 4
.ds IND1320 \*[SN-NO-DOT]
Numeric Output
.XS
\*(SN 				Numeric Output
.XE
.LP
Numeric data is output using the procedure \fCPRINT\fR. This procedure may have one, two, or three parameters, the first of which is the variable to be printed. This variable may be a Boolean, integer, real, or long real. A pure literal number (having or not the decimal point) is always interpreted as real. The second and third parameters determine the format to be used and are integer expressions. If omitted, both parameters are assumed to be zero. The effect of the various combinations of the format integers, \fCM\fR and \fCN\fR, is as follows:

.fam C
    M>O, N>O:        Fixed-point printing, M places before the decimal
                     point, N places after. A sign, space if positive,
                     dash if negative appears before the number. Zeros
                     before the decimal point (unless the rightmost) 
                     are replaced by spaces and the sign moved up to 
                     the number. A space character appears after the 
                     last digit.

                     This format always outputs M+N+3 symbols. Example:
 
 PRINT(3,3,3);PRINT(3.2,3,3);PRINT(0.00003,3,3);

    3.000    3.200    0.000

    M>O, N=O:        The same as the preceding except that (1) no
                     fractional part appears, and (2) the decimal point
                     is suppressed.

                     This format always outputs M+l symbols. Example:
 
 PRINT(3,3,0);PRINT(3.2,3,0);PRINT(0.00003,3,0);

    3    3    0   
.fam T

Please note the third number, basing on the preceding laws, is printed as zero.

.fam C
    M=O, N>O:        Floating-point format, consisting of a sign, a
                     decimal digit, a decimal point, N more decimal
                     digits, an exponent consisting of & for real,
                     && for long real followed by the exponent sign and
                     an exponent, zero suppressed from the left with
                     1 to 3 digits and a final space after the last.
                     (Note: the exponent sign is always printed.)

                     This format outputs at most N+8 characters for 
                     real and N+9 for long real quantities.

                     NOTE: the exponent character & in the number
                     picturing can be changed by means of option
                     --exp=C, where C is the chosen character between
                     E, & and \@. Example:

 PRINT(3,0,3);PRINT(3.2,0,3);PRINT(0.00003,0,3);

  3.000&+0  3.200&+0  3.000&-5
.fam T

If only two parameters appear, format \fCM,0\fR is assumed for integer variables, and format \fC0,N\fR for real and long real quantities, where \fCM\fR and \fCN\fR take, respectively, the value of the second parameter. Example:

.fam C
 PRINT(3,3);PRINT(3.2,3);PRINT(0.00003,3);
 
   3.000&+0  3.200&+0  3.000&-5
.fam T

If only one parameter appears, the format is interpreted as \fC0,0\fR which assumes standard printing modes of \fC11,0\fR for integer quantities, \fC0,9\fR for real quantities, and \fC0,17\fR for long real quantities. Example:

.fam C
 PRINT(3);PRINT(3.2);PRINT(0.00003);
 
  3.000000000&+0  3.200000000&+0  3.000000000&-5
.fam T

If the user should request more digits to be printed than those significant in real or long real numbers, the appropriate number of zeros follow a properly-rounded print of the number to the maximum precision available, with possible garbage digits at the end of the decimal scale.

The \fCPRINTLN\fR procedure works exactly as the \fCPRINT\fR statement, but outputs a Carriage Return after the number. This procedure was not in the DEC system-10/20 ALGOL but comes in handy when you want to avoid all the \fCNEWLINE\fR statements needed to go to the next line.
.NH 4
.ds IND1330 \*[SN-NO-DOT]
String Output
.XS
\*(SN 				String Output
.XE
.LP
A byte string may have its contents transferred to the currently selected output channel using the procedure \fCWRITE\fR, whose single parameter is either a string constant or a string variable containing the string to be output. For example:

.fam C
   WRITE(S);
.fam T

or

.fam C
   WRITE ("THE MOON IS MADE OF GREEN CHEESE");
.fam T

With exceptions explained in the following paragraphs, all of the bytes in the string are output literally, retaining the upper and lower format.

NOTE: Unlike some other ALGOL implementations, spaces and other non-printing symbols in byte strings are meaningful in \fHtaxi\fR.

Special editing characters are permitted within square brackets within the text of a byte string. These have a special function: 

.fam C
    P         Page throw

    C or N    Newline (C stands for carriage return, line feed)

    T         Tab

    S         Space

    B         Break output
.fam T

Any combination of these characters, with optional preceding repetition counts, can appear within square brackets in a byte string and are output as their special interpretation demands. For example:

.fam C
   WRITE("ABCD[P2C5S]EFGH");
.fam T

causes the following to be output:

.IP 1. 
the symbols \fCABCD\fR 
     
.IP 2. 
one-page throw, two new lines and five spaces

.IP 3. 
the symbols \fCEFGH\fR.
.LP

That is:

.fam C
    ABCD
 
         EFGH
.fam T

To output the symbols

.fam C
   [ ] " or ; 
.fam T

these must appear in the form

.fam C
   [[ ]] "" or ;;
.fam T

respectively. Thus

.fam C
   WRITE(''""A[[I]] := 3;;""'');
.fam T

causes the text

.fam C
   "A[I] := 3;"
.fam T

to be output. In the string, the double-single quote delimiting characters were used to help distinguished inner quotes from outer quotes. The inverse (and equivalent) is:

.fam C
   WRITE("''A[[I]] := 3;;''");
.fam T

which outputs the following

.fam C
   ''A[I] := 3;''
.fam T

Please note that the single quote represents itself, and need not be doubled. 

The \fCWRITELN\fR procedure works exactly as the \fCWRITE\fR statement but outputs a Carriage Return after the number. This procedure was not in the DEC system-10/20 ALGOL but comes in handy when you want to avoid all the \fCNEWLINE\fR statements or the \fC[C]\fR inner printing codes needed to go to the next line. This may not portable, though.
.NH 4
.ds IND1340 \*[SN-NO-DOT]
Octal Input/Output
.XS
\*(SN 				Octal Input/Output
.XE
.LP
The procedures \fCREADOCTAL\fR and \fCPRINTOCTAL\fR, respectively, allow the user to input and output quantities written/typed in octal format.

On input, for single precision variables, up to 11 octal digits are read, preceded by the symbol \fC%\fR, the terminator being any non-numeric symbol in the range \fC0-7\fR. For long real variables, two such octal numbers must be presented for input, the first preceded by the symbol \fC%\fR and the second optionally preceded by the symbol \fC%\fR.
 
On output, 11 octal digits, preceded by the symbol \fC%\fR, are printed for single precision variables. For long real variables, two quantities each with 11 octal digits globally preceded by the symbol \fC%\fR are printed, separated by a space. The output is followed by a terminator (the space character).

The \fCPRINTOCTAL\fR procedure has one variable parameter which may be of type integer, real, long real or Boolean. The \fCREADOCTAL\fR procedure may have any number of variables, separated by a comma (as for \fCREAD\fR, see).

For instance, the program 

.fam C
 BEGIN
 	LONG REAL A,B;
 	A:=23455;
 	PRINTOCTAL(A); NEWLINE;
 	PRINTLN(A);
 	WRITE("ENTER AN OCTAL NUMBER: ");
 	READOCTAL(B);
 	PRINTOCTAL(B); NEWLINE;
 	PRINTLN(B);
 END.	
.fam T

produces the following output

.fam C
  %00000000000 00000055637
  2.34550000000000036&&+4
 ENTER AN OCTAL NUMBER: %00000000000 00000055637       
  %00000000000 00000055637
  2.34550000000000036&&+4
.fam T

(This example supposes to re-enter, at the \fCREADOCTAL\fR request, the very same number previously printed by \fCPRINTOCTAL\fR.)
.NH 4
.ds IND1350 \*[SN-NO-DOT]
Array input/output
.XS
\*(SN 				Array input/output
.XE
.LP
Following what Heinz Rutishaser suggests in his 1970 introduction to Algol, I added to \fHtaxi\fR the two array procedures \fCINARRAY\fR and \fCOUTARRAY\fR, according to the ISO style. These procedures work with numeric and string arrays. 

.fam C
 INARRAY(ch,ar);
.fam T

The previous procedure causes the array \fCar\fR to be filled with values coming from the input channel \fCch\fR. The array \fCar\fR may be:

.IP *
a Boolean array, in which cases values are converted to zeros or ones.
.IP *
an integer array, in which cases values are cut to integers.
.IP *
a real array or a long real array, in which case the complete values are retained.
.LP

While evaluating numbers from the channel \fCch\fR, \fCINARRAY\fR considers as a literal number any sequence of characters in the form:

.fam C
 SNNN[.NNN[SCNN]]
.fam T

where \fCS\fR is the sign '\fC-\fR' or '\fC+\fR' (the latter being optional), \fCN\fR is any digit 0..9, the dot separates the integer part from the fractional part (the latter two being optional), \fCC\fR is the exponential character '\fC&\fR', '\fC\@\fR' or '\fCE\fR'; '\fCD\fR' is also accepted because of the Fortran double-precision format. The number must begin with a sign, a digit, a dot or the '\fC&\fR' or '\fC\@\fR' characters. ('\fCE\fR' and '\fCD\fR' are not available as starters.) The exponential group \fCSCNN\fR must be given as a whole (the sign \fCS\fR being optional). Expressions are not evaluated.

Any sequence of alphabetic or punctuation characters that does not start a valid numeric sequence is read and discarded. In particular, stating on the previous rules, a sequence like \fCE4\fR (which could be interpreted as \fC1*10^4\fR=\fC10000\fR) is equivalent to \fC4\fR, because the character \fCE\fR is read and discarded; analogously, the expression \fCSQR(3)\fR is equivalent to \fC3\fR because \fCSQR(\fR and \fC)\fR are read and discarded.

.fam C
 OUTARRAY(ch,ar[,width]);
.fam T

The previous procedure causes the array \fCar\fR to be printed on the screen to channel \fCch\fR, regardless of the number type; in case the number cannot be represented in floating-point format, it is printed in exponential form (in this case, the figure \fCSCNN\fR is included in the printable width). The third optional parameter is an integer expression that by default is 12 characters, that includes the sign (1 character), the integer part (variable), the dot (1), the decimal part (variable), the exponential (4, where needed) and a final space (1). This number can be used to size the output precision and alignment, extending or reducing the precision to the desired depth, with the following set:

 \fCwidth<4      \fR only the integer part is printed
 \fCwidth=5      \fR the integer part plus 1 decimal are printed
 \fCwidth=6      \fR the integer part plus 2 decimals are printed
 and so on...

Please note that stating on the previous rules, long real arrays are not printed using their proper type-precision (as it would with \fCPRINT\fR or \fCOUTLONGREAL\fR), but using appropriately the \fCwidth\fR parameter. 

Arrays are printed with one blank line preceding and one blank line following; the printing rules follow their dimensions:

.IP *
if the dimension is 1, the array is a vector and is printed vertically.
.IP *
if the dimension is 2, the array is a matrix and is printed in a rectangle.
.IP *
if the dimension is N > 2, the array is printed in a series of consecutive matrices. It's the user responsibility to separate the output.
.NH 2
.ds IND1360 \*[SN-NO-DOT]
SETTING DEFAULT INPUT/OUTPUT
.XS
\*(SN 			Setting default input/output
.XE
.LP
If the user does not select any input or output channels, input and output occur via channel 0 from the keyboard (input) and 1 to the user's terminal (output). Thus, for simple programs where the user wishes to input a few numbers and print a few results, he simply uses \fCREAD\fR, types in the data online through his terminal, and gets back the results from \fCPRINT\fR.
.NH 2
.ds IND1370 \*[SN-NO-DOT]
SETTING LOGICAL INPUT/OUTPUT
.XS
\*(SN 			Setting logical input/output
.XE
.LP
In addition to the 14+2 channels used to communicate with peripheral devices, san additional 16 channels, numbered from 16 to 31, are provided. These are input or output channels that use byte strings as a means of storage.

Using the procedures \fCINPUT\fR or \fCOUTPUT\fR, the user can attach a channel to a byte string possessed by a string variable, and can read and write bytes from and to this byte string, either to and from a peripheral device or to and from another byte string. 

.fam C
   INPUT(20,S) ;
.fam T

or

.fam C
   OUTPUT(20,S) ;
.fam T

cause the byte string possessed by the string variable \fCS\fR to be used as logical channel 20; this channel may subsequently be selected for input or output, as appropriate.

The user is still free, of course, to manipulate the individual bytes within the byte string utilizing the byte-subscription facilities available. Such facilities enable the user to read a file from a peripheral device into a string, process it in any way whatsoever, and output it again.

NOTE: when the \fCINPUT\fR or \fCOUTPUT\fR process of reading-from/writing-to a string reaches the string limit space, the buffer pointer is reset, causing the string to be re-read or re-written. If you try to print a string longer than the remaining space (starting the count from the buffer pointer to the string limit), only the part that fits is copied, the buffer pointer is reset and the rest is copied with the same cautions. Take it in account when you work with logical devices, and assure you have sufficient space on the string (if in case use \fCNEWSTRING\fR. See 13.7.4).
.NH 2
.ds IND1380 \*[SN-NO-DOT]
I/O CHANNEL STATUS
.XS
\*(SN 		I/O channel status
.XE
.LP
The status of any input or output channel can be determined at any time using the Boolean procedure \fCIOCHAN\fR, which takes an integer channel number as the parameter. The status returned is bit coded as in Table 16-2:

.B1
.CD
Table 16-2
I/O Channel Bit Status

.DE 
.fam C
  Bit      Value        Meaning if Set
.ps 9
.vs -3
 -----------------------------------------------------------------
  18       %400000      Device is physical (i.e., not logical)
  
  17       %200000      Directory device (unused)
  
  16       %100000      Terminal device
  
  15       %040000      ASCII mode (always set, unmodifiable)
  
  14       %020000      Magnetic tape (unused)
  
  13       %010000      Plotter/Printer
  
  12       %004000      Set for default TTY on channel 0
  
  11       %002000      Device is spooled (always set, unmodifiable)
  
  10       %001000      Device can do input
  
   9       %000400      Device is initialized for input
   
   8       %000200      File is open for input
   
   7       %000100      End of file encountered
   
   6       %000040      Input status OK
   
   5       %000020      Device can do output
   
   4       %000010      Device is initialized for output
   
   3       %000004      File is open for output
   
   2       %000002      Device quota exceeded (unused)
   
   1       %000001      Output status OK

.fam T
.B2
.LP

Some of these bits are of little or no use to the programmer, but, for example, if a channel connection is established, and the programmer does not know whether or not the device is ready for input or output, \fCIOCHAN\fR can be used to determine this.

The following example shows how the user can handle an unknown device whose name is given to the program via the user's terminal, and print the first line of the textual file if it's available:

.fam C
 BEGIN
     STRING DEVICE, FILE, ALINE; INTEGER CHANNEL;

     WRITE ("CHANNEL NO: "); BREAK.OUTPUT;
     READ (CHANNEL);
     
     WRITE ("[C]DEVICE NAME: "); BREAK.OUTPUT;
     READ (DEVICE);
     
     INPUT (CHANNEL, DEVICE);
     IF IOCHAN (CHANNEL) AND %200000 THEN BEGIN
           WRITE (" [C]FILE NAME: "); BREAK.OUTPUT;
  	   READ (FILE);
  	   
	   OPENFILE (CHANNEL, FILE);
           SELECTINPUT(CHANNEL);
           
	   COMMENT READ & WRITE THE FIRST LINE OF FILE;
           READ(ALINE);	WRITELN(ALINE);
           CLOSEFILE(CHANNEL);

     END
     RELEASE(CHANNEL);
 END.
.fam T

NOTE: When using Boolean expressions involving \fCIOCHAN\fR, the rules for evaluation in this implementation should be kept in mind. See section 5.2.

NOTE: An end-of-file on input is, at present, considered only for the \fCDSK\fR device. The EOF flag is set when reading from a text file has reached and passed the last character. The \fCTTY\fR does not check for end-of-file on input.

NOTE: An end-of-file on output is at present ignored. \fHtaxi\fR does not control the exceeding of a disk quota with files, or the exceeding of the disk memory, because this is left to the hosting Operating System. In this case, appearing error messages depend on the file system. 

NOTE: In case of logical devices, there is no end-of-file, neither in input nor output; when the end of the string is reached, the string pointer is reset to the start of the string, and the reading or writing can go on, in a circular model. This is a minor deviation from the DEC system-10/20 ALGOL behaviour.
.NH 2
.ds IND1390 \*[SN-NO-DOT]
TRANSFERRING FILES
.XS
\*(SN 		Transferring files
.XE
.LP
Once devices have been allocated to an input and an output channel, a complete file of information may be transferred between them automatically by calling the parameterless procedure \fCTRANSFILE\fR. This procedure copies bytes from one device to another from the currently selected input channel to the currently selected output channel, until an end-of-file status is raised on either the input or output channel.

NOTE: 
\- in \fCINPUT\fR, this procedure works only for channel 0 and channels in the range 2-15 (i.e. not for \fCTTY\fR channels nor for logical channels).
\- in \fCOUTPUT\fR, this procedure works only for channels in the range 1-15 (i.e. not for logical channels).

Example:

.fam C
 COMMENT: THIS PROGRAM COPIES ONE FILE TO ANOTHER;
 BEGIN
     INPUT(3,"DSK"); 
     OPEN.FILE(3,"from.dat");
     SELECT.INPUT(3);
     OUTPUT(7,"DSK");
     COMMENT: CREATE A VOID FILE;
     CREATE.FILE("to.dat"); 
     OPEN.FILE(7,"to.dat");
     SELECT.OUTPUT(7);
     TRANSFILE;
     CLOSE.FILE(3,7);
 END.
.fam T
.NH 2
.ds IND1400 \*[SN-NO-DOT]
CURRENTLY SELECTED CHANNEL NUMBERS
.XS
\*(SN 		Currently selected channel numbers
.XE
.LP
The number of the channel currently selected for input or output may be obtained by use of the integer parameterless procedures \fCINCHAN\fR or \fCOUTCHAN\fR.

E.g.

.fam C
     WRITE("CHANNEL OF INPUT =");PRINT(INCHAN);NEWLINE;
     WRITE("CHANNEL OF OUTPUT=");PRINT(OUTCHAN);NEWLINE;
.fam T
.bp
.NH 1
.ds IND1410 \*[SN-NO-DOT]
THE OPERATING ENVIRONMENT
.XS
\*(SN 		\fBThe operating environment\fR
.XE
.LP
\fHtaxi\fR has all the procedures enlisted in the operating environment of DEC system-10/20 ALGOL and the ISO 1538-1984 documents. 

In the following, they are grouped in the same sub-chapters of the DEC system-10/20 ALGOL user manual. 
.NH 2
.ds IND1420 \*[SN-NO-DOT]
MATHEMATICAL PROCEDURES
.XS
\*(SN 			Mathematical procedures
.XE
.LP
Undoubtedly, ALGOL is a math-driven language. Its power as an algorithm-maker is shown by the Algol Bulletin, that was published from March 1959 to August 1988. The algorithms presented in the Algol bulletin prove that ALGOL had a great impact on the scientific and mathematical world, because of its structured programming.

So, I extended \fHtaxi\fR mathematical abilities, freeing the programmer from designing common useful math functions, without wasting time for designing them.

The following procedures in general expect one real numeric argument and yield a real numeric result. If a literal numeric value or mathematical expression is given as argument, it is interpreted (or converted) to a real number. All trigonometric functions work with radians. The function \fCINTEGRAL\fR is more complex and follows its own rules.

.KS
   \fCABS\fR (Absolute value)
   @Domain:~~x~~\[mo]~~\[Re]#
   @Range:~~~~y~~\[mo]~~\[Re]~~|~~y~~\[>=]~~0#
.KE

.KS
   \fCARCCOS\fR (Arc cosine)
   @Domain:~~x~~\[mo]~~\[Re]~~|~~-1~~\[<=]~~x~~\[<=]~~1#
   @Range:~~~~y~~\[mo]~~\[Re]~~|~~0~~\[<=]~~y~~<~~\[*p]#
.KE

.KS
   \fCARCCOSEC\fR (Arc cosecant)
   @Domain:~~x~~\[mo]~~\[Re]~~|~~x~~\[<=]~~-1~~\[ca]~~x~~\[>=]~~1#
   @Range:~~~~y~~\[mo]~~\[Re]~~|~~-\[*p]~/~2~~<~~y~~<~~\[*p]~/~2#
.KE

.KS
   \fCARCCOSECH\fR (Arc hyperbolic cosecant)
   @Domain:~~x~~\[mo]~~\[Re]~~|~~x~~\[!=]~~0#
   @Range:~~~~y~~\[mo]~~\[Re]~~|~~y~~\[!=]~~0# 
.KE
   
.KS
   \fCARCCOSH\fR (Arc hyperbolic cosine)
   @Domain:~~x~~\[mo]~~\[Re]~~|~~x~~\[>=]~~1#
   @Range:~~~~y~~\[mo]~~\[Re]~~|~~y~~\[>=]~~0#
.KE
   
.KS
   \fCARCCOTAN\fR (Arc cotangent)
   @Domain:~~x~~\[mo]~~\[Re]#
   @Range:~~~~y~~\[mo]~~\[Re]~~|~~-\[*p]~/~2~~<~~y~~\[<=]~~\[*p]~/~2#
.KE
   
.KS
   \fCARCCOTANH\fR (Arc hyperbolic cotangent)
   @Domain:~~x~~\[mo]~~\[Re]~~|~~-1~~\[<=]~~x~~\[<=]~~1#
   @Range:~~~~y~~\[mo]~~\[Re]#
.KE
   
.KS
   \fCARCSEC\fR (Arc secant)
   @Domain:~~x~~\[mo]~~\[Re]~~|~~x~~\[<=]~~-1~~\[ca]~~x~~\[>=]~~1#
   @Range:~~~~y~~\[mo]~~\[Re]~~|~~0~~\[<=]~~y~~<~~\[*p]#
.KE
   
.KS
   \fCARCSECH\fR (Arc hyperbolic secant)
   @Domain:~~x~~\[mo]~~\[Re]~~|~~0~~<~~x~~\[<=]~~1#
   @Range:~~~~y~~\[mo]~~\[Re]~~|~~y~~\[>=]~~0#
.KE
   
.KS
   \fCARCSIN\fR (Arcsine)
   @Domain:~~x~~\[mo]~~\[Re]~~|~~-1~~\[<=]~~x~~\[<=]~~1#
   @Range:~~~~y~~\[mo]~~\[Re]~~|~~-\[*p]~/~2~~<~~y~~<~~\[*p]~/~2#
.KE
   
.KS
   \fCARCSINH\fR (Arc hyperbolic sine)
   @Domain:~~x~~\[mo]~~\[Re]#
   @Range:~~~~y~~\[mo]~~\[Re]#
.KE
   
.KS
   \fCARCTAN\fR (Arctangent)
   @Domain:~~x~~\[mo]~~\[Re]#
   @Range:~~~~y~~\[mo]~~\[Re]~~|~~-\[*p]~~\[<=]~~y~~\[<=]~~\[*p]#
.KE

.KS
   \fCARCTANH\fR (Arc hyperbolic tangent)
   @Domain:~~x~~\[mo]~~\[Re]~~|~~-1~~\[<=]~~x~~\[<=]~~1#
   @Range:~~~~y~~\[mo]~~\[Re]#
.KE

.KS
   \fCCOS\fR (Cosine)
   @Domain:~~x~~\[mo]~~\[Re]#
   @Range:~~~~y~~\[mo]~~\[Re]~~|~~-1~~\[<=]~~y~~\[<=]~~1#
.KE

.KS
   \fCCOSH\fR (Hyperbolic Cosine)
   @Domain:~~x~~\[mo]~~\[Re]#
   @Range:~~~~y~~\[mo]~~\[Re]~~|~~y~~\[>=]~~1#
.KE
   
.KS
   \fCCOSEC\fR (Cosecant)
   @Domain:~~x~~\[mo]~~\[Re]#
   @Range:~~~~y~~\[mo]~~\[Re]~~|~~y~~\[<=]~~-1~~\[ca]~~y~~\[>=]~~1#
.KE
   
.KS
   \fCCOSECH\fR (Hyperbolic cosecant)
   @Domain:~~x~~\[mo]~~\[Re]~~|~~x~~\[!=]~~0#
   @Range:~~~~y~~\[mo]~~\[Re]~~|~~y~~\[!=]~~0# 
.KE
   
.KS
   \fCCOTAN\fR (Cotangent)
   @Domain:~~x~~\[mo]~~\[Re]~~|~~\[*p]~~<~~x~~<~~0#
   @Range:~~~~y~~\[mo]~~\[Re]#
.KE
   
.KS
   \fCCOTANH\fR (Hyperbolic cotangent)
   @Domain:~~x~~\[mo]~~\[Re]~~|~~x~~\[!=]~~0#
   @Range:~~~~y~~\[mo]~~\[Re]~~|~~y~~<~~-1~~\[ca]~~y~~>~~1#
.KE

.KS
   \fCENTIER\fR (Largest non-exceeding integer)
   @Domain:~~x~~\[mo]~~N#
   @Range:~~~~y~~\[mo]~~N#
.KE

.KS
   \fCERF\fR (Error function)
   It is defined as
.EQ
\fCERF(x) \fR= erf(x) = 2 over sqrt pi int from 0 to x e sup (-t*t) dt
.EN
   @Domain:~~x~~\[mo]~~\[Re]+~~|~~x~~>~~0#
   @Range:~~~~y~~\[mo]~~\[Re]~~|~~0~~<~~y~~< 1.0# 
.KE

.KS
   \fCEXP\fR (Exponential function)
   @Domain:~~x~~\[mo]~~\[Re]#
   @Range:~~~~y~~\[mo]~~\[Re]~~|~~y~~\[>=]~~0#
.KE

.KS
   \fCGAMMA\fR (Gamma function)
   It is defined as
.EQ
\fCGAMMA(t) \fR= \[*G](t) = int from 0 to inf x sup { t - 1 } e sup {-x} dx
.EN
   @Domain:~~x~~\[mo]~~\[Re]~~|~~x~~\[!=]~~-k,~~k~~\[mo]~~N~~|~~k~~\[>=]~~0#
   @Domain:~~t~~\[mo]~~\[Re]~~|~~t~~> 0#
   @Range:~~~~y~~\[mo]~~\[Re]#
.KE

   \fCINTEGRAL\fR (Finite Integral)
   It is defined as
.EQ
\fC"INTEGRAL(\"f(x)\",a,b,x [,n])"\fR~~~=~~~int from a to b { f(x) dx }
.EN
   @Domain:~~x~~\[mo]~~\[Re]~~(range~~depends~~on~~the~~expression)#
   @Domain:~~y~~\[mo]~~\[Re]~~(range~~depends~~on~~the~~expression)#

The function @~f(x)~# is any mathematical ALGOL expression in the form of a string, with the integration variable occurring in it (otherwise it is a constant integration). The function must be continuous in the integration interval. The variable of integration must exist. Any other variables occurring in the expression stand for themselves and act as constants. The integration variable is written in naked form, as a proper variable name. The value of \fIn\fR, which is optional, specifies the number of subdivisions expressed as power to 10. If not given, the value 5 is set as default (that is, @~10 sup 5 = 100'000~# subdivisions), which bears at least 8 precise and fast decimal digits\*[*]. All arguments are passed by value, except the integration variable, which is passed by name, and retains the value of the last computed abscissa at the end of the calculation. 
.FS
Warning: subdivisions indices higher than 7 increase considerably the computation time without increasing correspondingly the precision. (The more sums, the more round-off errors). Roughly, 5 means at least 8 fast precise decimals, 6 means at least 9 precise decimals (using more time), while 7 means at least 10 precise decimals (using a lot of time). The value 8 yields at least 11 precise decimals (which is good) but with unbearably long computation time.
.FE

The solution is searched using the \fIiterated rule\fR, which tries to solve, in place of the exact solution, the approximate solution:
.EQ
int from a to b { f(x)~dx } approx { b - a } over n left ( f(a) over 2 + sum from k=1 to n-1 f left ( a + k { b - a } over n right ) + f(b) over 2 right )
.EN

In the directory \fCfiles/\fR of the installation folder of \fHtaxi\fR you can find the program \fCelli.alg\fR, that calculates an elliptic integral of the first kind, the file \fCintegral.alg\fR, that calculates a polynomial integral, and the file \fCsinint.alg\fR that calculates a sinusoidal integral. 

If \fCINTEGRAL\fR is used into a procedure, and the integration variable is passed by name into the procedure, it is \fBthis\fR variable inside the procedure that must appear in the integration function. For an example, see the program \fCintegral_test.alg\fR, that calculates an integral using the intermediate procedure \fCinteg()\fR.

.KS
   \fCLN\fR (Natural Logarithm)
   @Domain:~~x~~\[mo]~~\[Re]~~|~~x~~>~~0# 
   @Range:~~~~y~~\[mo]~~\[Re]#
.KE

.KS
   \fCSEC\fR (Secant)
   @Domain:~~x~~\[mo]~~\[Re]#
   @Range:~~~~y~~\[mo]~~\[Re]~~|~~y~~\[<=]~~-1~~\[ca]~~y~~\[>=]~~1#
.KE
   
.KS
   \fCSECH\fR (Hyperbolic secant)
   @Domain:~~x~~\[mo]~~\[Re]#
   @Range:~~~~y~~\[mo]~~\[Re]~~|~~0~~\[<=]~~y~~\[<=]~~1#
.KE
   
.KS
   \fCSIN\fR (Sine)
   @Domain:~~x~~\[mo]~~\[Re]#
   @Range:~~~~y~~\[mo]~~\[Re]~~|~~-1~~\[<=]~~x~~\[<=]~~1#
.KE
   
.KS
   \fCSINH\fR (Hyperbolic Sine)
   @Domain:~~x~~\[mo]~~\[Re]#
   @Range:~~~~y~~\[mo]~~\[Re]#
.KE
  
.KS
   \fCSQRT\fR (Square Root)
   @Domain:~~x~~\[mo]~~\[Re]~~|~~x~~\[>=]~~0#
   @Range:~~~~y~~\[mo]~~\[Re]~~|~~y~~\[>=]~~0#
.KE
   
.KS
   \fCTAN\fR (Tangent)
   @Domain:~~x~~\[mo]~~\[Re]~~|~~\[*p]~/~2~~<~~x~~<~~\[*p]~/~2#
   @Range:~~~~y~~\[mo]~~\[Re]#
.KE
   
.KS
   \fCTANH\fR (Hyperbolic Tangent)
   @Domain:~~x~~\[mo]~~\[Re]#
   @Range:~~~~y~~\[mo]~~\[Re]~~|~~-1~~<~~y~~<~~1#
.KE
   
The procedures \fCENTIER\fR, \fCABS\fR and \fCSIGN\fR were detailed in Section 5.1.2.


The following procedures (belonging to the DEC system-10/20 ALGOL) expect one long real numeric argument and yield a long real numeric result. If a literal numeric value or mathematical expression is given as argument, it is interpreted (or converted) to a long real number. All trigonometric functions work with radians.

.KS
   \fCLABS\fR (Absolute value)
   @Domain:~~x~~\[mo]~~\[Re]#
   @Range:~~~~y~~\[mo]~~\[Re]~~|~~y~~\[>=]~~0#
.KE

.KS
   \fCLARCTAN\fR (Arctangent)
   @Domain:~~x~~\[mo]~~\[Re]#
   @Range:~~~~y~~\[mo]~~\[Re]~~|~~-\[*p]~~\[<=]~~y~~\[<=]~~\[*p]#
.KE

.KS
   \fCLCOS\fR (Cosine)
   @Domain:~~x~~\[mo]~~\[Re]#
   @Range:~~~~y~~\[mo]~~\[Re]~~|~~-1~~\[<=]~~y~~\[<=]~~1#
.KE

.KS
   \fCLEXP\fR (Exponential function)
   @Domain:~~x~~\[mo]~~\[Re]#
   @Range:~~~~y~~\[mo]~~\[Re]~~|~~y~~\[>=]~~0#
.KE

.KS
   \fCLLN\fR (Natural Logarithm)
   @Domain:~~x~~\[mo]~~\[Re]~~|~~x~~>~~0# 
   @Range:~~~~y~~\[mo]~~\[Re]#
.KE

.KS
   \fCLSIN\fR (Sine)
   @Domain:~~x~~\[mo]~~\[Re]#
   @Range:~~~~y~~\[mo]~~\[Re]~~|~~-1~~\[<=]~~x~~\[<=]~~1#
.KE

.KS
   \fCLSQRT\fR (Square Root)
   @Domain:~~x~~\[mo]~~\[Re]~~|~~x~~\[>=]~~0#
   @Range:~~~~y~~\[mo]~~\[Re]~~|~~y~~\[>=]~~0#
.KE

The following conversion procedures are available (\fCBOOL\fR and \fCINT\fR, the only ones belonging to the DEC system-10/20 ALGOL, were detailed in Section 5.6):

.KS
   \fCBOOL\fR (Convert to Boolean type)
   @Domain:~~x~~\[mo]~~\[Re]#
   @Range:~~~~y~~\[mo]~~N~~|~~y~~=~~-1 or 0#
.KE

.KS
   \fCDEGREES\fR (Convert to degrees)
   @Domain:~~x~~\[mo]~~\[Re]#
   @Range:~~~~y~~\[mo]~~\[Re]#
.KE
   
.KS
   \fCINT\fR  (Convert to integer type)
   @Domain:~~x~~\[mo]~~\[Re]#
   @Range:~~~~y~~\[mo]~~N#
.KE

.KS
   \fCRADIANS\fR (Convert to radians)
   @Domain:~~x~~\[mo]~~\[Re]#
   @Range:~~~~y~~\[mo]~~\[Re]#
.KE

.KS
   \fCTOLONG\fR (Convert to long real type)
   @Domain:~~x~~\[mo]~~\[Re]#
   @Range:~~~~y~~\[mo]~~\[Re]#
.KE

.KS
   \fCTOREAL\fR (Convert to real type)
   @Domain:~~x~~\[mo]~~\[Re]#
   @Range:~~~~y~~\[mo]~~\[Re]#
.KE
.NH 2
.ds IND1430 \*[SN-NO-DOT]
STRING PROCEDURES
.XS
\*(SN 			String procedures
.XE
.LP
For details of the string procedures \fCCONCAT\fR, \fCLENGTH\fR, \fCSIZE\fR, \fCCOPY\fR, \fCNEWSTRING\fR, \fCCONVERT\fR, \fCHEAD\fR, \fCTAIL\fR, \fCTAKE\fR, \fCDROP\fR and the procedure \fCDELETE\fR, see Paragraph 13.7.
.NH 2
.ds IND1440 \*[SN-NO-DOT]
UTILITY PROCEDURES
.XS
\*(SN 			Utility procedures
.XE
.LP
.NH 3
.ds IND1450 \*[SN-NO-DOT]
Array Dimension Functions
.XS
\*(SN 			Array Dimension Functions
.XE
.LP
The integer procedure \fCDIM\fR, which takes as parameter the name of an array of any type, yields a result that is the number of dimensions of the array. This is most useful when the user passes an array as a parameter and wishes to check if it is, for example, a matrix. 

The integer procedures \fCLB\fR and \fCUB\fR also take as first parameters the name of an array; the second parameter is the subscript number (1 for the first dimensions, 2 for the second dimension and so on). The result is the lower or upper bound, respectively, of the subscript specified by the second parameter. The following procedure uses these to clear real square matrices:

.fam C
   PROCEDURE ZERO(A); ARRAY A;
   BEGIN
      INTEGER I,J;
      IF DIM (A) = 2 THEN BEGIN
         INTEGER L1,L2,U1,U2;
         L1 := LB(A,1); U1 := UB(A,1);
         L2 := LB(A,2); U2 := UB(A,2);
         FOR I := L1 UNTIL U1 DO
            FOR J := L2 UNTIL U2 DO 
               A[I,J] := 0;
      END
   END ZERO;
.fam T
.NH 3
.ds IND1460 \*[SN-NO-DOT]
Minima and Maxima Functions
.XS
\*(SN 			Minima and Maxima Functions
.XE
.LP
The integer procedures \fCIMIN\fR and \fCIMAX\fR, the real procedures \fCRMIN\fR and \fCRMAX\fR, and the long real procedures \fCLMIN\fR and \fCLMAX\fR are used, respectively, to determine the minimum or maximum of a series of arguments of the appropriate type. These procedures normally accept any number of parameters that may be contained in the input line.

For example:

.fam C
 I := IMIN(J,K,4,L);
 X := RMAX(Y+Z,RMIN(Y-Z,Q);
.fam T

NOTE: the \fCIMIN\fR and \fCIMAX\fR expect an integer values list, and implicitly convert any not integer value in the list to the integer type.
.NH 3
.ds IND1470 \*[SN-NO-DOT]
Field Manipulation
.XS
\*(SN 			Field Manipulation
.XE
.LP
The procedures \fCGFIELD\fR and \fCSFIELD\fR enable the user to manipulate a field within an integer number, literal or contained into a variable. The integer parameters \fCI\fR and \fCJ\fR specify a group of bits of length \fCJ\fR whose rightmost bit is the \fCI\fR'th bit (counting from zero at the right-hand side). The byte specified varies from 1 to 31 in length and may be at any position in the variable. \fCI\fR may range from 0 to 30, with the constraint \fCI + J <= 31\fR. If values don't fit these rules, they are shaped accordingly. 

The integer procedure \fCGFIELD\fR uses \fCI\fR and \fCJ\fR as the second and third parameters; the first parameter is the variable or the constant containing the base value. The returned result is the value of the group of bits (right justified) specified by \fCI\fR, \fCJ\fR. Thus:

.fam C
  INTEGER A;
  A:=117;
  PRINTLN(GFIELD(A,2,4));
.fam T

returns the value of the group of bits from 2 through 5 of the integer \fCA\fR:

.fam C
         13
.fam T

(Being 117=1110101 in binary, with bit 0 on the right, the statement returns bits 2,3,4,5 and thus the sequence 1101, which is 13.)

The typeless procedure \fCSFIELD\fR sets a byte specified by the second and third parameters \fCI\fR, \fCJ\fR to the value specified by the fourth parameter, of type integer. Thus 

.fam C
  INTEGER A;
  A:=117;
  SFIELD(A,2,4,0);PRINTLN(A);
.fam T

zeros the group of bytes 2,3,4,5 specified in the first example, returning

.fam C
         65
.fam T

(The statement sets to null bits 2,3,4,5 and thus the number becomes 1000001=65.) The statement:
  
.fam C
  SFIELD(A,2,4,7);PRINTLN(A);
.fam T

sets bits 2,3,4,5 to the bits of 7=0111, returning

.fam C
         93
.fam T

(The number 1110101 becomes 1011101=93.)

If the fourth argument in the list is greater in bits-depth than the required group of bits, only the part that fits is considered, starting from its rightmost bit. E.g.

.fam C
  SFIELD(A,2,4,64);PRINTLN(A);
.fam T

tries to overwrite bits 2,3,4,5 of number in A, using the number 64, which is in binary 64=100000; since the four rightmost bits are used, that is 0000, the effect is the same as using zero; the result is:

.fam C
         65
.fam T

NOTE: the AA-0196C-TK ALGOL manual provided instructions that were left-driven, while the instructions given here are right-driven, as used by current literature. The result is the same, as long as you count the \fCI\fR'th bit starting from bit 0 on one side, for a length \fCJ\fR of bits counting towards the other side;

.fam C
      right-driven:  1110101
                     6543210
		     
      left-driven:   1010111
                     0123456      
.fam T

This is a minor deviation from the DEC system-10/20 ALGOL.
.NH 2
.ds IND1480 \*[SN-NO-DOT]
DATA TRANSMISSION PROCEDURES
.XS
\*(SN 			Data transmission procedures
.XE
.LP
For details of these procedures refer to Chapter 16.
.NH 2
.ds IND1490 \*[SN-NO-DOT]
INTERFACE PROCEDURES
.XS
\*(SN 			Interface procedures
.XE
.LP
The DEC system-10/20 ALGOL had a set of procedures enabled to invoke an external Fortran procedure (predeclared with the \fCEXTERNAL\fR statement), which could or not have a return value; the following procedures were provided: 

 - \fCCALL\fR (untyped)
 - \fCICALL\fR (integer type)
 - \fCRCALL\fR (real type)
 - \fCDCALL\fR (double-precision Fortran type)
 - \fCLCALL\fR (logical Fortran type)

These had to be used with Fortran version F-40; if a Fortran version F-10 had to be used, the same procedure names were appended to the "F10" token, thus they were: 

 - \fCF10CALL\fR (untyped)
 - \fCF10ICALL\fR (integer type)
 - \fCF10RCALL\fR (real type)
 - \fCF10DCALL\fR (double-precision Fortran type)
 - \fCF10LCALL\fR (logical Fortran type)

In \fHtaxi\fR, only one version of \fCCALL\fR is enabled, with different usage. The procedure

.fam C
   CALL(X);
.fam T

invokes another instance of \fHtaxi\fR over the program \fCX\fR, where \fCX\fR is a proper string (literal or variable) containing the name of the ALGOL textual program, along with its path if necessary. If the \fC".alg"\fR extension is not specified it is eventually attached to the name.

The execution of the called program starts at the same position of the \fCCALL\fR statement, and thus its output is interspersed with the output of the caller.

An error in the called program prints an error message (as usual) but the caller is not stopped. \fCCALL\fR provides a syntax that can retrieve the occurred error code. If the syntax

.fam C
   CALL(X,N);
.fam T

is used, the return status of the called program is stored in \fCN\fR, for the user evaluation of the results (and to treat possible errors). The exit status follows the following conventions:

.IP -
a zero means a regular execution (no errors).
.IP -
a negative value means a UNIX error (here not quantified, because it depends on the various UNIX versions). This error is not an ALGOL error emitted by taxi, but something returned by the O.S.
.IP -
a positive value is the ALGOL error code, identifying what happened in the called program.
.NH 2
.ds IND1500 \*[SN-NO-DOT]
GENERAL INFORMATION ROUTINE
.XS
\*(SN 			General information routine
.XE
.LP
The integer procedure \fCINFO\fR, depending on the value of the parameter specified, provides information about various aspects of the environment.

.KS
    \fBParameter	Scope\fR
 	0		program size in bytes
 	1		date
 	2		time (seconds since midnight)
 	3		time (milliseconds since midnight)
 	4		runtime (milliseconds)
 	7		interpreter version
.KE

Other values simply return zero. All arguments are integer numeric values; returned values are generally of integer type, apart for \fCINFO(7)\fR. (See ahead.)

.IP \[bu]
\fCINFO(0)\fR returns the real dimension in bytes of the running program (not the meta-language generated by the pre-parser), and including the loaded libraries; thus, it may be bigger than the value returned by the shell. 

.IP \[bu]
\fCINFO(1)\fR returns the current date in compact format; the date is returned as an integer in the form \fCyyyymmdd\fR, with zero-padded numbers. (E.g. 20160502 for May 2, 2016.)

.IP \[bu]
For what about \fCINFO(2)\fR, \fCINFO(3)\fR and \fCINFO(4)\fR, returned values are based upon time as calculated by the underlying machine; so, they cannot be absolutely precise, because they are retrieved by the ticks (i.e. CPU cycles) of your machine.

.IP \[bu]
\fCINFO(7)\fR returns a real number, in the form \fCv.MMmmm\fR; the integer part is the version number, the two following decimals are the major version number and the three following decimals are the minor version number (for instance, 1.02004 is returned for version 1.02.004); \fCINFO(7)\fR is suitable to be printed with \fCPRINT(INFO(7),1,5)\fR.
.LP

Other examples:

.fam C
 PRINT(INFO(4)) ;
.fam T

might produce

.fam C
 1134600
.fam T

the job's runtime up to now in milliseconds, whereas

.fam C
 PRINT(INFO(5));
.fam T

simply returns zero.

.NH 2
.ds IND1510 \*[SN-NO-DOT]
EXECUTION TIMING
.XS
\*(SN 			Execution timing
.XE
.LP
To measure the execution timing, option \fC-t\fR comes in handy, but the measuring of time performed by this option includes the pre-parsing and the closing operations, that are executed by \fHtaxi\fR for the startup and the analysis of the source, so that it's surely greater than the actual execution runtime of your ALGOL program\*[*].
.FS
To be honest, the startup phase takes a very small amount (few milliseconds), but this varies depending on the quantity of \fCBEGIN-END\fR, \fCIF-THEN-ELSE\fR, \fCWHILE-DO\fR and \fCFOR-DO\fR structures found. In any case, \fCCLOCK\fR was built to return possibly the most precise value.
.FE

To record the execution timing in more steps, including only the parts of code you want to register, you can use the procedure \fCCLOCK\fR, which  returns in milliseconds the clock since \fHtaxi\fR's start. The returned value is shortened by the argument value, which is interpreted as an integer. The first time \fCCLOCK\fR is invoked, it should be stored in a variable as the time-zero value:

.fam C
  N = CLOCK(0)
.fam T

Any subsequent usage of this procedure with argument \fCN\fR will return the distance in milliseconds from the time-zero value, for instance:

.fam C
  PRINT(CLOCK(N))
.fam T

This technique measures the progression of the ALGOL execution between the two program lines. Actually, the following expression holds:

.fam C
  CLOCK(N) = CLOCK(0) - N
.fam T

The procedure \fCCLOCK\fR comes from Algol-20 (the ALGOL created by the Carnegie Institute of Technology in Washington in 1965), adapted for \fHtaxi\fR to treat milliseconds rather than seconds.

Another technique involves two independent measures:

.fam C
  START := CLOCK(0);
  ...
  ... <anything else>
  ...
  FINISH := CLOCK(0);
  WRITE("THE PROCESS TOOK "); PRINT(FINISH-START); 
  WRITE(" MILLISECONDS[N]");
.fam T

in a more classic way. 
.NH 2
.ds IND1520 \*[SN-NO-DOT]
DATE AND TIME IN ASCII FORMAT
.XS
\*(SN 			Date and time in ASCII format
.XE
.LP
Three routines are provided for returning the current time and date in string format suitable for printing without modification. The two date routines, \fCFDATE\fR and \fCVDATE\fR, give the option of a standard three-character abbreviation for the month (\fCFDATE\fR), or a variable-length string with the name of the month in full (\fCVDATE\fR). In both cases the year is given in full. String procedure \fCTIME\fR gives an eight-character string with the current time as \fCHH:MM:SS\fR.

For example

.fam C
 WRITE (VDATE) ; NEWLINE; WRITE(TIME);
.fam T

would produce an output as in

.fam C
 05-JANUARY-2021
 12:16:55
.fam T

whereas

.fam C
 WRITE (FDATE) ; NEWLINE; WRITE(TIME);
.fam T

would produce an output as in 

.fam C
 27-JUL-2024
 14:18:24
.fam T

NOTE: the month string is always in capital letters.
.NH 2
.ds IND1530 \*[SN-NO-DOT]
RANDOM NUMBER ROUTINE
.XS
\*(SN 			Random number routine
.XE
.LP
Three routines have been included to provide a random number generation capability. The number generator \fCRAND\fR is similar to that used in the DEC system-10/20 BASIC library. The floating-point output number is distributed uniformly between 0 and 1.

The \fHtaxi\fR version, unlike BASIC and like the DEC system-10/20 ALGOL, is initialized randomly. If a repeatable sequence of pseudo-random numbers is required, then the procedure \fCSETRAN\fR should be called before the first call to \fCRAND\fR, with a fixed initial value, for instance:

.fam C
 SETRAN(-1) 
.fam T

should be included in the ALGOL program. If the argument is zero, the call to \fCSETRAN\fR calculates a new seed based on current time (i.e. performs user randomization).

The third procedure is \fCSAVRAN\fR, which returns the value of the last generated random number without invoking the number generator. 

\fCRAND\fR and \fCSAVRAN\fR are real procedures, \fCSETRAN\fR is non-type.
.NH 2
.ds IND1541 \*[SN-NO-DOT]
Pausing a program
.XS
\*(SN 		Pausing a program
.XE
.LP
The typeless and parameterless procedure \fCPAUSE\fR merely exits to the underlying shell, in such a way as to allow execution to be continued by typing, from the shell itself, the \fCexit\fR command\*[*]. This is provided to allow, for example, a device to be assigned or to ascertain if a file exists, or whatever is the need that cannot be obtained by the program itself.
.FS
The underlying environment in the original DEC manual was called \fIMonitor\fR, which required the user to type \fCCONTINUE\fR to make execution go on; since \fHtaxi\fR is a Unix program, it falls back to the shell, and to exit from a Unix shell, the \fCexit\fR command is required.
.FE

To signal the start of pausing, the message

.fam C
 Paused. Type 'exit' to restore.
.fam T

appears. When \fCexit\fR is typed, the messages

.fam C
 exit
 Restoring the program.
.fam T

appear. All these messages separate the ALGOL output from the output of the shell.
.NH 2
.ds IND1540 \*[SN-NO-DOT]
PROGRAM TRACING AND DEBUGGING
.XS
\*(SN 		Program tracing and debugging
.XE
.LP
\fHtaxi\fR makes available two typeless and parameterless procedures, \fCONTRACE\fR and \fCOFFTRACE\fR that respectively enable and disable the dynamic tracing of procedures executions. When \fCONTRACE\fR and \fCOFFTRACE\fR are invoked, their own debug line is not printed, but a system string appears. E.g.

.fam C
 ONTRACE;
 ...
 ...
 OFFTRACE;
.fam T

Produces the effect:

.fam C
 <Trace enabled>

 [...]

 [...]

 <Trace disabled>
.fam T

See chapter 19 for the complete exposure of the debug features.
.NH 2
.ds IND1550 \*[SN-NO-DOT]
VARIABLE CONTENT TRACING
.XS
\*(SN 		Variable content tracing
.XE
.LP
The typeless procedure \fCDUMP\fR lets the programmer know the content of the variables, to see if they contain what is expected. The \fCDUMP\fR output is directed always to the screen, regardless of the selected output channel. Syntax:

.fam C
 DUMP
 DUMP(N)
 DUMP ALL
 DUMP var1, var2, var3....
.fam T

\fCDUMP\fR accepts numerical values in parentheses or string arguments. In case of numerical argument, this is one integer parameter which represents the number of block-levels to be dumped, starting from the current level and towards the root level.  A value of zero has the effect of dumping \fCALL\fR.

The definition of a 'level' is the following: 

.IP 1
any \fCBEGIN\fR starts a level, and its correspondent \fCEND\fR closes that level; the current level is level 1, and all container levels (down to the root level) increase their level number hierarchically (being the root level the highest number).

.IP 2
any \fCPROCEDURE\fR, when executed, starts a level, in which argument variables and the typed return variable are declared; this level is closed when the runtime \fCPROCEDURE\fR process ends.

.IP 3
nothing else starts a level.
.LP

E.g.

.fam C
 DUMP(1)
 DUMP
.fam T

dump only current level, whereas

.fam C
 DUMP(3)
.fam T

dumps the current level and the two consecutive lower levels. 

.fam C
 DUMP(0)
 DUMP ALL
.fam T

dump all levels down to the root level. (The root level can be hard to be calculated manually, for long and complicated programs.)

The procedure \fCDUMP\fR can also use string arguments; in this case, they are variables names, and \fCDUMP\fR shows their content; variable names are written in a list after \fCDUMP\fR, without brackets and separated by commas:

.fam C
 DUMP height,weight,....
.fam T

As said, level 1 is the current level, which is the level where \fCDUMP\fR is found. The root level, layered some levels distant, has one specific level number, qualifying the "distance" between current level and the root level. Any variable which is declared in the space between the current and the root level and is visible for the current level at the time \fCDUMP\fR is invoked, is dumped.

The following program shows how \fCDUMP\fR can be used.

.fam C
 BEGIN
    INTEGER A,B,C,D,E;
    A:=B:=C:=D:=E:=24;
    BEGIN
       REAL F;
       LONG REAL G;
       F:=ln(A);
       G:=F+B;
       BEGIN
          BOOLEAN H;
          INTEGER I,J,K;
          REAL L,M,N;
          H:=F>0;
          N:=3;
          DUMP;
          END;
       END;
 END.
.fam T

The output is the table of the variables visible for current level, marked as 1:

.fam C
 Level:1  Name:H [#8], Type is Boolean, Value is -1.000000
 Level:1  Name:I [#9], Type is integer, Value is 0.000000
 Level:1  Name:J [#10], Type is integer, Value is 0.000000
 Level:1  Name:K [#11], Type is integer, Value is 0.000000
 Level:1  Name:L [#12], Type is real, Value is 0.000000
 Level:1  Name:M [#13], Type is real, Value is 0.000000
.fam T

If \fCDUMP\fR is changed to \fCDUMP ALL\fR (there are three levels):

.fam C 
 Level:3  Name:A [#1], Type is integer, Value is 24.000000
 Level:3  Name:B [#2], Type is integer, Value is 24.000000
 Level:3  Name:C [#3], Type is integer, Value is 24.000000
 Level:3  Name:D [#4], Type is integer, Value is 24.000000
 Level:3  Name:E [#5], Type is integer, Value is 24.000000
 Level:2  Name:F [#6], Type is real, Value is 3.178054
 Level:2  Name:G [#7], Type is long real, Value is 27.178054
 Level:1  Name:H [#8], Type is Boolean, Value is -1.000000
 Level:1  Name:I [#9], Type is integer, Value is 0.000000
 Level:1  Name:J [#10], Type is integer, Value is 0.000000
 Level:1  Name:K [#11], Type is integer, Value is 0.000000
 Level:1  Name:L [#12], Type is real, Value is 0.000000
 Level:1  Name:M [#13], Type is real, Value is 0.000000
 Level:1  Name:N [#14], Type is real, Value is 3.000000
.fam T
 
All variables in the levels are shown. If \fCDUMP\fR is put in another block:

.fam C
 BEGIN
    INTEGER A,B,C,D,E;
    A:=B:=C:=D:=E:=24;
    BEGIN
       REAL F;
       LONG REAL G;
       F:=ln(A);
       G:=F+B;
       BEGIN
          BOOLEAN H;
          INTEGER I,J,K;
          REAL L,M,N;
          H:=F>0;
          N:=3;
       END;
       DUMP ALL;
    END;
 END.
.fam T

the output would be:

.fam C 
 Level:2  Name:A [#1], Type is integer, Value is 24.000000
 Level:2  Name:B [#2], Type is integer, Value is 24.000000
 Level:2  Name:C [#3], Type is integer, Value is 24.000000
 Level:2  Name:D [#4], Type is integer, Value is 24.000000
 Level:2  Name:E [#5], Type is integer, Value is 24.000000
 Level:1  Name:F [#6], Type is real, Value is 3.178054
 Level:1  Name:G [#7], Type is long real, Value is 27.178054
.fam T

The \fCDUMP\fR mask is read as follows:
 
.IP -
\fCLevel\fR: the level number; the current level (where \fCDUMP\fR is called), is level number 1; next levels are thus numbered 2,3,...,N; lateral levels are not seen at all, being out of reach (see ahead). The highest level is the root level.
.IP -
\fCName\fR: the variable name, followed by the variable index in square brackets. There is one index for each variable.
.IP - 
Type: the type of the variable.
.IP - 
Value: the variable content.
.LP

If \fCDUMP\fR is needed only for specific variables:

.fam C
 BEGIN
    INTEGER A,B,C,D,E;
    A:=B:=C:=D:=E:=24;
    BEGIN
       REAL F;
       LONG REAL G;
       F:=ln(A);
       G:=F+B;
       BEGIN
          BOOLEAN H;
          INTEGER I,J,K;
          REAL L,M,N;
          H:=F>0;
          Name:=3;
       END;
       DUMP B,C;
    END;
 END.
.fam T

The output is 

.fam C
 Level:2  Name:B [#2], Type is integer, Value is 24.000000

 Level:2  Name:C [#3], Type is integer, Value is 24.000000
.fam T

with the usual mask interpretation and the correspondent level. If a wrong call is used, for example with \fCDUMP K\fR instead of \fCDUMP A\fR, a message would appear:

.fam C
 taxi runtime processor error in the program at line 16:
 Illegal variable or variable out of scope for DUMP.
 DUMP K;
     ^
 Error code 62
.fam T

This is because variable \fCK\fR exists only when the relative \fCBEGIN\fR is entered and its level created and is destroyed when the level is terminated, thus \fCDUMP\fR cannot see it.

If you happen to have a variable called \fCALL\fR, invoking \fCDUMP ALL\fR is not interpreted as "dump variable \fCALL\fR" but "dump all variables". To solve this interpretation, put it not as first by using a comma:

.fam C
 DUMP ,ALL
.fam T

.bp
.NH 1
.ds IND1560 \*[SN-NO-DOT]
ISO 1538-1984 (E) INTEGRATION AND COMPATIBILITY
.XS
\*(SN 		\fBISO 1538-1984 (E) integration and compatibility\fR
.XE
.LP
The ISO 1538-1984 specifies, in  Appendix 1, that two subsets of ALGOL 60 are defined, denoted as level 1 and level 2, if level 0 is the language version with the full architecture.

The level 1 is defined as equal to level 0 but with the following restrictions:

.nr step 1 1
.IP \n[step] 5
The \fCOWN\fR declarator is not included. 
.IP \n+[step]
Additional restrictions are placed upon actual parameters as given by the following replacement lines to the table in 
.UL "Section 4.7.5.5"
\.
.br
.fam C 
 - Formal parameter    Mode     Actual parameter
   ------------------------------------------------------------- 
   integer             name     integer expression (see 
.UL "4.7.5.2"
) 
   real                name     real expression (see 
.UL "4.7.5.2"
) 
   integer array       value    integer array (see 
.UL "4.7.5.3"
) 
   real array          value    real array (see 
.UL "4.7.5.3"
) 
   typeless procedure  name     typeless procedure (see 
.UL "4.7.5.3"
) 
   integer procedure   name     integer procedure (see 
.UL "4.7.5.3"
) 
   real procedure      name     real procedure (see 
.UL "4.7.5.3"
) 
.fam T
.IP \n+[step]
Only one alphabet of 26 letters is provided, which is regarded as being the lower case alphabet of the reference language.
.IP \n+[step]
If deleting every symbol after the twelfth in every identifier would change the action of the program, then the program is undefined. 
.LP

The level 2 subset consists of restrictions 1-3 of level 1 and also: 

.nr step 5 1
.IP \n[step] 5 
Procedures may not be called recursively, either directly or indirectly. 
.IP \n+[step]
If a parameter is called by name, then the corresponding actual parameter may only be an identifier or a string. 
.IP \n+[step]
The designational expressions occurring in a switch list may only be labels. 
.IP \n+[step]
The specifiers switch, procedure and (type) procedure are not included. 
.IP \n+[step]
A left part list may only be a left part. 
.IP \n+[step]
If deleting every symbol after the sixth in every identifier would change the action of the program, then the program is undefined. 
.LP

\fHtaxi\fR has none of these restrictions, so I can state it is at least a level 0 ALGOL. Help me to prove it, by testing it under every aspect...
.NH 2
.ds IND1570 \*[SN-NO-DOT]
GENERAL
.XS
\*(SN 			General
.XE
.LP
\fHtaxi\fR is quite fully ISO 1538-1984 compliant, even if some decisions in favour of the DEC system-10/20 ALGOL were taken when the two differentiated; this is due to the complete procedures DEC can offer, while the ISO 1538-1984 lacks some specific I/O statements. (For example, opening a file in input/output.)

In any case, the ISO conformance is guaranteed at least for the system procedures, the math environment and all the procedures in the Environmental Block, and all differences between \fHtaxi\fR and the ISO 1538-1984 are always exposed, though scattered all over the entire manual, where appropriate.

Escape characters are correctly input and output, as loosely imposed in
.UL "Section 2.6.3"
of the Standard, and according to Section 18.7.1 of this manual.

In the following, all the ISO 1538-1984 features enabled in \fHtaxi\fR are presented.
.NH 2
.ds IND1580 \*[SN-NO-DOT]
ISO INTEGER PROCEDURES
.XS
\*(SN 			ISO integer procedures
.XE
.LP
The following integer procedures are provided (see the ISO 1538, 
.UL "Appendix 2, page 14"
):

.IP  \fCABS(E)\fR       
absolute value @~|E|~# (real argument, real result)

.IP  \fCIABS(E)\fR      
absolute value @~|E|~# (integer argument, integer result)

.IP  \fCSIGN(E)\fR      
sign of the real argument

.IP  \fCENTIER(E)\fR    
largest integer not greater than \fCE\fR (real argument, integer result)
.LP
.NH 2
.ds IND1590 \*[SN-NO-DOT]
ISO MATHEMATICAL FUNCTIONS
.XS
\*(SN 			ISO mathematical functions
.XE
.LP
The following math real functions are provided (see the ISO 1538
.UL "Appendix 2, page 14"
):

.IP \fCSQRT(E)\fR      
square root @~ sqrt \fCE\fR~# (error message differs)

.IP  \fCSIN(E)\fR       
sine of \fCE\fR expressed in radians
  
.IP  \fCCOS(E)\fR       
cosine of \fCE\fR expressed in radians

.IP  \fCARCTAN(E)\fR    
principal value returned in radians of the arctangent of \fCE\fR

.IP  \fCLN(E)\fR        
natural logarithm of \fCE\fR (error message differs)

.IP  \fCEXP(E)\fR
exponential function of \fCE\fR (error message differs)
.LP

Besides, the following ISO 1538-1984 functions are provided (see 
.UL "Section 3.3.4.3 page 7"
):

.IP  \fCEXPI(I,J)\fR
exponentiation @~\fCI\fR sup \fCJ\fR~# (\fCI\fR and \fCJ\fR integer values)
  
.IP  \fCEXPR(X,Y)\fR    
exponentiation @~\fCX\fR sup \fCY\fR~# (\fCX\fR and \fCY\fR real values)

.IP  \fCEXPN(R,I)\fR    
exponentiation @~\fCR\fR sup \fCI\fR~# (\fCR\fR real and \fCI\fR integer)
.LP
.NH 2
.ds IND1600 \*[SN-NO-DOT]
ISO TERMINATING PROCEDURES
.XS
\*(SN 				ISO terminating procedures
.XE
.LP
The following procedures are provided (see the ISO1538
.UL "Appendix 2, page 14"
):

.IP  \fCSTOP\fR
anticipated end of program

NOTE: the \fCSTOP\fR procedure executes a brutal and immediate stop of the execution; none of the existing structures (\fCIF-THEN\fR, \fCWHILE\fR, \fCFOR\fR and \fCBEGIN\fR blocks) are closed, and opened channels or files are forced close by the ending routine. The execution terminates with the message:

.fam C
     taxi execution interrupted by STOP at line <n>
.fam T

where \fC<n>\fR is the line where the \fCSTOP\fR occurs.

.IP  \fCFAULT(STR,R)\fR
error message printing and anticipated end

NOTE: error treatment in \fHtaxi\fR is built according to the DEC system-10/20 ALGOL behaviour\*[*]. But the ISO standard included a procedure for treating runtime user errors (though this could be also accomplished by a proper procedure using only \fCWRITE\fR or \fCOUTSTRING\fR). So I introduced the ISO \fCFAULT\fR, which has at least the remarkable advantage of uniforming the printing of error messages, and may reveal effectively helpful in devising personal error treatment routines. 
.FS
I must warn that the error message list in the DEC manual is largely incomplete, so I had to design personal and specific error messages to help the programmer to understand what and where the error occurred. 
.FE

E.g.
  
.fam C
      FAULT("error in argument",Y);
.fam T

(supposing \fCY\fR contains some specific error-prone value that violates some conditions), produces

.fam C
      fault  error in argument  -3.000000
.fam T

The aspect of the error message is totally ISO 1538-1984-compliant (respecting spaces and the lower-case characters).

In designing the \fCFAULT\fR procedure, I thought it could be improved to include the DEC side as well; therefore, in \fHtaxi\fR, \fCFAULT\fR has two other captivating features. 

The first makes optional the second argument; that is, if the second argument is not given, only the textual message is printed. E.g.

.fam C
      FAULT("error in argument");
.fam T

produces

.fam C
      fault  error in argument
.fam T

The error string may be a literal value or contained into a string variable or string array element.

The second improvement  makes \fCFAULT\fR accept a numeric value as argument; in this case, it is interpreted as the error code of the \fHtaxi\fR error list\*[*]. This can uniform the error messages with DEC. E.g.
.FS
type \fCtaxi --error-list\fR to see the whole list on the screen.
.FE

.fam C
      FAULT(47)
.fam T

prints

.fam C
      fault  Division by zero
.fam T

In this way, \fCFAULT\fR becomes the \fItrait d'union\fR of the two worlds, at least for what about the printing of error messages. 
.LP
.NH 3
.ds IND1610 \*[SN-NO-DOT]
Special Error Testing Features
.XS
\*(SN 			Special Error Testing Features
.XE
.LP
A special error-test feature is the \fIzero-condition\fR: error condition 0 (zero) is a harmless error condition that is never returned by \fHtaxi\fR, and that can be conveniently used by \fCFAULT\fR to specify an error condition test without having to build a real error in the code. 

I must warn you though that, since \fHtaxi\fR is a UNIX program, it uses the convention that the returned value 0 (zero) is normally considered by the shell as the code for \fIEXIT with SUCCESS\fR (in UNIX terminology); this means that, in using the procedure \fCCALL\fR (see 17.5), such a case is received as a regular ending by the called program, and if you meant to catch the zero error condition this would be undistinguishable from a regular execution and thus useless. 

Take this into account when using \fCFAULT\fR within \fCCALL\fR calls.
.NH 2
.ds IND1620 \*[SN-NO-DOT]
ISO INPUT/OUTPUT PROCEDURES
.XS
\*(SN 			IOS input/output procedures
.XE
.LP
I have anticipated earlier that the ISO 1538-1984 offers no procedures for establishing a connection to a file or a device (leaving the responsibility to the implementer); anyway, the following input/output procedures described in the ISO 1538-1984 are provided (see 
.UL "Appendix 2, page 14-16"
):
		
.IP  "\fCINCHAR(channel,str,int);\fR"
Set \fCint\fR to the value corresponding to the first position in \fCstr\fR of current character on \fCchannel\fR. Set \fCint\fR to zero if character not in \fCstr\fR. Move \fCchannel\fR pointer to next character. The string \fCstr\fR can contain escape characters in the form \fC\\x\fR, that will be correctly evaluated as such.

.IP  "\fCOUTCHAR(channel,str,int);\fR"
Pass to \fCchannel\fR the character in \fCstr\fR, whose position corresponds to the value of \fCint\fR. The first character of the string \fCstr\fR has position 1.

.IP  "\fCLENGTH(str);\fR"
Return the number of characters in the open string \fCstr\fR enclosed by the outermost string quotes, after performing any necessary concatenation as defined in the ISO Standard at  
.UL "Section 2.6.3"
and also \fCLENGTH\fR in Section 13.7.2 of this manual.

.IP  "\fCOUTSTRING(channel,str);\fR"
Pass to channel all characters of \fCstr\fR, until the end of the string. It is a wrapper for \fCOUTCHAR\fR. Even if not explicitly specified in the ISO norm (that only asserts in 2.6.3 the need for an escaping sequence for the string delimiters), \fCOUTSTRING\fR was enabled to parse all the escape characters specified in 18.8.1.

.IP  "\fCOUTTERMINATOR(channel);\fR"
Output a terminator for use after a number to \fCchannel\fR. In \fHtaxi\fR the terminator is a space character. 

.IP  "\fCININTEGER(channel,int);\fR"
\fCint\fR (which must be a proper integer variable) takes the value of an integer, as defined in 
.UL "Section 2.5.1"
, read from \fCchannel\fR. The terminator of the integer may be either a space, a newline or a semicolon. Any number of spaces or newlines may precede the first character of the integer representation.

.IP  "\fCOUTINTEGER(channel,int)\fR"
Pass to \fCchannel\fR the characters representing the value of \fCint\fR, followed by a terminator. In the case of a negative number, the output is preceded by the minus sign.

.IP  "\fCINREAL(channel,re);\fR"
\fCre\fR takes the value of a real number read from \fCchannel\fR. Blanks may follow the exponent symbol, which can be \fC&\fR, \fC\@\fR or \fCE\fR. The terminator of the integer may be either space, a newline or a semicolon. Any number of spaces or newlines may precede the first character of the real representation.

.IP  "\fCOUTREAL(channel,re);\fR"
Pass to \fCchannel\fR the characters representing the value of real \fCre\fR, followed by a terminator. In the case of a negative number, the output is preceded by the minus sign. The exponential form is activated only when the number cannot fit the 10 characters available space\*[*] exponential excluded. The output format is formed by the integer part plus the decimals, in total 10 characters, with the eleventh position occupied by the dot, and three or four more characters for the positive or negative exponential part. 
.FS
The ISO \fCoutreal\fR at 
.UL "page 16"
of the Standard uses a formula to retrieve the width of the printing number, that is the precision for the decimals. The formula is 
.EQ
entier(1.0 - ln(epsilon) over ln(10.0) )
.EN
Now, using a normal value as 1E-15 for an average \fCepsilon\fR, we get 16 as depth. (Even more, if you think that nowadays machines are capable of holding even more digits.) Probably it was intended as the total characters space for integer part, decimals and the exponential part. This turns out to be a little strange, if you consider that the ISO \fCoutreal\fR procedure prints \fIall the digits\fR, zeros included. So I chose to retain 10 digits  (exponential part excluded) as the total digits width for \fCOUTREAL\fR, basing on the same output of the DEC protocol for the decimal part, and add the exponential only when due. This is a minor difference with the ISO document since \fCOUTREAL\fR in \fHtaxi\fR is really ISO-compliant, except for the width.
.FE
.LP
.NH 2
.ds IND1630 \*[SN-NO-DOT]
ISO ENVIRONMENTAL ENQUIRIES
.XS
\*(SN 			ISO environmental enquiries
.XE
.LP
NOTE: the environmental enquiries exposed in ISO1538
.UL "Appendix 2, page 16"
, quote "\fImaxreal, minreal, and maxint are, respectively, the maximum allowable positive real number, the minimum allowable positive real number, and the maximum allowable positive integer, such that any valid expression of the form\fR

 \fC<primary> <arithmetic operator> <primary>\fR

\fIwill be correctly evaluated, provided that each of the primaries concerned, and the mathematically correct result lies within the open interval (-maxreal, -minreal) or (minreal, maxreal) or is zero if of real type, or within the open interval (-maxint, maxint) if of integer type...\fR"

So, the following environmental enquiries, contained in the ISO1538-Appendix 2, 
.UL "page 16"
) are provided (see also \fCtaxi.h\fR)

.IP  "\fCMAXREAL\fR"
The maximum positive allowed real number. 
.br
It is set to 1E+16.\*[*]
.FS
This limit is valid only for the ISO procedure \fCOUTREAL\fR. In case a \fCREAL\fR number is printed with \fCPRINT\fR, the limit of computation is not \fCMAXREAL\fR but \fCMAXLONGREAL\fR (see ahead).
.FE

.IP  \fCMINREAL\fR
The minimum allowed negative real number. 
.br
It is set to 1E-16.

.IP  \fCMAXINT\fR
The maximum computable integer value. 
.br
It is set to 2147483647.

.IP  "\fCEPSILON\fR"
The smallest positive real number such that

.fam C   
    1.0+EPSILON > 1.0 
    1.0 > 1.0-EPSILON
.fam T

It is set to 9.9999999999999999E-16. 

.LP
In addition to the default ISO 1538-1984 environmental enquiries, \fHtaxi\fR has also the following constants:
  
.IP  "\fCINFINITY\fR"
.br
The number beyond the maximum computable positive real/long real. 
.br
It is printed as \fCinf\fR (not by \fHtaxi\fR but by the gcc).

NOTE: \fCINFINITY\fR returns an 'infinite' number, which is not a proper number and is printed as \fCinf\fR. This has not to be confused with \fCINF\fR, which returns a computable number, the maximum positive real. \fCINFINITY\fR is the 'number' you get if you try to go past \fCINF\fR. 

NOTE: if you try to assign \fCINFINITY\fR to an integer type, this will be assigned the value -2147483647, because the integer type has no infinite.

.IP  "\fCINF\fR"
.br
Maximum computable positive real/long real. 
.br
It is set to 1.7E308.

NOTE: \fCINF\fR returns an 'infinitive', which is a proper number and is shown in full. \fCINF\fR and \fCMAXLONGREAL\fR can be confused because they are quite the same value. \fCINF\fR was introduced to set the 'true' limit of computation of the C double type. This has not to be confused with \fCINFINITY\fR, which is not a computable number.

.IP  "\fCLONGEPSILON\fR"
The smallest positive long real number such that
  
.fam C 
    1.0&&0+LONGEPSILON > 1.0&&0 
    1.0&&0 > 1.0&&0-LONGEPSILON
.fam T

It is set to 9.9999999999999999E-307. 
.LP

.IP  \fCMAXLONGREAL\fR
Maximum allowed positive long real number. 
.br
It is set to 1.0E+308.

.IP  \fCMINLONGREAL\fR
Minimum allowed positive long real number. 
.br
It is set to 1.0E-308.

.IP  \fCMININT\fR
Maximum computable negative integer value. 
.br
It is set to -2147483648.

.IP  \fCPI;\fR
.br
Greek \[*p], equal to the ratio of a circle's circumference to its diameter. It is set to 3.14159265358979. \fCPI\fR returns a long real value.
.LP

For what about the limits previously exposed, remember what was said for the storing of real numbers\*[*]: since they are stored in the same C \fCdouble\fR memory space of the long real numbers, any computation involving real/long real numbers is not truncated to \fCMAXREAL\fR or \fCMINREAL\fR; the limits are only superimposed in printing (for use with \fCPRINT\fR and \fCOUTREAL\fR).
.FS
See paragraph 1.2.2.
.FE
.NH 2
.ds IND1640 \*[SN-NO-DOT]
SPECIAL ISO-LIKE ADDITIONS
.XS
\*(SN 			Special ISO-like additions
.XE
.LP
To gain perfect compatibility between the ISO 1538-1984 spirit and the DEC system-10/20 ALGOL procedures, and to reach a higher level of compatibility with other ALGOL environments, the following procedures, which don't belong to the DEC design or the ISO standard, are provided:

.IP  "\fCINARRAY(channel,ar);\fR"
\fCar\fR, which is a regular numeric array, is filled with values read from \fCchannel\fR. \fCINARRAY\fR was discussed in detail in Section 16.7.3.5 "Array Input/output".

.IP  "\fCOUTARRAY(channel,ar);\fR"
Array \fCar\fR is printed to \fCchannel\fR according to fixed rules. \fCOUTARRAY\fR was discussed in detail in Section 16.7.3.5 "Array Input/output".

.IP  "\fCINSTRING(channel,str);\fR"
\fCstr\fR, which is a regular string variable, takes the value of the string read from \fCchannel\fR; in case of a file line, \fCstr\fR takes the value of the whole line up to END-OF-LINE; In case of input from the keyboard, \fCstr\fR takes the value of the whole typed line up to the Enter key. Escape characters are correctly evaluated as such.

If the string is enclosed in double-quotes like \fC"this"\fR or in double single quotes like \fC''this''\fR, the surrounding quotes are not removed before assignment so that strings are retained as-is.

If \fCstr\fR is successively assigned to a string variable of length \fCL\fR, only up to \fCL\fR characters of \fCstr\fR are copied, and the rest is lost. Thus the user must take in account the length of the hosting string. (The usage of \fCNEWSTRING\fR may reveal useful in case one wants to enlarge the space of the default 255 characters hosting string, for instance to assign a file line, which may be longer.)

.IP  "\fCINLONGREAL(channel,lre);\fR"
\fClre\fR takes the value of a number read from \fCchannel\fR. Blanks may follow the exponent symbol, which can be \fC&&\fR, \fC\@\@\fR, \fCD\fR or \fCE\fR. If the exponential symbol is not doubled, \fHtaxi\fR won't complain. 

.IP  "\fCOUTLONGREAL(channel,lre);\fR"
Passes to \fCchannel\fR the characters representing the value of the long real \fClre\fR, followed by a terminator. The exponential form is activated only when the number cannot fit the 20 decimals available space. In the case of a negative number, the output is preceded by the minus sign.

.IP  "\fCOUTBOOLEAN(channel,lbool);\fR"
Passes to \fCchannel\fR the words \fCfalse\fR or \fCtrue\fR, according to the truth value of the Boolean \fClbool\fR, followed by a terminator.

.IP  "\fCINCHARACTER(channel,char);\fR"
\fCchar\fR takes the value of an ASCII character read from \fCchannel\fR. A character is a number in the range 0\[di]127. In case of input from keyboard, the character is read and not echoed, and no Enter key is required: after the keypress, the procedure ends.

.IP  "\fCOUTCHARACTER(channel,char);\fR"
Passes to \fCchannel\fR the character number in the range 0\[di]127, as an ASCII character. No terminator follows.

.IP  "\fCERRC, ERRL\fR"
These variables take respectively the error code number and the error line number in case of errors occurred in procedures that host a label as error return technique. (E.g. \fCINPUT\fR, \fCOUTPUT\fR, \fCOPENFILE\fR.) In case of normal usage, their both are set to -1.
.LP

Besides, the following command, which is a more general print statement, though not ISO-like, is provided:

.IP  \fCVPRINT(S);\fR
Prints to current output channel the string \fCS\fR (either literal or contained into a string variable or a string expression) followed by a New Line character. Interpretation of escape characters in 18.7.1 is provided. Any other escape used is interpreted literally. (E.g. \fC\\w\fR is \fCw\fR.) The special string commands contained in square brackets (available in the DEC system-10/20 ALGOL \fCWRITE\fR) are here not supported and are interpreted literally.
.LP

.NH 3
.ds IND1650 \*[SN-NO-DOT]
Escape characters
.XS
\*(SN 			Escape characters
.XE
.LP
Here are the escaping characters understood by \fHtaxi\fR (and used in the ISO string procedures and also in the foreigner imported \fCVPRINT\fR):

.fam C
   alarm beep       \\a 
   backspace        \\b 
   form feed        \\f
   new line         \\n 
   carriage return  \\r 
   horizontal tab   \\t 
   vertical tab     \\v 
   backslash        \\\\
   single quote     \\' 
.fam T

In Unix, generally, the New Line character is performed by \fC\\n\fR, while in the Mac world the same task is performed by \fC\\r\fR and in DOS/Windows by \fC\\r\\n\fR; in any case, if you use \fC\\n\fR, this will be correctly interpreted as a New Line escaping character in (hopefully) all the three environments.
.NH 2
.ds IND1660 \*[SN-NO-DOT]
DEC AND ISO 1538-1984: TWO DIFFERENT PHILOSOPHIES
.XS
\*(SN 			DEC and ISO 1538-1984: two different philosophies
.XE
.LP
DEC and ISO, while based upon the same ALGOL rules, bear a different conception in treating the input/output. There is good and bad in each world, as you will see, and you can use at any time the one you like best, or the one specifically targeted for your instance of output. 

In the following, some specific differences are underlined.

.LP
.NH 3
.ds IND1670 \*[SN-NO-DOT]
DEC and ISO default channels
.XS
\*(SN 			DEC and ISO default channels
.XE
.LP
The main and most important difference between DEC and ISO I/O procedures (apart for the graphical issues) is that the DEC procedures \fCPRINT\fR, \fCWRITE\fR, \fCNEWLINE\fR, \fCREAD\fR etc. (included \fCVPRINT\fR) act on the default input/output channels set by \fCSELECTINPUT\fR or \fCSELECTOUTPUT\fR (by default the \fCTTY\fR for both directions). That is, if you want to print on \fIanother\fR channel, you have to open it and make it available.

The ISO 1538-1984 procedures, instead, like \fCINCHAR\fR, \fCOUTCHAR\fR, \fCOUTSTRING\fR, \fCININTEGER\fR, \fCOUTINTEGER\fR, \fCINREAL\fR, \fCOUTREAL\fR do specify the channel in the argument queue. If the default \fCTTY\fR is to be used, the channel number to be specified is 0 (zero) for input and 1 (one) for output. Unfortunately, no means for opening other channels is provided by the ISO 1538-1984, so that you have to use the DEC ones for this purpose.
.NH 3
.ds IND1680 \*[SN-NO-DOT]
DEC and ISO numeric output
.XS
\*(SN 			DEC and ISO numeric output
.XE
.LP
The main difference between numeric DEC output procedure and ISO output procedures is this:

.IP - 
DEC \fCPRINT\fR procedures print numbers along with fixed rules: you can manoeuvre the output by deciding in advance the depth and width of numbers by changing the second and third arguments, and this gives great help when printing tables, and multiple results, matrices and so forth. A space character is always printed after a number, preceded by the minus sign if negative or a blank if positive.\*[*]
.FS
It's curious noting that the SAIL program, available in the TOPS20 platforms didn't print a space \fIafter\fR the number.
.FE 

.IP - 
ISO 1538-1984 \fCOUTREAL\fR and \fCOUTINTEGER\fR (and the apocryphal \fCOUTLONGREAL\fR), instead, print numbers more 'naturally'; after all, reading 25.40000000 is more comfortable than 2.540000000&+1; these procedures are designed to use the exponential form only when needed, while the DEC system-10/20 ALGOL prints real and long real numbers always in exponential form, unless you size the output on your own through \fCPRINT\fR. 
.NH 3
.ds IND1690 \*[SN-NO-DOT]
DEC and ISO output line length
.XS
\*(SN 			DEC and ISO output line length
.XE
.LP
Another difference occurring between the two worlds managed by \fHtaxi\fR is the way they manage the line length in the output:

.IP \-
DEC \fCPRINT\fR and \fCWRITE\fR procedures keep track of the line counter, and if the printing position is past the value of 72, they print a New Line character, to avoid breaking up strings and numbers.
.IP \-
ISO 1538-184 \fCOUTREAL\fR, \fCOUTINTEGER\fR and \fCOUTLONGREAL\fR procedures instead, while they keep track of the line counter, don't control if the printing position is past the screen limit. This adheres to the ISO documents (Environmental block, Appendix 2).
.LP
.NH 2
.ds IND1700 \*[SN-NO-DOT]
MANUAL CONVERSIONS FOR OTHER SOURCES
.XS
\*(SN 		Manual conversions from other sources
.XE
.LP
\fHtaxi\fR does its best to convert foreign structures to proper ALGOL items, but certainly it cannot do everything. Certain features cannot be converted because they have a very special meaning for \fHtaxi\fR, and thus must be changed manually, in particular, if an environment uses other channels for the TTY other than 0 (zero) or 1 (one), these have to be changed manually.

NOTE: Some specific statements cannot be converted. For instance, marst (an ISO ALGOL to C converter), uses instructions like \fC'print'\fR to output a list of items (numbers or strings) to channel 1 - the terminal - and \fC'inline'\fR to pass C-formatted strings to the C converter, which are supposed to be compiled along with the rest of the program. The first, \fC'print'\fR, has the same name of the \fCPRINT\fR procedure in the DEC system-10/20 ALGOL, which is targeted to print one number at each invocation, and thus cannot be converted (in the sense of DEC). The second, \fC'inline'\fR, requires the evaluation of the string, and case by case a new procedure (or procedures set) must be created to simulate the C effect. For instance, suppose you have, into the body of a procedure called \fCretproc\fR:

.fam C
  inline("my.retval.u.real = rand();");
.fam T

This is supposed to get some random value to the variable \fCmy.retval.u.real\fR. To convert this in ALGOL, a manual similar effect can be obtained by using in place of the previous \fCinline\fR entry:

.fam C
  my.retval.u.real := RAND; 
.fam T

In all other cases, you first have to ascertain what is needed. Second, you have to find a trick that solves the problem.
.bp
.NH 1
.ds IND1710 \*[SN-NO-DOT]
DEBUGGING PROGRAMS
.XS
\*(SN 		\fBDebugging programs\fR
.XE
.LP

Being an interpreter, \fHtaxi\fR has a simple debugger; it aims to help the programmer find where the error occurs, since error messages not always bring exact information.

The debugging is enabled in three ways: option \fC-d\fR enables the debug from the start since it is invoked on the command line. In the source, you can enable the debugging with the typeless procedure \fCONTRACE\fR and can be disabled with \fCOFFTRACE\fR.  

There are two acting debugger engines: the one acting on the pre-parsing phase and the one on the runtime phase. Let's examine them in detail.

Note: the line number and position number that the debugger writes are not those of your ALGOL original listing, but they refer to the tokenized and blanks-stripped version of the program.

.NH 2
.ds IND1720 \*[SN-NO-DOT]
THE PRE-PARSING PHASE
.XS
\*(SN 			The pre-parsing phase
.XE
.LP

Option \fC-e\fR ('e' stands for 'extended debug') enables the debugging of the pre-parsing phase, and option \fC--verbose\fR increases the information given. During this phase, the following happens:

.IP *
Every \fCLABEL\fR is stored, removed from the code and printed in reverse colours. 

E.g.:
.fam C
 Stored label #1 LAB1 (2222, 6, 27)
.fam T

The three numbers in brackets are 1) the numeric code associated to the label (unique for each unique label); 2) the line where \fCLAB1\fR is put; 3) the position in the line where \fCLAB1\fR is put. These values are used by \fCGOTO\fR, to know exactly where to jump.

.IP *
\fCBEGIN-END\fR couples are searched, and their relative positions are stored internally, for fast execution; a message in reverse colours is printed for each couple (in verbose mode only), like this:

.fam C
 BEGIN [#1] at line 1 has:
 begin data: l=1, p=5
 end data  : l=22, p=0
.fam T

Each \fCBEGIN\fR must match one \fCEND\fR. An error is raised at the first unmatched couple.

.IP *
Every \fCPROCEDURE\fR is analyzed for what about: start and end of \fCPROCEDURE\fR body, type of the \fCPROCEDURE\fR (the number in square brackets is the type code), number and type of arguments (if any), and the proper \fCBEGIN-END\fR main cycle is stored (if any); a message in reverse colours is printed for each \fCPROCEDURE\fR like this:

.fam C
 PROCEDURE [#1] test at line 3 has:
 type = Real [20]
 arguments number = 2
   #1 X, real referenced variable
   #2 I, real valuated variable
 proc data : l=3, p=0
 begin data: l=5, p=0
 term data : l=8, p=3
.fam T

The lines data (the last three) are printed only in verbose mode. Notice that a \fIreferenced\fR variable is passed by name, a \fIvaluated\fR variable is passed using the \fCVALUE\fR specification.

.IP *
Every \fCIF-THEN\fR and every \fCIF-THEN-ELSE\fR are searched and found; the parser stores the position of the start of the condition expression, the position of \fCTHEN\fR (to call in case of true condition) and the position of \fCELSE\fR (to call in case of false condition); this last may be omitted; the termination position is saved to make a quick jump to the end of the decisional part; a message in reverse colours is printed (in verbose mode only ) for each \fCIF-THEN-ELSE\fR like this:

.fam C
 IF [#1] at line 12 has:
 cond data: l=12, p=2
 THEN data: l=12, p=9
 ELSE data: l=17, p=4
 term data: l=17, p=5
.fam T

and for each \fCIF-THEN\fR like this:

.fam C
 IF [#1] at line 12 has:
 cond data: l=12, p=2
 THEN data: l=12, p=9
 ELSE data: l=-1, p=-1
 term data: l=12, p=12
.fam T

where the \fCELSE\fR clause is absent.

.IP *
Every \fCFOR-DO\fR and \fCWHILE-DO\fR section are searched and found; the parser stores the position of the variable code (or variables list) of the \fCFOR\fR or the condition expression of \fCWHILE\fR, and the termination position, to jump to when the cycle is over. The inner calculations are evaluated at run-time; a message in reverse colours is printed (in verbose mode only) for each \fCFOR-DO\fR and \fCWHILE-DO\fR like these:

.fam C
 FOR [#3] at line 14 has:
 var data : l=14, p=3
 term data: l=20, p=3

 WHILE [#1] at line 11 has:
 cond data: l=11, p=5
 term data: l=18, p=3
.fam T

.IP *
Finally, the pre-parse phase coordinates the \fCPROCEDURE\fRs, according to the field of application; for instance, if \fCPROCEDURE A\fR defines procedure \fCB\fR inside its body (not in the main body), the following appears in reverse colours:

.fam C
 Procedures categorizing:
 set procedure B as subordinated to procedure A
.fam T

This message informs you that \fCB\fR cannot be called from the main body or any other procedures but only from within \fCA\fR.

At the end of the pre-parsing phase, the runtime debugging is enabled automatically (option \fC-d\fR, the run-time debugger), so there's no need to call both.

.NH 2
.ds IND1730 \*[SN-NO-DOT]
THE RUNTIME PHASE
.XS
\*(SN 			The runtime phase
.XE
.LP

Option \fC-d\fR enables the debugging of the runtime phase. During this phase, the following happens:

.IP *
Every line of code under execution is printed in reverse colours and tokenized blanks-stripped form, enclosed in square brackets. The output, if any, is printed in the next line, otherwise a blank line appears. For instance the program lines:

.fam C
 INTEGER X4; X4:=24;
 WRITE("X4  ="); PRINTLN(X4,4,2);
.fam T

show the following debug output:

.fam C
 [INTEGERX4]
 Declared X4 [#1], Type is integer
 
 [X4\[co]24;]
 
 [WRITE("X4  =")]
 X4  =
 [PRINTLN(X4,4,2);]
    24.00 
.fam T

If on the same line lie two or more instructions, the debugger shows the whole line but debugs the current instruction only.

The debug in itself ruins the output of the debugged program, because it clutters it with interspersed text. But after all, when everything gets smooth, the debug must not be invoked, so I judge this not relevant if the final scope is finding the mistake.

This debug technique, even if naive and simple, is very helpful, because it lets you examine the program flow to understand why the program does not do what you intended.

The various debug features are:

.IP *
Every variable declaration - even for a variable in the argument list of a \fCPROCEDURE\fR - shows its declarative assertion in reverse colours:

.fam C
 Declared X1 [#3], Type is real
 Declared X2 [#4], Type is Boolean
 Declared X3 [#5], Type is long real
 Declared X4 [#6], Type is integer
 Declared X5 [#7], Type is label
 Declared X6 [#8], Type is string
.fam T

If a \fCPROCEDURE\fR with a return value was declared, the following appears in reverse colours:

.fam C
 Declared fictitious variable A [#1], Type is real
.fam T

The 'fictitious' adjective focuses on the fact that this is not a real variable, but it represents the return value of the \fCPROCEDURE\fR, with the same name of the \fCPROCEDURE\fR.

.IP *
Every assignment to the fictitious variable is shown:

.fam C
 Assigned fictitious variable test [#1], Type is real, Value is 4.898979
.fam T

.IP *
\fCPROCEDURES\fR must be executed when invoked, but they must be ignored in the calling level when met consecutively in the source; in this case the message in reverse colours appears:

.fam C
 [REALPROCEDUREB;]
 Skipping procedure B
.fam T

This means: the line \fC'REAL PROCEDURE B'\fR was found and skipped, and a jump to the first instruction following it was executed.

.IP *
\fCIF..THEN..ELSE\fR declarations behave a little differently; when \fCIF\fR is evaluated, only the condition is printed in reverse colour; the evaluation of the \fCTHEN..ELSE\fR flag is done internally (and not reached by the debugger); then, on a different line the \fCTHEN\fR \fIor\fR the \fCELSE\fR part is printed, in reverse. 

E.g. this program piece

.fam C
 IF A=0 THEN WRITE("DON'T DO")
 ELSE WRITE("DO");
.fam T

is debugged, in case of false condition (suppose \fCA=1\fR):

.fam C
 [IFA=0]

 [WRITE("DO");]
 DO
.fam T

and is debugged, in case of true condition (\fCA=0\fR):

.fam C
 [IFA=0]

 [WRITE("DON'T DO")]
 DON'T DO
.fam T

Summing up, the \fCIF\fR condition is printed, and then follows the right executed part (the \fCTHEN\fR \fIor\fR the \fCELSE\fR part).

For the case where a \fCBEGIN-END\fR block follows \fCTHEN\fR or \fCELSE\fR, it is debugged as usual.

.NH 2
.ds IND1740 \*[SN-NO-DOT]
USING STEP-BY-STEP TRACING
.XS
\*(SN 			Using step-by-step tracing
.XE
.LP

Using the two procedures \fCONTRACE\fR and \fCOFFTRACE\fR the programmer can enable the debugging on a specific part of the code, and not on the entire code. This second debugging technique shows the same lines of the classic debugger, but it stops at every procedure token (stop-mode), waiting for the programmer's intervention. 

The commands available by the programmer are one-key characters (not echoed) that perform some specific actions:

\fBCommand H - help\fR
.br
By hitting the key \fBH\fR, the programmer will see a help screen that summarizes the commands of the debugger.

\fBCommand C - continue\fR
.br
By hitting the key \fBC\fR, the programmer will istruct the debugger to continue in debug mode, disabling the stop-mode; the execution will proceed until the end of the execution as if started with option \fC-d\fR (until the final \fCEND\fR or until the next \fCOFFTRACE\fR).

\fBCommand G - go\fR
.br
By hitting the key \fBG\fR, the programmer will istruct the debugger to continue disabling the debug and the stop-mode as well; the execution will proceed until its natural end in normal mode.

\fBCommand X - exit\fR
.br
By hitting the key \fBX\fR, the programmer will instruct the debugger to stop immediately the execution. It's like a \fCSTOP\fR, with the difference that the string

\fC(terminated)\fR

appears before the stop takes place, to signal that the execution was stopped by the programmer and not by the program itself. All closing procedures are anyway executed (file closing, memory freeing, etc.).

\fBCommand V - dump variable\fR
.br
By hitting the key \fBV\fR, the programmer will see a \fC>\fR at the start of the line to signal that he can input a variable name. This name is searched in the current context and, if found, variable is shown (as if \fCDUMP\fR was called upon it). If the variable does not exist or is out of scope, this is simply reported, with no effect on the execution.

\fBCommand P - dump procedure\fR
.br
By hitting the key \fBP\fR, the programmer will see a \fC>\fR at the start of the line to signal that he can input a procedure name. This name is searched in the current context and, if found, the procedure data are displayed as in option \fC-e\fR (option \fC--verbose\fR increases the information amount). If the procedure does not exist or is out of scope, this is simply reported, with no effect on the execution.

\fBAny other key\fR
.br
By hitting any other key (space bar included) the debugger will step to the next token and will executed its procedure, along with the printing of the debug line.
.LP

In all a simple debugger that helps a lot, at least I think so.
 
.bp
.NH 1
.ds IND1750 \*[SN-NO-DOT]
IN THE END...
.XS
\*(SN 		\fBIn the end...\fR
.XE
.LP
This program was designed, written and implemented just for fun. I'm not a professional programmer. But I like programming a lot. So here it is.

Infinite thanks to \fBIan Jones\fR, a friend and a great tester, who compiled and ran taxi an incredibly high number of times, finding all sort of errors in the listings. He's been the mechanic of \fHtaxi\fR!

Infinite thanks also to Bruce Axtens, who's always shown great willingness to help me; he is the master of the Windows world, the one who compiles my programs for Unix and makes them available for the Redmond operating system. He's a programmer, and he's able to spot bugs faster than a blink.

\fBCAVEAT\fR: \fIThis text was written starting from the 1977 version of the DEC system-10/20 ALGOL programmer's Guide AA-O196C-TK, changing and updating the not complying parts, integrated with the ISO 1538-1984 features, quoting it from time to time. If owners of the copyrights of the cited documents should require any modification, I ask them to let me know, for the appropriated changes to be applied to this manual.\fR

This manual was written using gvim and it was type-processed using groff. If you find errors or if you don't like something, it's entirely my fault.

If you find any bugs, write to <ing dot antonio dot maschio at gmail dot com>, don't hesitate. I'll try to solve the bugs as soon as possible.

Two things are still to be said: 

the first is that I hope you like \fHtaxi\fR. 

The second is: it's GPL, enjoy! \[HE]
.bp
.NS 
Appendix 1: CONCEPTS INDEX
.XS
Appendix 1	\fBConcepts index\fR
.XE
.LP

.ps 8
NOTE: in the following, index numbers refer to chapters, not page numbers; e.g. 2.3, 5.2.1
.LP

.MC
.ps 8
   Advanced use of procedures \*[IND730]
   ALGOL history \*[IND10]
   ALGOL literature \*[IND50]
   Arithmetic expression \*[IND320]
   Arithmetic operators \*[IND380]
   Array declarations \*[IND610]
   Array dimensioning \*[IND1450]
   Array I/O \*[IND1350]
   Array elements \*[IND620]
   Arrays bound pair \*[IND1610]
   ASCII constants \*[IND290]
   Assignments \*[IND440]
   Basic symbols \*[IND120]
   Block structure \*[IND630]
   Boolean constants \*[IND280]
   Boolean expressions \*[IND350]
   Boolean operators \*[IND360]
   Boolean variables \*[IND370]
   Boolean/Integer conversion \*[IND1410]
   Boy interpreter \*[IND60]
   Break and continue simulation \*[IND780]
   Byte subscripting \*[IND950]
   Calculation issues \*[IND90]
   Case sensitiveness \*[IND00], \*[IND190], \*[IND660]
   Channels \*[IND1160], \*[IND1170]
   Commentary \*[IND160], \*[IND830]
   Compiling taxi \*[IND70]
   Compound statements \*[IND480]
   Compound symbols \*[IND130]
   Conditional expressions \*[IND1060]
   Conditional statements \*[IND520], \*[IND1060], \*[IND1100] 
   Constants (literals) \*[IND210]
   Cycling procedures \*[IND530]
   Dangling ELSE case \*[IND520]
   Data I/O \*[IND1160], \*[IND1260], \*[IND1480]
   Date procedures \*[IND1520]
   Debugging \*[IND1540], \*[IND1550], \*[IND1710]
   DEC enhancements \*[IND30]
   DEC restrictions \*[IND20]
   DEC/ISO differences \*[IND40], \*[IND1660]
   Declaration \*[IND200], \*[IND610]
   Default I/O \*[IND1360], \*[IND1670]
   Delimiter words \*[IND100]
   Designational expressions \*[IND1110]
   Devices \*[IND1170]
   Device allocation \*[IND1170]
   Device release \*[IND1250]
   Differences (ISO) \*[IND1240]
   Dynamic bound arrays \*[IND650]
   Enhancements (DEC) \*[IND30]
   Execution details \*[IND80]
   Execution timing \*[IND1510]
   Expressions evaluation \*[IND470]
   Expressions \*[IND310]
   External procedures \*[IND820]
   Field manipulation \*[IND1470]
   File devices \*[IND1210]
   Files transfer \*[IND1390]
   Foreign operators \*[IND390]
   General Problem Solver (GPS) \*[IND760]
   History of ALGOL \*[IND10]
   I/O channels status \*[IND1380]
   I/O procedures 16.7, 17.4
   I/O selection \*[IND1400], 16.12
   Identifiers \*[IND100], \*[IND190], \*[IND330]
   Information procedure \*[IND1500]
   Input/Output \*[IND1360], \*[IND1370], \*[IND1380] 
   Integer constants \*[IND230]
   Integer/Boolean conversion \*[IND410]
   Interface procedures \*[IND1490]
   ISO additions \*[IND1560], \*[IND1640]
   ISO compatibility \*[IND1560]
   ISO differences \*[IND1240]
   ISO Error testing \*[IND1610]
   ISO Escape characters \*[IND1650]
   ISO Exponentiation \*[IND1590]
   ISO I/O procedures \*[IND1620]
   ISO inquiries \*[IND1630]
   ISO integer procedures \*[IND1580]
   ISO math procedures \*[IND1590]
   ISO terminating procedures \*[IND1600]
   ISO/DEC differences \*[IND40], \*[IND1660]
   Jensen's device \*[IND750]
   Labels \*[IND100], \*[IND500]
   Label constants \*[IND300]
   Layout of declarations \*[IND790]
   Layout of procedures \*[IND800]
   Lines structure \*[IND170]
   Local variable \*[IND640]
   Logical device \*[IND1370]
   Logical expression \*[IND350]
   Logical I/O \*[IND1370]
   Logical operators \*[IND360]
   Logical variables \*[IND370]
   Long real constants \*[IND250]
   Machine token \*[IND400]
   Math library procedures \*[IND1430]
   Maxima procedure \*[IND1460]
   Minima procedure \*[IND1460]
   Multiple assignments \*[IND450]
   Null strings \*[IND960]
   Numeric constants \*[IND220]
   Numeric output \*[IND1320]
   Numeric storage \*[IND260]
   Octal constants \*[IND270]
   Octal I/O \*[IND1340]
   Operators precedence \*[IND360], \*[IND470]
   Own arrays \*[IND1140]
   Own variables \*[IND1130]
   Parameter by "name" \*[IND680], \*[IND740]
   Parameter by "value" \*[IND670]
   Parameters \*[IND100]
   Parenthesized assignments \*[IND460]
   Pre-parsing phase debug \*[INF1720]
   Precedence of operators \*[IND360], \*[IND470]
   Procedure bodies \*[IND700]
   Procedure calls \*[IND710]
   Procedure headings \*[IND690]
   Procedure scopes \*[IND720]
   Procedures \*[IND100], \*[IND660]
   Random generation procedures \*[IND1530]
   Real Constants \*[IND240]
   Recursion \*[IND770]
   Reserved words \*[IND140]
   Restrictions (DEC) \*[IND20]
   Runtime phase debug \*[IND1730]
   Running process \*[IND80]
   Scalar declarations \*[IND200]
   Spacing \*[IND160]
   Special procedures \*[IND340] 
   Statements \*[IND430]
   Storage (numbers) \*[IND260]
   String assignments \*[IND930]
   String comparison \*[IND970]
   String constants \*[IND300]
   String expressions \*[IND930]
   String library procedures \*[IND980], \*[IND1430]
   String output \*[IND1330]
   Strings \*[IND910]
   Switches \*[IND870]
   Terminator words \*[IND100], \*[IND140]
   Terminology \*[IND100]
   Time procedures \*[IND1510]
   Tracing \*[IND1540], \*[IND1740]
   Transferring files \*[IND1390]
   Types \*[IND200]
   Unconditional jumps \*[IND510]
   Variables declaration \*[IND200]
   Variables names warning \*[IND150]
   Variables scope \*[IND630]

.1C

.NS 1 
Appendix 2: LANGUAGE ELEMENTS INDEX
.XS
Appendix 2	\fBLanguage elements index\fR
.XE
.LP
NOTE: in the following index:
.IP -
names in upper case bold characters denote reserved procedures and structures identifiers. E.g.
.fam C
.B FOR
.B BEGIN
.B REAL
.fam T
.IP -
names in upper case italic characters denote non-reserved procedures and constants identifiers. E.g.
.fam C
.I PRINT()
.I OUTPUT()
.I EPSILON
.fam T
.IP - 
names in lower case bold characters denote math operators identifiers and symbols. E.g. 
.fam C
.B and
.B eqv
.B :=
.B <
.B =>
.fam T
.IP - 
index numbers refer to chapters, not page numbers. E.g. 2.3, 5.2.1

.fam C
   \fB!\fR\fC (comment) \*[IND120], \*[IND160] 
   \fB!=\fR\fC (inequality) \*[IND390]
   \fB#\fR\fC (inequality) \*[IND120], \*[IND380], \*[IND390], \*[IND400]
   \fB%\fR\fC (octal constant) \*[IND120], \*[IND270]
   \fB%\fR\fC (remainder) \*[IND390]
   \fB*\fR\fC (multiplication) \*[IND320]
   \fB**\fR\fC (exponentiation) \*[IND320]
   \fB+\fR\fC (sign and addition) \*[IND320]
   \fB-\fR\fC (sign and subtraction) \*[IND320]
   \fB->\fR\fC (implication) \*[IND360], \*[IND390]
   \fB/\fR\fC (division) \*[IND320]
   \fB/\\\fR\fC (ISO 'and') \*[IND40], \*[IND360], \*[IND400]
   \fB:\fR\fC (ARRAY indices separator) \*[IND610]
   \fB:\fR\fC (LABEL designator) \*[IND500]
   \fB:=\fR\fC (assignment) \*[IND130], \*[IND400],  \*[IND450]
   \fB<\fR\fC (lesser than) \*[IND120], \*[IND470]
   \fB<-\fR\fC (assignment) \*[IND120]
   \fB<->\fR\fC (equivalence) \*[IND390]
   \fB<=\fR\fC (lesser or equal) \*[IND130], \*[IND370], \*[IND470]
   \fB<>\fR\fC (inequality) \*[IND130]
   \fB=\fR\fC (equality) \*[IND120], \*[IND380], \*[IND470]
   \fB=<\fR\fC (lesser or equal) \*[IND390]
   \fB==\fR\fC (equivalence) \*[IND130], \*[IND470]
   \fB=>\fR\fC (greater or equal) \*[IND390]
   \fB>\fR\fC (greater than) \*[IND120], \*[IND380], \*[IND470]
   \fB><\fR\fC (inequality) \*[IND390]
   \fB>=\fR\fC (greater or equal) \*[IND130], \*[IND370], \*[IND470]
   \fB>>\fR\fC (implication) \*[IND390]
   \fB\[di]\fR\fC (ISO 'div') \*[IND120], \*[IND320], \*[IND470] 
   \fB\[md]\fR\fC (dot math) \*[IND220]
   \fB\\\fR\fC ('div') \*[IND120], \*[IND320], \*[IND470]
   \fB\\/\fR\fC (ISO 'or') \*[IND40], \*[IND130], \*[IND360]
   \fB^\fR\fC (exponentiation) \*[IND120], \*[IND330], \*[IND470]
   \fB~\fR\fC (tilde, ISO 'not') \*[IND120], \*[IND360]
   \fB~=\fR\fC (inequality) \*[IND130], \*[IND380]
   \fIABS()\fR\fC \*[IND340], \*[IND1430], \*[IND1580]
   \fBand\fR\fC \*[IND360], \*[IND380], \*[IND470]
   \fIARCCOS()\fR\fC \*[IND1430]
   \fIARCCOSEC()\fR\fC \*[IND1430]
   \fIARCCOSECH()\fR\fC \*[IND1430]
   \fIARCCOSH()\fR\fC \*[IND1430]
   \fIARCCOTAN()\fR\fC \*[IND1430]
   \fIARCCOTANH()\fR\fC \*[IND1430]
   \fIARCSEC()\fR\fC \*[IND1430]
   \fIARCSECH()\fR\fC \*[IND1430]
   \fIARCSINH()\fR\fC \*[IND1430]
   \fIARCSIN()\fR\fC \*[IND1430]
   \fIARCTAN()\fR\fC \*[IND1430], \*[IND1590]
   \fIARCTANH()\fR\fC \*[IND1430]
   \fBARRAY\fR\fC \*[IND140], \*[IND590]
   \fBBEGIN\fR\fC \*[IND100], \*[IND140], \*[IND480], \*[IND640]
   \fIBOOL()\fR\fC \*[IND410]
   \fBBOOLEAN\fR\fC \*[IND140], \*[IND200]
   \fIBREAKOUTPUT\fR\fC \*[IND1270]
   \fICALL()\fR\fC \*[IND1490]
   \fICLOCK()\fR\fC \*[IND1510]
   \fICLOSEFILE()\fR\fC \*[IND1210]
   \fBCOMMENT\fR\fC \*[IND140], \*[IND160]
   \fICONCAT()\fR\fC \*[IND990]
   \fICONVERT()\fR\fC \*[IND1050]
   \fICOPY()\fR\fC \*[IND1010]
   \fICOS()\fR\fC \*[IND1430], \*[IND1590]
   \fICOSEC()\fR\fC \*[IND1430]
   \fICOSECH()\fR\fC \*[IND1430]
   \fICOSH()\fR\fC \*[IND1430]
   \fICOTAN()\fR\fC \*[IND1430]
   \fICOTANH()\fR\fC \*[IND1430]
   \fICREATEFILE()\fR\fC \*[IND1230]
   \fIDEGREES\fR\fC \*[IND1430]
   \fIDELETE()\fR\fC \*[IND1030]
   \fIDIM()\fR\fC \*[IND1450]
   \fBdiv\fR\fC \*[IND320], \*[IND330], \*[IND470]
   \fBDO\fR\fC \*[IND540], \*[IND570]
   \fIDROP()\fR\fC \*[IND1040]
   \fBDUMP\fR\fC \*[IND140], \*[IND1550]
   \fBELSE\fR\fC \*[IND100], \*[IND140], \*[IND520], \*[IND1080]
   \fBEND\fR\fC \*[IND100], \*[IND140], \*[IND480], \*[IND630]
   \fIENTIER()\fR\fC \*[IND430], \*[IND1430], \*[IND1580]
   \fIEPSILON\fR\fC (constant) \*[IND1630]
   \fBeqiv\fR\fC (equivalence) \*[IND390]
   \fBeql\fR\fC (equality) \*[IND390]
   \fBeqv\fR\fC (equivalence) \*[IND130], \*[IND360], \*[IND380]
   \fIERF\fR\fC \*[IND1430]
   \fIERRC\fR\fC \*[IND1640]
   \fIERRL\fR\fC \*[IND1640]
   \fIEXP()\fR\fC \*[IND1430], \*[IND1590]
   \fIEXPI()\fR\fC \*[IND1590]
   \fIEXPN()\fR\fC \*[IND1590]
   \fIEXPR()\fR\fC \*[IND1590] 
   \fBEXTERNAL\fR\fC \*[IND140], \*[IND820]
   \fBFALSE\fR\fC (constant) \*[IND280], \*[IND370]
   \fIFAULT()\fR\fC \*[IND1600]
   \fIFDATE\fR\fC \*[IND1520]
   \fBFOR\fR\fC \*[IND140], \*[IND540]
   \fBFORWARD\fR\fC \*[IND140], \*[IND810]
   \fIGAMMA\fR\fC \*[IND1430]
   \fBgeq\fR\fC (greater or equal) \*[IND390]
   \fIGFIELD()\fR\fC \*[IND1470]
   \fBGO TO/GOTO\fR\fC \*[IND140], \*[IND300], \*[IND510], \*[IND900]
   \fBgtr\fR\fC (greater than) \*[IND390]
   \fIHEAD()\fR\fC \*[IND1040]
   \fIIABS()\fR\fC \*[IND1580]
   \fBIF\fR\fC \*[IND140], \*[IND440], \*[IND520], \*[IND1090]
   \fIIMAX()\fR\fC \*[IND1460]
   \fIIMIN()\fR\fC \*[IND1460]
   \fBimp\fR\fC (implication) \*[IND360], \*[IND470]
   \fBimpl\fR\fC (implication) \*[IND390]
   \fIINCHAN\fR\fC \*[IND1400]
   \fIINCHAR()\fR\fC \*[IND1620]
   \fIINCHARACTER()\fR\fC \*[IND1640]
   \fBINCLUDE\fR\fC \*[IND140], \*[IND820]
   \fIINF\fR\fC (constant) \*[IND1630]
   \fIINFINITY\fR\fC (constant) \*[IND1630]
   \fIINFO()\fR\fC \*[IND1500]
   \fIININTEGER()\fR\fC \*[IND1620]
   \fIINLONGREAL()\fR\fC \*[IND1640]
   \fIINPUT()\fR\fC \*[IND1170], \*[IND1210], \*[IND1370]
   \fIINREAL()\fR\fC \*[IND1620]
   \fIINSTRING()\fR\fC \*[IND1640]
   \fIINSYMBOL()\fR\fC \*[IND1270]
   \fIINT()\fR\fC \*[IND410]
   \fBINTEGER\fR\fC \*[IND140], \*[IND200]
   \fIINTEGRAL()\fR\fC \*[IND1430]
   \fIIOCHAN()\fR\fC \*[IND1380]
   \fBLABEL\fR\fC \*[IND140], \*[IND200], \*[IND300]
   \fILARCTAN()\fR\fC \*[IND1430]
   \fILB()\fR\fC \*[IND1450]
   \fILCOS()\fR\fC \*[IND1430]
   \fILENGTH()\fR\fC \*[IND1000], \*[IND1430]
   \fBleq\fR\fC (lesser or equal) \*[IND390]
   \fILEXP()\fR\fC \*[IND1430]
   \fILLN()\fR\fC \*[IND1430]
   \fILMAX()\fR\fC \*[IND1460]
   \fILMIN()\fR\fC \*[IND1460]
   \fILN()\fR\fC \*[IND1430], \*[IND1590]
   \fBLONG REAL\fR\fC \*[IND140], \*[IND200]
   \fILONGEPSILON\fR\fC \*[IND1630]
   \fILSIN()\fR\fC \*[IND1430]
   \fILSQRT()\fR\fC \*[IND1430]
   \fBlss\fR\fC (lesser than) \*[IND390]
   \fIMAXINT\fR\fC (constant) \*[IND1630]
   \fIMAXLONGREAL\fR\fC \*[IND1630]
   \fIMAXREAL\fR\fC (constant) \*[IND1630]
   \fIMININT\fR\fC (constant) \*[IND1630]
   \fIMINLONGREAL\fR\fC \*[IND1630]
   \fIMINREAL\fR\fC (constant) \*[IND1630]
   \fBmod\fR\fC (remainder) \*[IND320], \*[IND330], \*[IND470]
   \fBneq\fR\fC (inequality) \*[IND390]
   \fINEWLINE\fR\fC \*[IND1290]
   \fINEWSTRING()\fR\fC \*[IND1020]
   \fINEXTSYMBOL()\fR\fC \*[IND1270]
   \fBnot\fR\fC \*[IND40], \*[IND120],  \*[IND360], \*[IND470]
   \fBnotequal\fR\fC \*[IND380]
   \fIOFFTRACE\fR\fC \*[IND1540]
   \fIONTRACE\fR\fC \*[IND1540]
   \fIOPENFILE()\fR\fC \*[IND1210]
   \fBor\fR\fC \*[IND360], \*[IND380], \*[IND470]
   \fIOUTBOOLEAN()\fR\fC \*[IND1640]
   \fIOUTCHAN()\fR\fC \*[IND1400]
   \fIOUTCHAR()\fR\fC \*[IND1620]
   \fIOUTCHARACTER()\fR\fC \*[IND1640]
   \fIOUTINTEGER()\fR\fC \*[IND1620]
   \fIOUTLONGREAL()\fR\fC \*[IND1640]
   \fIOUTPUT()\fR\fC \*[IND1170], \*[IND1210], \*[IND1370]
   \fIOUTREAL()\fR\fC \*[IND1620]
   \fIOUTSTRING()\fR\fC \*[IND1620]
   \fIOUTSYMBOL()\fR\fC \*[IND1270]
   \fIOUTTERMINATOR()\fR\fC \*[IND1620]
   \fBOWN\fR\fC \*[IND140], \*[IND1120]
   \fIPAGE\fR\fC \*[IND1290]
   \fBPAUSE\fR\fC \*[IND1541]
   \fIPI\fR\fC (constant) \*[IND1630]
   \fIPRINT()\fR\fC \*[IND1320]
   \fIPRINTLN()\fR\fC \*[IND1320]
   \fIPRINTOCTAL()\fR\fC \*[IND1340]
   \fBPROCEDURE\fR\fC \*[IND140], \*[IND660]
   \fIRADIANS\fR\fC \*[IND1430]
   \fIRAND\fR\fC \*[IND1530]
   \fIREAD()\fR\fC \*[IND940], \*[IND1310]
   \fIREADOCTAL()\fR\fC \*[IND1340]
   \fBREAL\fR\fC \*[IND140], \*[IND200]
   \fIRELEASE()\fR\fC \*[IND1170], \*[IND1250]
   \fBrem\fR\fC \*[IND320], \*[IND330], \*[IND470]
   \fIRMAX()\fR\fC \*[IND1460]
   \fIRMIN()\fR\fC \*[IND1460]
   \fISAVRAN\fR\fC \*[IND1530]
   \fISELECTINPUT()\fR\fC \*[IND1240]
   \fISELECTOUTPUT()\fR\fC \*[IND1240]
   \fISETRAN\fR\fC \*[IND1530]
   \fISFIELD()\fR\fC \*[IND1470]
   \fISIGN()\fR\fC \*[IND340], \*[IND1580]
   \fISEC()\fR\fC \*[IND1430]
   \fISECH()\fR\fC \*[IND1430]
   \fISIN()\fR\fC \*[IND1430], \*[IND1590]
   \fISINH()\fR\fC \*[IND1430]
   \fISIZE()\fR\fC \*[IND1000]
   \fISKIPSYMBOL\fR\fC \*[IND1270]
   \fISPACE()\fR\fC \*[IND1290]
   \fISQRT()\fR\fC \*[IND1430], \*[IND1590]
   \fBSTEP\fR\fC \*[IND140], \*[IND540], \*[IND1550]
   \fISTOP\fR\fC \*[IND1600]
   \fBSTRING\fR\fC \*[IND140], \*[IND200]
   \fBSWITCH\fR\fC \*[IND140], \*[IND870]
   \fITAB\fR\fC \*[IND1290]
   \fITAKE()\fR\fC \*[IND1040]
   \fITAIL()\fR\fC \*[IND1040]
   \fITAN()\fR\fC \*[IND1430]
   \fITANH()\fR\fC \*[IND1430]
   \fBTHEN\fR\fC \*[IND140], \*[IND520], \*[IND1080], \*[1090]
   \fITIME\fR\fC \*[IND1520]
   \fITRANSFILE\fR\fC \*[IND1390]
   \fBTRUE\fR\fC (constant) \*[IND280], \*[IND370]
   \fIUB()\fR\fC \*[IND1450]
   \fBUNTIL\fR\fC \*[IND140], \*[IND540], \*[IND550]
   \fBVALUE\fR\fC \*[IND140], \*[IND670]
   \fIVDATE\fR\fC \*[IND1520]
   \fIVPRINT()\fR\fC \*[IND1640]
   \fBWHILE\fR\fC (FOR element) \*[IND140], \*[IND540], \*[IND550]
   \fBWHILE\fR\fC \*[IND140], \*[IND570]
   \fIWRITE()\fR\fC \*[IND1330]
   \fIWRITELN()\fR\fC \*[IND1330]
.fam T
.1C
.TC
